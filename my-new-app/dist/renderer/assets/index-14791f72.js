(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function i(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(s){if(s.ep)return;s.ep=!0;const a=i(s);fetch(s.href,a)}})();function hh(t,e){const i=Object.create(null),r=t.split(",");for(let s=0;s<r.length;s++)i[r[s]]=!0;return e?s=>!!i[s.toLowerCase()]:s=>!!i[s]}const Xe={},Os=[],_i=()=>{},wg=()=>!1,Sg=/^on[^a-z]/,go=t=>Sg.test(t),uh=t=>t.startsWith("onUpdate:"),yt=Object.assign,ch=(t,e)=>{const i=t.indexOf(e);i>-1&&t.splice(i,1)},Eg=Object.prototype.hasOwnProperty,Re=(t,e)=>Eg.call(t,e),pe=Array.isArray,Da=t=>mo(t)==="[object Map]",Tg=t=>mo(t)==="[object Set]",Ae=t=>typeof t=="function",Ct=t=>typeof t=="string",po=t=>typeof t=="symbol",$e=t=>t!==null&&typeof t=="object",ed=t=>($e(t)||Ae(t))&&Ae(t.then)&&Ae(t.catch),Bg=Object.prototype.toString,mo=t=>Bg.call(t),Dg=t=>mo(t).slice(8,-1),Rg=t=>mo(t)==="[object Object]",dh=t=>Ct(t)&&t!=="NaN"&&t[0]!=="-"&&""+parseInt(t,10)===t,Dn=hh(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Ao=t=>{const e=Object.create(null);return i=>e[i]||(e[i]=t(i))},Mg=/-(\w)/g,Qi=Ao(t=>t.replace(Mg,(e,i)=>i?i.toUpperCase():"")),Pg=/\B([A-Z])/g,ta=Ao(t=>t.replace(Pg,"-$1").toLowerCase()),_o=Ao(t=>t.charAt(0).toUpperCase()+t.slice(1)),Oo=Ao(t=>t?`on${_o(t)}`:""),cs=(t,e)=>!Object.is(t,e),No=(t,e)=>{for(let i=0;i<t.length;i++)t[i](e)},Yn=(t,e,i)=>{Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:i})},Ug=t=>{const e=parseFloat(t);return isNaN(e)?t:e};let ou;const hl=()=>ou||(ou=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function fh(t){if(pe(t)){const e={};for(let i=0;i<t.length;i++){const r=t[i],s=Ct(r)?Fg(r):fh(r);if(s)for(const a in s)e[a]=s[a]}return e}else if(Ct(t)||$e(t))return t}const Lg=/;(?![^(]*\))/g,Og=/:([^]+)/,Ng=/\/\*[^]*?\*\//g;function Fg(t){const e={};return t.replace(Ng,"").split(Lg).forEach(i=>{if(i){const r=i.split(Og);r.length>1&&(e[r[0].trim()]=r[1].trim())}}),e}function gh(t){let e="";if(Ct(t))e=t;else if(pe(t))for(let i=0;i<t.length;i++){const r=gh(t[i]);r&&(e+=r+" ")}else if($e(t))for(const i in t)t[i]&&(e+=i+" ");return e.trim()}const kg="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Qg=hh(kg);function td(t){return!!t||t===""}let Kt;class id{constructor(e=!1){this.detached=e,this._active=!0,this.effects=[],this.cleanups=[],this.parent=Kt,!e&&Kt&&(this.index=(Kt.scopes||(Kt.scopes=[])).push(this)-1)}get active(){return this._active}run(e){if(this._active){const i=Kt;try{return Kt=this,e()}finally{Kt=i}}}on(){Kt=this}off(){Kt=this.parent}stop(e){if(this._active){let i,r;for(i=0,r=this.effects.length;i<r;i++)this.effects[i].stop();for(i=0,r=this.cleanups.length;i<r;i++)this.cleanups[i]();if(this.scopes)for(i=0,r=this.scopes.length;i<r;i++)this.scopes[i].stop(!0);if(!this.detached&&this.parent&&!e){const s=this.parent.scopes.pop();s&&s!==this&&(this.parent.scopes[this.index]=s,s.index=this.index)}this.parent=void 0,this._active=!1}}}function rd(t){return new id(t)}function zg(t,e=Kt){e&&e.active&&e.effects.push(t)}function sd(){return Kt}function Gg(t){Kt&&Kt.cleanups.push(t)}const ph=t=>{const e=new Set(t);return e.w=0,e.n=0,e},ad=t=>(t.w&Tr)>0,nd=t=>(t.n&Tr)>0,Vg=({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=Tr},Hg=t=>{const{deps:e}=t;if(e.length){let i=0;for(let r=0;r<e.length;r++){const s=e[r];ad(s)&&!nd(s)?s.delete(t):e[i++]=s,s.w&=~Tr,s.n&=~Tr}e.length=i}},Xn=new WeakMap;let pa=0,Tr=1;const ul=30;let pi;const ss=Symbol(""),cl=Symbol("");class mh{constructor(e,i=null,r){this.fn=e,this.scheduler=i,this.active=!0,this.deps=[],this.parent=void 0,zg(this,r)}run(){if(!this.active)return this.fn();let e=pi,i=Cr;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=pi,pi=this,Cr=!0,Tr=1<<++pa,pa<=ul?Vg(this):lu(this),this.fn()}finally{pa<=ul&&Hg(this),Tr=1<<--pa,pi=this.parent,Cr=i,this.parent=void 0,this.deferStop&&this.stop()}}stop(){pi===this?this.deferStop=!0:this.active&&(lu(this),this.onStop&&this.onStop(),this.active=!1)}}function lu(t){const{deps:e}=t;if(e.length){for(let i=0;i<e.length;i++)e[i].delete(t);e.length=0}}let Cr=!0;const od=[];function ia(){od.push(Cr),Cr=!1}function ra(){const t=od.pop();Cr=t===void 0?!0:t}function Gt(t,e,i){if(Cr&&pi){let r=Xn.get(t);r||Xn.set(t,r=new Map);let s=r.get(i);s||r.set(i,s=ph()),ld(s)}}function ld(t,e){let i=!1;pa<=ul?nd(t)||(t.n|=Tr,i=!ad(t)):i=!t.has(pi),i&&(t.add(pi),pi.deps.push(t))}function rr(t,e,i,r,s,a){const o=Xn.get(t);if(!o)return;let l=[];if(e==="clear")l=[...o.values()];else if(i==="length"&&pe(t)){const h=Number(r);o.forEach((u,c)=>{(c==="length"||!po(c)&&c>=h)&&l.push(u)})}else switch(i!==void 0&&l.push(o.get(i)),e){case"add":pe(t)?dh(i)&&l.push(o.get("length")):(l.push(o.get(ss)),Da(t)&&l.push(o.get(cl)));break;case"delete":pe(t)||(l.push(o.get(ss)),Da(t)&&l.push(o.get(cl)));break;case"set":Da(t)&&l.push(o.get(ss));break}if(l.length===1)l[0]&&dl(l[0]);else{const h=[];for(const u of l)u&&h.push(...u);dl(ph(h))}}function dl(t,e){const i=pe(t)?t:[...t];for(const r of i)r.computed&&hu(r);for(const r of i)r.computed||hu(r)}function hu(t,e){(t!==pi||t.allowRecurse)&&(t.scheduler?t.scheduler():t.run())}function Yg(t,e){var i;return(i=Xn.get(t))==null?void 0:i.get(e)}const Xg=hh("__proto__,__v_isRef,__isVue"),hd=new Set(Object.getOwnPropertyNames(Symbol).filter(t=>t!=="arguments"&&t!=="caller").map(t=>Symbol[t]).filter(po)),uu=Kg();function Kg(){const t={};return["includes","indexOf","lastIndexOf"].forEach(e=>{t[e]=function(...i){const r=Be(this);for(let a=0,o=this.length;a<o;a++)Gt(r,"get",a+"");const s=r[e](...i);return s===-1||s===!1?r[e](...i.map(Be)):s}}),["push","pop","shift","unshift","splice"].forEach(e=>{t[e]=function(...i){ia();const r=Be(this)[e].apply(this,i);return ra(),r}}),t}function Wg(t){const e=Be(this);return Gt(e,"has",t),e.hasOwnProperty(t)}class ud{constructor(e=!1,i=!1){this._isReadonly=e,this._shallow=i}get(e,i,r){const s=this._isReadonly,a=this._shallow;if(i==="__v_isReactive")return!s;if(i==="__v_isReadonly")return s;if(i==="__v_isShallow")return a;if(i==="__v_raw"&&r===(s?a?op:gd:a?fd:dd).get(e))return e;const o=pe(e);if(!s){if(o&&Re(uu,i))return Reflect.get(uu,i,r);if(i==="hasOwnProperty")return Wg}const l=Reflect.get(e,i,r);return(po(i)?hd.has(i):Xg(i))||(s||Gt(e,"get",i),a)?l:je(l)?o&&dh(i)?l:l.value:$e(l)?s?md(l):sa(l):l}}class cd extends ud{constructor(e=!1){super(!1,e)}set(e,i,r,s){let a=e[i];if(Hs(a)&&je(a)&&!je(r))return!1;if(!this._shallow&&(!Kn(r)&&!Hs(r)&&(a=Be(a),r=Be(r)),!pe(e)&&je(a)&&!je(r)))return a.value=r,!0;const o=pe(e)&&dh(i)?Number(i)<e.length:Re(e,i),l=Reflect.set(e,i,r,s);return e===Be(s)&&(o?cs(r,a)&&rr(e,"set",i,r):rr(e,"add",i,r)),l}deleteProperty(e,i){const r=Re(e,i);e[i];const s=Reflect.deleteProperty(e,i);return s&&r&&rr(e,"delete",i,void 0),s}has(e,i){const r=Reflect.has(e,i);return(!po(i)||!hd.has(i))&&Gt(e,"has",i),r}ownKeys(e){return Gt(e,"iterate",pe(e)?"length":ss),Reflect.ownKeys(e)}}class jg extends ud{constructor(e=!1){super(!0,e)}set(e,i){return!0}deleteProperty(e,i){return!0}}const qg=new cd,Jg=new jg,Zg=new cd(!0),Ah=t=>t,vo=t=>Reflect.getPrototypeOf(t);function on(t,e,i=!1,r=!1){t=t.__v_raw;const s=Be(t),a=Be(e);i||(cs(e,a)&&Gt(s,"get",e),Gt(s,"get",a));const{has:o}=vo(s),l=r?Ah:i?xh:Ka;if(o.call(s,e))return l(t.get(e));if(o.call(s,a))return l(t.get(a));t!==s&&t.get(e)}function ln(t,e=!1){const i=this.__v_raw,r=Be(i),s=Be(t);return e||(cs(t,s)&&Gt(r,"has",t),Gt(r,"has",s)),t===s?i.has(t):i.has(t)||i.has(s)}function hn(t,e=!1){return t=t.__v_raw,!e&&Gt(Be(t),"iterate",ss),Reflect.get(t,"size",t)}function cu(t){t=Be(t);const e=Be(this);return vo(e).has.call(e,t)||(e.add(t),rr(e,"add",t,t)),this}function du(t,e){e=Be(e);const i=Be(this),{has:r,get:s}=vo(i);let a=r.call(i,t);a||(t=Be(t),a=r.call(i,t));const o=s.call(i,t);return i.set(t,e),a?cs(e,o)&&rr(i,"set",t,e):rr(i,"add",t,e),this}function fu(t){const e=Be(this),{has:i,get:r}=vo(e);let s=i.call(e,t);s||(t=Be(t),s=i.call(e,t)),r&&r.call(e,t);const a=e.delete(t);return s&&rr(e,"delete",t,void 0),a}function gu(){const t=Be(this),e=t.size!==0,i=t.clear();return e&&rr(t,"clear",void 0,void 0),i}function un(t,e){return function(r,s){const a=this,o=a.__v_raw,l=Be(o),h=e?Ah:t?xh:Ka;return!t&&Gt(l,"iterate",ss),o.forEach((u,c)=>r.call(s,h(u),h(c),a))}}function cn(t,e,i){return function(...r){const s=this.__v_raw,a=Be(s),o=Da(a),l=t==="entries"||t===Symbol.iterator&&o,h=t==="keys"&&o,u=s[t](...r),c=i?Ah:e?xh:Ka;return!e&&Gt(a,"iterate",h?cl:ss),{next(){const{value:d,done:f}=u.next();return f?{value:d,done:f}:{value:l?[c(d[0]),c(d[1])]:c(d),done:f}},[Symbol.iterator](){return this}}}}function ur(t){return function(...e){return t==="delete"?!1:t==="clear"?void 0:this}}function $g(){const t={get(a){return on(this,a)},get size(){return hn(this)},has:ln,add:cu,set:du,delete:fu,clear:gu,forEach:un(!1,!1)},e={get(a){return on(this,a,!1,!0)},get size(){return hn(this)},has:ln,add:cu,set:du,delete:fu,clear:gu,forEach:un(!1,!0)},i={get(a){return on(this,a,!0)},get size(){return hn(this,!0)},has(a){return ln.call(this,a,!0)},add:ur("add"),set:ur("set"),delete:ur("delete"),clear:ur("clear"),forEach:un(!0,!1)},r={get(a){return on(this,a,!0,!0)},get size(){return hn(this,!0)},has(a){return ln.call(this,a,!0)},add:ur("add"),set:ur("set"),delete:ur("delete"),clear:ur("clear"),forEach:un(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(a=>{t[a]=cn(a,!1,!1),i[a]=cn(a,!0,!1),e[a]=cn(a,!1,!0),r[a]=cn(a,!0,!0)}),[t,i,e,r]}const[ep,tp,ip,rp]=$g();function _h(t,e){const i=e?t?rp:ip:t?tp:ep;return(r,s,a)=>s==="__v_isReactive"?!t:s==="__v_isReadonly"?t:s==="__v_raw"?r:Reflect.get(Re(i,s)&&s in r?i:r,s,a)}const sp={get:_h(!1,!1)},ap={get:_h(!1,!0)},np={get:_h(!0,!1)},dd=new WeakMap,fd=new WeakMap,gd=new WeakMap,op=new WeakMap;function lp(t){switch(t){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function hp(t){return t.__v_skip||!Object.isExtensible(t)?0:lp(Dg(t))}function sa(t){return Hs(t)?t:vh(t,!1,qg,sp,dd)}function pd(t){return vh(t,!1,Zg,ap,fd)}function md(t){return vh(t,!0,Jg,np,gd)}function vh(t,e,i,r,s){if(!$e(t)||t.__v_raw&&!(e&&t.__v_isReactive))return t;const a=s.get(t);if(a)return a;const o=hp(t);if(o===0)return t;const l=new Proxy(t,o===2?r:i);return s.set(t,l),l}function sr(t){return Hs(t)?sr(t.__v_raw):!!(t&&t.__v_isReactive)}function Hs(t){return!!(t&&t.__v_isReadonly)}function Kn(t){return!!(t&&t.__v_isShallow)}function Ad(t){return sr(t)||Hs(t)}function Be(t){const e=t&&t.__v_raw;return e?Be(e):t}function xo(t){return Yn(t,"__v_skip",!0),t}const Ka=t=>$e(t)?sa(t):t,xh=t=>$e(t)?md(t):t;function _d(t){Cr&&pi&&(t=Be(t),ld(t.dep||(t.dep=ph())))}function vd(t,e){t=Be(t);const i=t.dep;i&&dl(i)}function je(t){return!!(t&&t.__v_isRef===!0)}function Br(t){return xd(t,!1)}function up(t){return xd(t,!0)}function xd(t,e){return je(t)?t:new cp(t,e)}class cp{constructor(e,i){this.__v_isShallow=i,this.dep=void 0,this.__v_isRef=!0,this._rawValue=i?e:Be(e),this._value=i?e:Ka(e)}get value(){return _d(this),this._value}set value(e){const i=this.__v_isShallow||Kn(e)||Hs(e);e=i?e:Be(e),cs(e,this._rawValue)&&(this._rawValue=e,this._value=i?e:Ka(e),vd(this))}}function as(t){return je(t)?t.value:t}const dp={get:(t,e,i)=>as(Reflect.get(t,e,i)),set:(t,e,i,r)=>{const s=t[e];return je(s)&&!je(i)?(s.value=i,!0):Reflect.set(t,e,i,r)}};function yd(t){return sr(t)?t:new Proxy(t,dp)}function fp(t){const e=pe(t)?new Array(t.length):{};for(const i in t)e[i]=Cd(t,i);return e}class gp{constructor(e,i,r){this._object=e,this._key=i,this._defaultValue=r,this.__v_isRef=!0}get value(){const e=this._object[this._key];return e===void 0?this._defaultValue:e}set value(e){this._object[this._key]=e}get dep(){return Yg(Be(this._object),this._key)}}class pp{constructor(e){this._getter=e,this.__v_isRef=!0,this.__v_isReadonly=!0}get value(){return this._getter()}}function mp(t,e,i){return je(t)?t:Ae(t)?new pp(t):$e(t)&&arguments.length>1?Cd(t,e,i):Br(t)}function Cd(t,e,i){const r=t[e];return je(r)?r:new gp(t,e,i)}class Ap{constructor(e,i,r,s){this._setter=i,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new mh(e,()=>{this._dirty||(this._dirty=!0,vd(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!s,this.__v_isReadonly=r}get value(){const e=Be(this);return _d(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}function _p(t,e,i=!1){let r,s;const a=Ae(t);return a?(r=t,s=_i):(r=t.get,s=t.set),new Ap(r,s,a||!s,i)}function br(t,e,i,r){let s;try{s=r?t(...r):t()}catch(a){yo(a,e,i)}return s}function vi(t,e,i,r){if(Ae(t)){const a=br(t,e,i,r);return a&&ed(a)&&a.catch(o=>{yo(o,e,i)}),a}const s=[];for(let a=0;a<t.length;a++)s.push(vi(t[a],e,i,r));return s}function yo(t,e,i,r=!0){const s=e?e.vnode:null;if(e){let a=e.parent;const o=e.proxy,l=i;for(;a;){const u=a.ec;if(u){for(let c=0;c<u.length;c++)if(u[c](t,o,l)===!1)return}a=a.parent}const h=e.appContext.config.errorHandler;if(h){br(h,null,10,[t,o,l]);return}}vp(t,i,s,r)}function vp(t,e,i,r=!0){console.error(t)}let Wa=!1,fl=!1;const St=[];let Li=0;const Ns=[];let Ji=null,$r=0;const bd=Promise.resolve();let yh=null;function Ch(t){const e=yh||bd;return t?e.then(this?t.bind(this):t):e}function xp(t){let e=Li+1,i=St.length;for(;e<i;){const r=e+i>>>1,s=St[r],a=ja(s);a<t||a===t&&s.pre?e=r+1:i=r}return e}function bh(t){(!St.length||!St.includes(t,Wa&&t.allowRecurse?Li+1:Li))&&(t.id==null?St.push(t):St.splice(xp(t.id),0,t),Id())}function Id(){!Wa&&!fl&&(fl=!0,yh=bd.then(Sd))}function yp(t){const e=St.indexOf(t);e>Li&&St.splice(e,1)}function Cp(t){pe(t)?Ns.push(...t):(!Ji||!Ji.includes(t,t.allowRecurse?$r+1:$r))&&Ns.push(t),Id()}function pu(t,e=Wa?Li+1:0){for(;e<St.length;e++){const i=St[e];i&&i.pre&&(St.splice(e,1),e--,i())}}function wd(t){if(Ns.length){const e=[...new Set(Ns)];if(Ns.length=0,Ji){Ji.push(...e);return}for(Ji=e,Ji.sort((i,r)=>ja(i)-ja(r)),$r=0;$r<Ji.length;$r++)Ji[$r]();Ji=null,$r=0}}const ja=t=>t.id==null?1/0:t.id,bp=(t,e)=>{const i=ja(t)-ja(e);if(i===0){if(t.pre&&!e.pre)return-1;if(e.pre&&!t.pre)return 1}return i};function Sd(t){fl=!1,Wa=!0,St.sort(bp);const e=_i;try{for(Li=0;Li<St.length;Li++){const i=St[Li];i&&i.active!==!1&&br(i,null,14)}}finally{Li=0,St.length=0,wd(),Wa=!1,yh=null,(St.length||Ns.length)&&Sd()}}function Ip(t,e,...i){if(t.isUnmounted)return;const r=t.vnode.props||Xe;let s=i;const a=e.startsWith("update:"),o=a&&e.slice(7);if(o&&o in r){const c=`${o==="modelValue"?"model":o}Modifiers`,{number:d,trim:f}=r[c]||Xe;f&&(s=i.map(g=>Ct(g)?g.trim():g)),d&&(s=i.map(Ug))}let l,h=r[l=Oo(e)]||r[l=Oo(Qi(e))];!h&&a&&(h=r[l=Oo(ta(e))]),h&&vi(h,t,6,s);const u=r[l+"Once"];if(u){if(!t.emitted)t.emitted={};else if(t.emitted[l])return;t.emitted[l]=!0,vi(u,t,6,s)}}function Ed(t,e,i=!1){const r=e.emitsCache,s=r.get(t);if(s!==void 0)return s;const a=t.emits;let o={},l=!1;if(!Ae(t)){const h=u=>{const c=Ed(u,e,!0);c&&(l=!0,yt(o,c))};!i&&e.mixins.length&&e.mixins.forEach(h),t.extends&&h(t.extends),t.mixins&&t.mixins.forEach(h)}return!a&&!l?($e(t)&&r.set(t,null),null):(pe(a)?a.forEach(h=>o[h]=null):yt(o,a),$e(t)&&r.set(t,o),o)}function Co(t,e){return!t||!go(e)?!1:(e=e.slice(2).replace(/Once$/,""),Re(t,e[0].toLowerCase()+e.slice(1))||Re(t,ta(e))||Re(t,e))}let qt=null,Td=null;function Wn(t){const e=qt;return qt=t,Td=t&&t.type.__scopeId||null,e}function Bd(t,e=qt,i){if(!e||t._n)return t;const r=(...s)=>{r._d&&Su(-1);const a=Wn(e);let o;try{o=t(...s)}finally{Wn(a),r._d&&Su(1)}return o};return r._n=!0,r._c=!0,r._d=!0,r}function Fo(t){const{type:e,vnode:i,proxy:r,withProxy:s,props:a,propsOptions:[o],slots:l,attrs:h,emit:u,render:c,renderCache:d,data:f,setupState:g,ctx:m,inheritAttrs:A}=t;let _,x;const b=Wn(t);try{if(i.shapeFlag&4){const E=s||r,M=E;_=Pi(c.call(M,E,d,a,g,f,m)),x=h}else{const E=e;_=Pi(E.length>1?E(a,{attrs:h,slots:l,emit:u}):E(a,null)),x=e.props?h:wp(h)}}catch(E){Pa.length=0,yo(E,t,1),_=ue(Ja)}let R=_;if(x&&A!==!1){const E=Object.keys(x),{shapeFlag:M}=R;E.length&&M&7&&(o&&E.some(uh)&&(x=Sp(x,o)),R=Ys(R,x))}return i.dirs&&(R=Ys(R),R.dirs=R.dirs?R.dirs.concat(i.dirs):i.dirs),i.transition&&(R.transition=i.transition),_=R,Wn(b),_}const wp=t=>{let e;for(const i in t)(i==="class"||i==="style"||go(i))&&((e||(e={}))[i]=t[i]);return e},Sp=(t,e)=>{const i={};for(const r in t)(!uh(r)||!(r.slice(9)in e))&&(i[r]=t[r]);return i};function Ep(t,e,i){const{props:r,children:s,component:a}=t,{props:o,children:l,patchFlag:h}=e,u=a.emitsOptions;if(e.dirs||e.transition)return!0;if(i&&h>=0){if(h&1024)return!0;if(h&16)return r?mu(r,o,u):!!o;if(h&8){const c=e.dynamicProps;for(let d=0;d<c.length;d++){const f=c[d];if(o[f]!==r[f]&&!Co(u,f))return!0}}}else return(s||l)&&(!l||!l.$stable)?!0:r===o?!1:r?o?mu(r,o,u):!0:!!o;return!1}function mu(t,e,i){const r=Object.keys(e);if(r.length!==Object.keys(t).length)return!0;for(let s=0;s<r.length;s++){const a=r[s];if(e[a]!==t[a]&&!Co(i,a))return!0}return!1}function Tp({vnode:t,parent:e},i){for(;e&&e.subTree===t;)(t=e.vnode).el=i,e=e.parent}const Dd="components";function Bp(t,e){return Rp(Dd,t,!0,e)||t}const Dp=Symbol.for("v-ndc");function Rp(t,e,i=!0,r=!1){const s=qt||ut;if(s){const a=s.type;if(t===Dd){const l=bm(a,!1);if(l&&(l===e||l===Qi(e)||l===_o(Qi(e))))return a}const o=Au(s[t]||a[t],e)||Au(s.appContext[t],e);return!o&&r?a:o}}function Au(t,e){return t&&(t[e]||t[Qi(e)]||t[_o(Qi(e))])}const Mp=t=>t.__isSuspense;function Pp(t,e){e&&e.pendingBranch?pe(t)?e.effects.push(...t):e.effects.push(t):Cp(t)}function Up(t,e){return Ih(t,null,e)}const dn={};function Ir(t,e,i){return Ih(t,e,i)}function Ih(t,e,{immediate:i,deep:r,flush:s,onTrack:a,onTrigger:o}=Xe){var l;const h=sd()===((l=ut)==null?void 0:l.scope)?ut:null;let u,c=!1,d=!1;if(je(t)?(u=()=>t.value,c=Kn(t)):sr(t)?(u=()=>t,r=!0):pe(t)?(d=!0,c=t.some(E=>sr(E)||Kn(E)),u=()=>t.map(E=>{if(je(E))return E.value;if(sr(E))return Ms(E);if(Ae(E))return br(E,h,2)})):Ae(t)?e?u=()=>br(t,h,2):u=()=>{if(!(h&&h.isUnmounted))return f&&f(),vi(t,h,3,[g])}:u=_i,e&&r){const E=u;u=()=>Ms(E())}let f,g=E=>{f=b.onStop=()=>{br(E,h,4),f=b.onStop=void 0}},m;if($a)if(g=_i,e?i&&vi(e,h,3,[u(),d?[]:void 0,g]):u(),s==="sync"){const E=Sm();m=E.__watcherHandles||(E.__watcherHandles=[])}else return _i;let A=d?new Array(t.length).fill(dn):dn;const _=()=>{if(b.active)if(e){const E=b.run();(r||c||(d?E.some((M,G)=>cs(M,A[G])):cs(E,A)))&&(f&&f(),vi(e,h,3,[E,A===dn?void 0:d&&A[0]===dn?[]:A,g]),A=E)}else b.run()};_.allowRecurse=!!e;let x;s==="sync"?x=_:s==="post"?x=()=>Ot(_,h&&h.suspense):(_.pre=!0,h&&(_.id=h.uid),x=()=>bh(_));const b=new mh(u,x);e?i?_():A=b.run():s==="post"?Ot(b.run.bind(b),h&&h.suspense):b.run();const R=()=>{b.stop(),h&&h.scope&&ch(h.scope.effects,b)};return m&&m.push(R),R}function Lp(t,e,i){const r=this.proxy,s=Ct(t)?t.includes(".")?Rd(r,t):()=>r[t]:t.bind(r,r);let a;Ae(e)?a=e:(a=e.handler,i=e);const o=ut;Xs(this);const l=Ih(s,a.bind(r),i);return o?Xs(o):ns(),l}function Rd(t,e){const i=e.split(".");return()=>{let r=t;for(let s=0;s<i.length&&r;s++)r=r[i[s]];return r}}function Ms(t,e){if(!$e(t)||t.__v_skip||(e=e||new Set,e.has(t)))return t;if(e.add(t),je(t))Ms(t.value,e);else if(pe(t))for(let i=0;i<t.length;i++)Ms(t[i],e);else if(Tg(t)||Da(t))t.forEach(i=>{Ms(i,e)});else if(Rg(t))for(const i in t)Ms(t[i],e);return t}function zr(t,e,i,r){const s=t.dirs,a=e&&e.dirs;for(let o=0;o<s.length;o++){const l=s[o];a&&(l.oldValue=a[o].value);let h=l.dir[r];h&&(ia(),vi(h,i,8,[t.el,l,t,e]),ra())}}/*! #__NO_SIDE_EFFECTS__ */function Vi(t,e){return Ae(t)?(()=>yt({name:t.name},e,{setup:t}))():t}const Rn=t=>!!t.type.__asyncLoader,Md=t=>t.type.__isKeepAlive;function Pd(t,e){Ld(t,"a",e)}function Ud(t,e){Ld(t,"da",e)}function Ld(t,e,i=ut){const r=t.__wdc||(t.__wdc=()=>{let s=i;for(;s;){if(s.isDeactivated)return;s=s.parent}return t()});if(bo(e,r,i),i){let s=i.parent;for(;s&&s.parent;)Md(s.parent.vnode)&&Op(r,e,i,s),s=s.parent}}function Op(t,e,i,r){const s=bo(e,t,r,!0);Fd(()=>{ch(r[e],s)},i)}function bo(t,e,i=ut,r=!1){if(i){const s=i[t]||(i[t]=[]),a=e.__weh||(e.__weh=(...o)=>{if(i.isUnmounted)return;ia(),Xs(i);const l=vi(e,i,t,o);return ns(),ra(),l});return r?s.unshift(a):s.push(a),a}}const hr=t=>(e,i=ut)=>(!$a||t==="sp")&&bo(t,(...r)=>e(...r),i),Np=hr("bm"),Od=hr("m"),Fp=hr("bu"),kp=hr("u"),Nd=hr("bum"),Fd=hr("um"),Qp=hr("sp"),zp=hr("rtg"),Gp=hr("rtc");function Vp(t,e=ut){bo("ec",t,e)}const gl=t=>t?jd(t)?Dh(t)||t.proxy:gl(t.parent):null,Ra=yt(Object.create(null),{$:t=>t,$el:t=>t.vnode.el,$data:t=>t.data,$props:t=>t.props,$attrs:t=>t.attrs,$slots:t=>t.slots,$refs:t=>t.refs,$parent:t=>gl(t.parent),$root:t=>gl(t.root),$emit:t=>t.emit,$options:t=>wh(t),$forceUpdate:t=>t.f||(t.f=()=>bh(t.update)),$nextTick:t=>t.n||(t.n=Ch.bind(t.proxy)),$watch:t=>Lp.bind(t)}),ko=(t,e)=>t!==Xe&&!t.__isScriptSetup&&Re(t,e),Hp={get({_:t},e){const{ctx:i,setupState:r,data:s,props:a,accessCache:o,type:l,appContext:h}=t;let u;if(e[0]!=="$"){const g=o[e];if(g!==void 0)switch(g){case 1:return r[e];case 2:return s[e];case 4:return i[e];case 3:return a[e]}else{if(ko(r,e))return o[e]=1,r[e];if(s!==Xe&&Re(s,e))return o[e]=2,s[e];if((u=t.propsOptions[0])&&Re(u,e))return o[e]=3,a[e];if(i!==Xe&&Re(i,e))return o[e]=4,i[e];pl&&(o[e]=0)}}const c=Ra[e];let d,f;if(c)return e==="$attrs"&&Gt(t,"get",e),c(t);if((d=l.__cssModules)&&(d=d[e]))return d;if(i!==Xe&&Re(i,e))return o[e]=4,i[e];if(f=h.config.globalProperties,Re(f,e))return f[e]},set({_:t},e,i){const{data:r,setupState:s,ctx:a}=t;return ko(s,e)?(s[e]=i,!0):r!==Xe&&Re(r,e)?(r[e]=i,!0):Re(t.props,e)||e[0]==="$"&&e.slice(1)in t?!1:(a[e]=i,!0)},has({_:{data:t,setupState:e,accessCache:i,ctx:r,appContext:s,propsOptions:a}},o){let l;return!!i[o]||t!==Xe&&Re(t,o)||ko(e,o)||(l=a[0])&&Re(l,o)||Re(r,o)||Re(Ra,o)||Re(s.config.globalProperties,o)},defineProperty(t,e,i){return i.get!=null?t._.accessCache[e]=0:Re(i,"value")&&this.set(t,e,i.value,null),Reflect.defineProperty(t,e,i)}};function _u(t){return pe(t)?t.reduce((e,i)=>(e[i]=null,e),{}):t}let pl=!0;function Yp(t){const e=wh(t),i=t.proxy,r=t.ctx;pl=!1,e.beforeCreate&&vu(e.beforeCreate,t,"bc");const{data:s,computed:a,methods:o,watch:l,provide:h,inject:u,created:c,beforeMount:d,mounted:f,beforeUpdate:g,updated:m,activated:A,deactivated:_,beforeDestroy:x,beforeUnmount:b,destroyed:R,unmounted:E,render:M,renderTracked:G,renderTriggered:V,errorCaptured:k,serverPrefetch:O,expose:ce,inheritAttrs:we,components:Ce,directives:be,filters:De}=e;if(u&&Xp(u,r,null),o)for(const _e in o){const de=o[_e];Ae(de)&&(r[_e]=de.bind(i))}if(s){const _e=s.call(i,i);$e(_e)&&(t.data=sa(_e))}if(pl=!0,a)for(const _e in a){const de=a[_e],et=Ae(de)?de.bind(i,i):Ae(de.get)?de.get.bind(i,i):_i,Qe=!Ae(de)&&Ae(de.set)?de.set.bind(i):_i,tt=Et({get:et,set:Qe});Object.defineProperty(r,_e,{enumerable:!0,configurable:!0,get:()=>tt.value,set:at=>tt.value=at})}if(l)for(const _e in l)kd(l[_e],r,i,_e);if(h){const _e=Ae(h)?h.call(i):h;Reflect.ownKeys(_e).forEach(de=>{Ma(de,_e[de])})}c&&vu(c,t,"c");function he(_e,de){pe(de)?de.forEach(et=>_e(et.bind(i))):de&&_e(de.bind(i))}if(he(Np,d),he(Od,f),he(Fp,g),he(kp,m),he(Pd,A),he(Ud,_),he(Vp,k),he(Gp,G),he(zp,V),he(Nd,b),he(Fd,E),he(Qp,O),pe(ce))if(ce.length){const _e=t.exposed||(t.exposed={});ce.forEach(de=>{Object.defineProperty(_e,de,{get:()=>i[de],set:et=>i[de]=et})})}else t.exposed||(t.exposed={});M&&t.render===_i&&(t.render=M),we!=null&&(t.inheritAttrs=we),Ce&&(t.components=Ce),be&&(t.directives=be)}function Xp(t,e,i=_i){pe(t)&&(t=ml(t));for(const r in t){const s=t[r];let a;$e(s)?"default"in s?a=xi(s.from||r,s.default,!0):a=xi(s.from||r):a=xi(s),je(a)?Object.defineProperty(e,r,{enumerable:!0,configurable:!0,get:()=>a.value,set:o=>a.value=o}):e[r]=a}}function vu(t,e,i){vi(pe(t)?t.map(r=>r.bind(e.proxy)):t.bind(e.proxy),e,i)}function kd(t,e,i,r){const s=r.includes(".")?Rd(i,r):()=>i[r];if(Ct(t)){const a=e[t];Ae(a)&&Ir(s,a)}else if(Ae(t))Ir(s,t.bind(i));else if($e(t))if(pe(t))t.forEach(a=>kd(a,e,i,r));else{const a=Ae(t.handler)?t.handler.bind(i):e[t.handler];Ae(a)&&Ir(s,a,t)}}function wh(t){const e=t.type,{mixins:i,extends:r}=e,{mixins:s,optionsCache:a,config:{optionMergeStrategies:o}}=t.appContext,l=a.get(e);let h;return l?h=l:!s.length&&!i&&!r?h=e:(h={},s.length&&s.forEach(u=>jn(h,u,o,!0)),jn(h,e,o)),$e(e)&&a.set(e,h),h}function jn(t,e,i,r=!1){const{mixins:s,extends:a}=e;a&&jn(t,a,i,!0),s&&s.forEach(o=>jn(t,o,i,!0));for(const o in e)if(!(r&&o==="expose")){const l=Kp[o]||i&&i[o];t[o]=l?l(t[o],e[o]):e[o]}return t}const Kp={data:xu,props:yu,emits:yu,methods:ma,computed:ma,beforeCreate:Bt,created:Bt,beforeMount:Bt,mounted:Bt,beforeUpdate:Bt,updated:Bt,beforeDestroy:Bt,beforeUnmount:Bt,destroyed:Bt,unmounted:Bt,activated:Bt,deactivated:Bt,errorCaptured:Bt,serverPrefetch:Bt,components:ma,directives:ma,watch:jp,provide:xu,inject:Wp};function xu(t,e){return e?t?function(){return yt(Ae(t)?t.call(this,this):t,Ae(e)?e.call(this,this):e)}:e:t}function Wp(t,e){return ma(ml(t),ml(e))}function ml(t){if(pe(t)){const e={};for(let i=0;i<t.length;i++)e[t[i]]=t[i];return e}return t}function Bt(t,e){return t?[...new Set([].concat(t,e))]:e}function ma(t,e){return t?yt(Object.create(null),t,e):e}function yu(t,e){return t?pe(t)&&pe(e)?[...new Set([...t,...e])]:yt(Object.create(null),_u(t),_u(e??{})):e}function jp(t,e){if(!t)return e;if(!e)return t;const i=yt(Object.create(null),t);for(const r in e)i[r]=Bt(t[r],e[r]);return i}function Qd(){return{app:null,config:{isNativeTag:wg,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let qp=0;function Jp(t,e){return function(r,s=null){Ae(r)||(r=yt({},r)),s!=null&&!$e(s)&&(s=null);const a=Qd(),o=new WeakSet;let l=!1;const h=a.app={_uid:qp++,_component:r,_props:s,_container:null,_context:a,_instance:null,version:Em,get config(){return a.config},set config(u){},use(u,...c){return o.has(u)||(u&&Ae(u.install)?(o.add(u),u.install(h,...c)):Ae(u)&&(o.add(u),u(h,...c))),h},mixin(u){return a.mixins.includes(u)||a.mixins.push(u),h},component(u,c){return c?(a.components[u]=c,h):a.components[u]},directive(u,c){return c?(a.directives[u]=c,h):a.directives[u]},mount(u,c,d){if(!l){const f=ue(r,s);return f.appContext=a,c&&e?e(f,u):t(f,u,d),l=!0,h._container=u,u.__vue_app__=h,Dh(f.component)||f.component.proxy}},unmount(){l&&(t(null,h._container),delete h._container.__vue_app__)},provide(u,c){return a.provides[u]=c,h},runWithContext(u){qa=h;try{return u()}finally{qa=null}}};return h}}let qa=null;function Ma(t,e){if(ut){let i=ut.provides;const r=ut.parent&&ut.parent.provides;r===i&&(i=ut.provides=Object.create(r)),i[t]=e}}function xi(t,e,i=!1){const r=ut||qt;if(r||qa){const s=r?r.parent==null?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides:qa._context.provides;if(s&&t in s)return s[t];if(arguments.length>1)return i&&Ae(e)?e.call(r&&r.proxy):e}}function Zp(){return!!(ut||qt||qa)}function $p(t,e,i,r=!1){const s={},a={};Yn(a,wo,1),t.propsDefaults=Object.create(null),zd(t,e,s,a);for(const o in t.propsOptions[0])o in s||(s[o]=void 0);i?t.props=r?s:pd(s):t.type.props?t.props=s:t.props=a,t.attrs=a}function em(t,e,i,r){const{props:s,attrs:a,vnode:{patchFlag:o}}=t,l=Be(s),[h]=t.propsOptions;let u=!1;if((r||o>0)&&!(o&16)){if(o&8){const c=t.vnode.dynamicProps;for(let d=0;d<c.length;d++){let f=c[d];if(Co(t.emitsOptions,f))continue;const g=e[f];if(h)if(Re(a,f))g!==a[f]&&(a[f]=g,u=!0);else{const m=Qi(f);s[m]=Al(h,l,m,g,t,!1)}else g!==a[f]&&(a[f]=g,u=!0)}}}else{zd(t,e,s,a)&&(u=!0);let c;for(const d in l)(!e||!Re(e,d)&&((c=ta(d))===d||!Re(e,c)))&&(h?i&&(i[d]!==void 0||i[c]!==void 0)&&(s[d]=Al(h,l,d,void 0,t,!0)):delete s[d]);if(a!==l)for(const d in a)(!e||!Re(e,d))&&(delete a[d],u=!0)}u&&rr(t,"set","$attrs")}function zd(t,e,i,r){const[s,a]=t.propsOptions;let o=!1,l;if(e)for(let h in e){if(Dn(h))continue;const u=e[h];let c;s&&Re(s,c=Qi(h))?!a||!a.includes(c)?i[c]=u:(l||(l={}))[c]=u:Co(t.emitsOptions,h)||(!(h in r)||u!==r[h])&&(r[h]=u,o=!0)}if(a){const h=Be(i),u=l||Xe;for(let c=0;c<a.length;c++){const d=a[c];i[d]=Al(s,h,d,u[d],t,!Re(u,d))}}return o}function Al(t,e,i,r,s,a){const o=t[i];if(o!=null){const l=Re(o,"default");if(l&&r===void 0){const h=o.default;if(o.type!==Function&&!o.skipFactory&&Ae(h)){const{propsDefaults:u}=s;i in u?r=u[i]:(Xs(s),r=u[i]=h.call(null,e),ns())}else r=h}o[0]&&(a&&!l?r=!1:o[1]&&(r===""||r===ta(i))&&(r=!0))}return r}function Gd(t,e,i=!1){const r=e.propsCache,s=r.get(t);if(s)return s;const a=t.props,o={},l=[];let h=!1;if(!Ae(t)){const c=d=>{h=!0;const[f,g]=Gd(d,e,!0);yt(o,f),g&&l.push(...g)};!i&&e.mixins.length&&e.mixins.forEach(c),t.extends&&c(t.extends),t.mixins&&t.mixins.forEach(c)}if(!a&&!h)return $e(t)&&r.set(t,Os),Os;if(pe(a))for(let c=0;c<a.length;c++){const d=Qi(a[c]);Cu(d)&&(o[d]=Xe)}else if(a)for(const c in a){const d=Qi(c);if(Cu(d)){const f=a[c],g=o[d]=pe(f)||Ae(f)?{type:f}:yt({},f);if(g){const m=wu(Boolean,g.type),A=wu(String,g.type);g[0]=m>-1,g[1]=A<0||m<A,(m>-1||Re(g,"default"))&&l.push(d)}}}const u=[o,l];return $e(t)&&r.set(t,u),u}function Cu(t){return t[0]!=="$"}function bu(t){const e=t&&t.toString().match(/^\s*(function|class) (\w+)/);return e?e[2]:t===null?"null":""}function Iu(t,e){return bu(t)===bu(e)}function wu(t,e){return pe(e)?e.findIndex(i=>Iu(i,t)):Ae(e)&&Iu(e,t)?0:-1}const Vd=t=>t[0]==="_"||t==="$stable",Sh=t=>pe(t)?t.map(Pi):[Pi(t)],tm=(t,e,i)=>{if(e._n)return e;const r=Bd((...s)=>Sh(e(...s)),i);return r._c=!1,r},Hd=(t,e,i)=>{const r=t._ctx;for(const s in t){if(Vd(s))continue;const a=t[s];if(Ae(a))e[s]=tm(s,a,r);else if(a!=null){const o=Sh(a);e[s]=()=>o}}},Yd=(t,e)=>{const i=Sh(e);t.slots.default=()=>i},im=(t,e)=>{if(t.vnode.shapeFlag&32){const i=e._;i?(t.slots=Be(e),Yn(e,"_",i)):Hd(e,t.slots={})}else t.slots={},e&&Yd(t,e);Yn(t.slots,wo,1)},rm=(t,e,i)=>{const{vnode:r,slots:s}=t;let a=!0,o=Xe;if(r.shapeFlag&32){const l=e._;l?i&&l===1?a=!1:(yt(s,e),!i&&l===1&&delete s._):(a=!e.$stable,Hd(e,s)),o=e}else e&&(Yd(t,e),o={default:1});if(a)for(const l in s)!Vd(l)&&o[l]==null&&delete s[l]};function _l(t,e,i,r,s=!1){if(pe(t)){t.forEach((f,g)=>_l(f,e&&(pe(e)?e[g]:e),i,r,s));return}if(Rn(r)&&!s)return;const a=r.shapeFlag&4?Dh(r.component)||r.component.proxy:r.el,o=s?null:a,{i:l,r:h}=t,u=e&&e.r,c=l.refs===Xe?l.refs={}:l.refs,d=l.setupState;if(u!=null&&u!==h&&(Ct(u)?(c[u]=null,Re(d,u)&&(d[u]=null)):je(u)&&(u.value=null)),Ae(h))br(h,l,12,[o,c]);else{const f=Ct(h),g=je(h);if(f||g){const m=()=>{if(t.f){const A=f?Re(d,h)?d[h]:c[h]:h.value;s?pe(A)&&ch(A,a):pe(A)?A.includes(a)||A.push(a):f?(c[h]=[a],Re(d,h)&&(d[h]=c[h])):(h.value=[a],t.k&&(c[t.k]=h.value))}else f?(c[h]=o,Re(d,h)&&(d[h]=o)):g&&(h.value=o,t.k&&(c[t.k]=o))};o?(m.id=-1,Ot(m,i)):m()}}}const Ot=Pp;function sm(t){return am(t)}function am(t,e){const i=hl();i.__VUE__=!0;const{insert:r,remove:s,patchProp:a,createElement:o,createText:l,createComment:h,setText:u,setElementText:c,parentNode:d,nextSibling:f,setScopeId:g=_i,insertStaticContent:m}=t,A=(y,C,S,P=null,N=null,F=null,$=!1,X=null,q=!!C.dynamicChildren)=>{if(y===C)return;y&&!oa(y,C)&&(P=U(y),at(y,N,F,!0),y=null),C.patchFlag===-2&&(q=!1,C.dynamicChildren=null);const{type:Q,ref:ae,shapeFlag:re}=C;switch(Q){case Io:_(y,C,S,P);break;case Ja:x(y,C,S,P);break;case Qo:y==null&&b(C,S,P,$);break;case Mi:Ce(y,C,S,P,N,F,$,X,q);break;default:re&1?M(y,C,S,P,N,F,$,X,q):re&6?be(y,C,S,P,N,F,$,X,q):(re&64||re&128)&&Q.process(y,C,S,P,N,F,$,X,q,J)}ae!=null&&N&&_l(ae,y&&y.ref,F,C||y,!C)},_=(y,C,S,P)=>{if(y==null)r(C.el=l(C.children),S,P);else{const N=C.el=y.el;C.children!==y.children&&u(N,C.children)}},x=(y,C,S,P)=>{y==null?r(C.el=h(C.children||""),S,P):C.el=y.el},b=(y,C,S,P)=>{[y.el,y.anchor]=m(y.children,C,S,P,y.el,y.anchor)},R=({el:y,anchor:C},S,P)=>{let N;for(;y&&y!==C;)N=f(y),r(y,S,P),y=N;r(C,S,P)},E=({el:y,anchor:C})=>{let S;for(;y&&y!==C;)S=f(y),s(y),y=S;s(C)},M=(y,C,S,P,N,F,$,X,q)=>{$=$||C.type==="svg",y==null?G(C,S,P,N,F,$,X,q):O(y,C,N,F,$,X,q)},G=(y,C,S,P,N,F,$,X)=>{let q,Q;const{type:ae,props:re,shapeFlag:ne,transition:fe,dirs:Ie}=y;if(q=y.el=o(y.type,F,re&&re.is,re),ne&8?c(q,y.children):ne&16&&k(y.children,q,null,P,N,F&&ae!=="foreignObject",$,X),Ie&&zr(y,null,P,"created"),V(q,y,y.scopeId,$,P),re){for(const ze in re)ze!=="value"&&!Dn(ze)&&a(q,ze,null,re[ze],F,y.children,P,N,ot);"value"in re&&a(q,"value",null,re.value),(Q=re.onVnodeBeforeMount)&&Ei(Q,P,y)}Ie&&zr(y,null,P,"beforeMount");const Ge=nm(N,fe);Ge&&fe.beforeEnter(q),r(q,C,S),((Q=re&&re.onVnodeMounted)||Ge||Ie)&&Ot(()=>{Q&&Ei(Q,P,y),Ge&&fe.enter(q),Ie&&zr(y,null,P,"mounted")},N)},V=(y,C,S,P,N)=>{if(S&&g(y,S),P)for(let F=0;F<P.length;F++)g(y,P[F]);if(N){let F=N.subTree;if(C===F){const $=N.vnode;V(y,$,$.scopeId,$.slotScopeIds,N.parent)}}},k=(y,C,S,P,N,F,$,X,q=0)=>{for(let Q=q;Q<y.length;Q++){const ae=y[Q]=X?_r(y[Q]):Pi(y[Q]);A(null,ae,C,S,P,N,F,$,X)}},O=(y,C,S,P,N,F,$)=>{const X=C.el=y.el;let{patchFlag:q,dynamicChildren:Q,dirs:ae}=C;q|=y.patchFlag&16;const re=y.props||Xe,ne=C.props||Xe;let fe;S&&Gr(S,!1),(fe=ne.onVnodeBeforeUpdate)&&Ei(fe,S,C,y),ae&&zr(C,y,S,"beforeUpdate"),S&&Gr(S,!0);const Ie=N&&C.type!=="foreignObject";if(Q?ce(y.dynamicChildren,Q,X,S,P,Ie,F):$||de(y,C,X,null,S,P,Ie,F,!1),q>0){if(q&16)we(X,C,re,ne,S,P,N);else if(q&2&&re.class!==ne.class&&a(X,"class",null,ne.class,N),q&4&&a(X,"style",re.style,ne.style,N),q&8){const Ge=C.dynamicProps;for(let ze=0;ze<Ge.length;ze++){const nt=Ge[ze],fi=re[nt],_s=ne[nt];(_s!==fi||nt==="value")&&a(X,nt,fi,_s,N,y.children,S,P,ot)}}q&1&&y.children!==C.children&&c(X,C.children)}else!$&&Q==null&&we(X,C,re,ne,S,P,N);((fe=ne.onVnodeUpdated)||ae)&&Ot(()=>{fe&&Ei(fe,S,C,y),ae&&zr(C,y,S,"updated")},P)},ce=(y,C,S,P,N,F,$)=>{for(let X=0;X<C.length;X++){const q=y[X],Q=C[X],ae=q.el&&(q.type===Mi||!oa(q,Q)||q.shapeFlag&70)?d(q.el):S;A(q,Q,ae,null,P,N,F,$,!0)}},we=(y,C,S,P,N,F,$)=>{if(S!==P){if(S!==Xe)for(const X in S)!Dn(X)&&!(X in P)&&a(y,X,S[X],null,$,C.children,N,F,ot);for(const X in P){if(Dn(X))continue;const q=P[X],Q=S[X];q!==Q&&X!=="value"&&a(y,X,Q,q,$,C.children,N,F,ot)}"value"in P&&a(y,"value",S.value,P.value)}},Ce=(y,C,S,P,N,F,$,X,q)=>{const Q=C.el=y?y.el:l(""),ae=C.anchor=y?y.anchor:l("");let{patchFlag:re,dynamicChildren:ne,slotScopeIds:fe}=C;fe&&(X=X?X.concat(fe):fe),y==null?(r(Q,S,P),r(ae,S,P),k(C.children,S,ae,N,F,$,X,q)):re>0&&re&64&&ne&&y.dynamicChildren?(ce(y.dynamicChildren,ne,S,N,F,$,X),(C.key!=null||N&&C===N.subTree)&&Xd(y,C,!0)):de(y,C,S,ae,N,F,$,X,q)},be=(y,C,S,P,N,F,$,X,q)=>{C.slotScopeIds=X,y==null?C.shapeFlag&512?N.ctx.activate(C,S,P,$,q):De(C,S,P,N,F,$,q):Ee(y,C,q)},De=(y,C,S,P,N,F,$)=>{const X=y.component=_m(y,P,N);if(Md(y)&&(X.ctx.renderer=J),vm(X),X.asyncDep){if(N&&N.registerDep(X,he),!y.el){const q=X.subTree=ue(Ja);x(null,q,C,S)}return}he(X,y,C,S,N,F,$)},Ee=(y,C,S)=>{const P=C.component=y.component;if(Ep(y,C,S))if(P.asyncDep&&!P.asyncResolved){_e(P,C,S);return}else P.next=C,yp(P.update),P.update();else C.el=y.el,P.vnode=C},he=(y,C,S,P,N,F,$)=>{const X=()=>{if(y.isMounted){let{next:ae,bu:re,u:ne,parent:fe,vnode:Ie}=y,Ge=ae,ze;Gr(y,!1),ae?(ae.el=Ie.el,_e(y,ae,$)):ae=Ie,re&&No(re),(ze=ae.props&&ae.props.onVnodeBeforeUpdate)&&Ei(ze,fe,ae,Ie),Gr(y,!0);const nt=Fo(y),fi=y.subTree;y.subTree=nt,A(fi,nt,d(fi.el),U(fi),y,N,F),ae.el=nt.el,Ge===null&&Tp(y,nt.el),ne&&Ot(ne,N),(ze=ae.props&&ae.props.onVnodeUpdated)&&Ot(()=>Ei(ze,fe,ae,Ie),N)}else{let ae;const{el:re,props:ne}=C,{bm:fe,m:Ie,parent:Ge}=y,ze=Rn(C);if(Gr(y,!1),fe&&No(fe),!ze&&(ae=ne&&ne.onVnodeBeforeMount)&&Ei(ae,Ge,C),Gr(y,!0),re&&Le){const nt=()=>{y.subTree=Fo(y),Le(re,y.subTree,y,N,null)};ze?C.type.__asyncLoader().then(()=>!y.isUnmounted&&nt()):nt()}else{const nt=y.subTree=Fo(y);A(null,nt,S,P,y,N,F),C.el=nt.el}if(Ie&&Ot(Ie,N),!ze&&(ae=ne&&ne.onVnodeMounted)){const nt=C;Ot(()=>Ei(ae,Ge,nt),N)}(C.shapeFlag&256||Ge&&Rn(Ge.vnode)&&Ge.vnode.shapeFlag&256)&&y.a&&Ot(y.a,N),y.isMounted=!0,C=S=P=null}},q=y.effect=new mh(X,()=>bh(Q),y.scope),Q=y.update=()=>q.run();Q.id=y.uid,Gr(y,!0),Q()},_e=(y,C,S)=>{C.component=y;const P=y.vnode.props;y.vnode=C,y.next=null,em(y,C.props,P,S),rm(y,C.children,S),ia(),pu(),ra()},de=(y,C,S,P,N,F,$,X,q=!1)=>{const Q=y&&y.children,ae=y?y.shapeFlag:0,re=C.children,{patchFlag:ne,shapeFlag:fe}=C;if(ne>0){if(ne&128){Qe(Q,re,S,P,N,F,$,X,q);return}else if(ne&256){et(Q,re,S,P,N,F,$,X,q);return}}fe&8?(ae&16&&ot(Q,N,F),re!==Q&&c(S,re)):ae&16?fe&16?Qe(Q,re,S,P,N,F,$,X,q):ot(Q,N,F,!0):(ae&8&&c(S,""),fe&16&&k(re,S,P,N,F,$,X,q))},et=(y,C,S,P,N,F,$,X,q)=>{y=y||Os,C=C||Os;const Q=y.length,ae=C.length,re=Math.min(Q,ae);let ne;for(ne=0;ne<re;ne++){const fe=C[ne]=q?_r(C[ne]):Pi(C[ne]);A(y[ne],fe,S,null,N,F,$,X,q)}Q>ae?ot(y,N,F,!0,!1,re):k(C,S,P,N,F,$,X,q,re)},Qe=(y,C,S,P,N,F,$,X,q)=>{let Q=0;const ae=C.length;let re=y.length-1,ne=ae-1;for(;Q<=re&&Q<=ne;){const fe=y[Q],Ie=C[Q]=q?_r(C[Q]):Pi(C[Q]);if(oa(fe,Ie))A(fe,Ie,S,null,N,F,$,X,q);else break;Q++}for(;Q<=re&&Q<=ne;){const fe=y[re],Ie=C[ne]=q?_r(C[ne]):Pi(C[ne]);if(oa(fe,Ie))A(fe,Ie,S,null,N,F,$,X,q);else break;re--,ne--}if(Q>re){if(Q<=ne){const fe=ne+1,Ie=fe<ae?C[fe].el:P;for(;Q<=ne;)A(null,C[Q]=q?_r(C[Q]):Pi(C[Q]),S,Ie,N,F,$,X,q),Q++}}else if(Q>ne)for(;Q<=re;)at(y[Q],N,F,!0),Q++;else{const fe=Q,Ie=Q,Ge=new Map;for(Q=Ie;Q<=ne;Q++){const Ht=C[Q]=q?_r(C[Q]):Pi(C[Q]);Ht.key!=null&&Ge.set(Ht.key,Q)}let ze,nt=0;const fi=ne-Ie+1;let _s=!1,su=0;const na=new Array(fi);for(Q=0;Q<fi;Q++)na[Q]=0;for(Q=fe;Q<=re;Q++){const Ht=y[Q];if(nt>=fi){at(Ht,N,F,!0);continue}let Si;if(Ht.key!=null)Si=Ge.get(Ht.key);else for(ze=Ie;ze<=ne;ze++)if(na[ze-Ie]===0&&oa(Ht,C[ze])){Si=ze;break}Si===void 0?at(Ht,N,F,!0):(na[Si-Ie]=Q+1,Si>=su?su=Si:_s=!0,A(Ht,C[Si],S,null,N,F,$,X,q),nt++)}const au=_s?om(na):Os;for(ze=au.length-1,Q=fi-1;Q>=0;Q--){const Ht=Ie+Q,Si=C[Ht],nu=Ht+1<ae?C[Ht+1].el:P;na[Q]===0?A(null,Si,S,nu,N,F,$,X,q):_s&&(ze<0||Q!==au[ze]?tt(Si,S,nu,2):ze--)}}},tt=(y,C,S,P,N=null)=>{const{el:F,type:$,transition:X,children:q,shapeFlag:Q}=y;if(Q&6){tt(y.component.subTree,C,S,P);return}if(Q&128){y.suspense.move(C,S,P);return}if(Q&64){$.move(y,C,S,J);return}if($===Mi){r(F,C,S);for(let re=0;re<q.length;re++)tt(q[re],C,S,P);r(y.anchor,C,S);return}if($===Qo){R(y,C,S);return}if(P!==2&&Q&1&&X)if(P===0)X.beforeEnter(F),r(F,C,S),Ot(()=>X.enter(F),N);else{const{leave:re,delayLeave:ne,afterLeave:fe}=X,Ie=()=>r(F,C,S),Ge=()=>{re(F,()=>{Ie(),fe&&fe()})};ne?ne(F,Ie,Ge):Ge()}else r(F,C,S)},at=(y,C,S,P=!1,N=!1)=>{const{type:F,props:$,ref:X,children:q,dynamicChildren:Q,shapeFlag:ae,patchFlag:re,dirs:ne}=y;if(X!=null&&_l(X,null,S,y,!0),ae&256){C.ctx.deactivate(y);return}const fe=ae&1&&ne,Ie=!Rn(y);let Ge;if(Ie&&(Ge=$&&$.onVnodeBeforeUnmount)&&Ei(Ge,C,y),ae&6)Qr(y.component,S,P);else{if(ae&128){y.suspense.unmount(S,P);return}fe&&zr(y,null,C,"beforeUnmount"),ae&64?y.type.remove(y,C,S,N,J,P):Q&&(F!==Mi||re>0&&re&64)?ot(Q,C,S,!1,!0):(F===Mi&&re&384||!N&&ae&16)&&ot(q,C,S),P&&ei(y)}(Ie&&(Ge=$&&$.onVnodeUnmounted)||fe)&&Ot(()=>{Ge&&Ei(Ge,C,y),fe&&zr(y,null,C,"unmounted")},S)},ei=y=>{const{type:C,el:S,anchor:P,transition:N}=y;if(C===Mi){Ki(S,P);return}if(C===Qo){E(y);return}const F=()=>{s(S),N&&!N.persisted&&N.afterLeave&&N.afterLeave()};if(y.shapeFlag&1&&N&&!N.persisted){const{leave:$,delayLeave:X}=N,q=()=>$(S,F);X?X(y.el,F,q):q()}else F()},Ki=(y,C)=>{let S;for(;y!==C;)S=f(y),s(y),y=S;s(C)},Qr=(y,C,S)=>{const{bum:P,scope:N,update:F,subTree:$,um:X}=y;P&&No(P),N.stop(),F&&(F.active=!1,at($,y,C,S)),X&&Ot(X,C),Ot(()=>{y.isUnmounted=!0},C),C&&C.pendingBranch&&!C.isUnmounted&&y.asyncDep&&!y.asyncResolved&&y.suspenseId===C.pendingId&&(C.deps--,C.deps===0&&C.resolve())},ot=(y,C,S,P=!1,N=!1,F=0)=>{for(let $=F;$<y.length;$++)at(y[$],C,S,P,N)},U=y=>y.shapeFlag&6?U(y.component.subTree):y.shapeFlag&128?y.suspense.next():f(y.anchor||y.el),ee=(y,C,S)=>{y==null?C._vnode&&at(C._vnode,null,null,!0):A(C._vnode||null,y,C,null,null,null,S),pu(),wd(),C._vnode=y},J={p:A,um:at,m:tt,r:ei,mt:De,mc:k,pc:de,pbc:ce,n:U,o:t};let se,Le;return e&&([se,Le]=e(J)),{render:ee,hydrate:se,createApp:Jp(ee,se)}}function Gr({effect:t,update:e},i){t.allowRecurse=e.allowRecurse=i}function nm(t,e){return(!t||t&&!t.pendingBranch)&&e&&!e.persisted}function Xd(t,e,i=!1){const r=t.children,s=e.children;if(pe(r)&&pe(s))for(let a=0;a<r.length;a++){const o=r[a];let l=s[a];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=s[a]=_r(s[a]),l.el=o.el),i||Xd(o,l)),l.type===Io&&(l.el=o.el)}}function om(t){const e=t.slice(),i=[0];let r,s,a,o,l;const h=t.length;for(r=0;r<h;r++){const u=t[r];if(u!==0){if(s=i[i.length-1],t[s]<u){e[r]=s,i.push(r);continue}for(a=0,o=i.length-1;a<o;)l=a+o>>1,t[i[l]]<u?a=l+1:o=l;u<t[i[a]]&&(a>0&&(e[r]=i[a-1]),i[a]=r)}}for(a=i.length,o=i[a-1];a-- >0;)i[a]=o,o=e[o];return i}const lm=t=>t.__isTeleport,Mi=Symbol.for("v-fgt"),Io=Symbol.for("v-txt"),Ja=Symbol.for("v-cmt"),Qo=Symbol.for("v-stc"),Pa=[];let Ai=null;function hm(t=!1){Pa.push(Ai=t?null:[])}function um(){Pa.pop(),Ai=Pa[Pa.length-1]||null}let Za=1;function Su(t){Za+=t}function cm(t){return t.dynamicChildren=Za>0?Ai||Os:null,um(),Za>0&&Ai&&Ai.push(t),t}function dm(t,e,i,r,s){return cm(ue(t,e,i,r,s,!0))}function vl(t){return t?t.__v_isVNode===!0:!1}function oa(t,e){return t.type===e.type&&t.key===e.key}const wo="__vInternal",Kd=({key:t})=>t??null,Mn=({ref:t,ref_key:e,ref_for:i})=>(typeof t=="number"&&(t=""+t),t!=null?Ct(t)||je(t)||Ae(t)?{i:qt,r:t,k:e,f:!!i}:t:null);function fm(t,e=null,i=null,r=0,s=null,a=t===Mi?0:1,o=!1,l=!1){const h={__v_isVNode:!0,__v_skip:!0,type:t,props:e,key:e&&Kd(e),ref:e&&Mn(e),scopeId:Td,slotScopeIds:null,children:i,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:a,patchFlag:r,dynamicProps:s,dynamicChildren:null,appContext:null,ctx:qt};return l?(Eh(h,i),a&128&&t.normalize(h)):i&&(h.shapeFlag|=Ct(i)?8:16),Za>0&&!o&&Ai&&(h.patchFlag>0||a&6)&&h.patchFlag!==32&&Ai.push(h),h}const ue=gm;function gm(t,e=null,i=null,r=0,s=null,a=!1){if((!t||t===Dp)&&(t=Ja),vl(t)){const l=Ys(t,e,!0);return i&&Eh(l,i),Za>0&&!a&&Ai&&(l.shapeFlag&6?Ai[Ai.indexOf(t)]=l:Ai.push(l)),l.patchFlag|=-2,l}if(Im(t)&&(t=t.__vccOpts),e){e=pm(e);let{class:l,style:h}=e;l&&!Ct(l)&&(e.class=gh(l)),$e(h)&&(Ad(h)&&!pe(h)&&(h=yt({},h)),e.style=fh(h))}const o=Ct(t)?1:Mp(t)?128:lm(t)?64:$e(t)?4:Ae(t)?2:0;return fm(t,e,i,r,s,o,a,!0)}function pm(t){return t?Ad(t)||wo in t?yt({},t):t:null}function Ys(t,e,i=!1){const{props:r,ref:s,patchFlag:a,children:o}=t,l=e?Th(r||{},e):r;return{__v_isVNode:!0,__v_skip:!0,type:t.type,props:l,key:l&&Kd(l),ref:e&&e.ref?i&&s?pe(s)?s.concat(Mn(e)):[s,Mn(e)]:Mn(e):s,scopeId:t.scopeId,slotScopeIds:t.slotScopeIds,children:o,target:t.target,targetAnchor:t.targetAnchor,staticCount:t.staticCount,shapeFlag:t.shapeFlag,patchFlag:e&&t.type!==Mi?a===-1?16:a|16:a,dynamicProps:t.dynamicProps,dynamicChildren:t.dynamicChildren,appContext:t.appContext,dirs:t.dirs,transition:t.transition,component:t.component,suspense:t.suspense,ssContent:t.ssContent&&Ys(t.ssContent),ssFallback:t.ssFallback&&Ys(t.ssFallback),el:t.el,anchor:t.anchor,ctx:t.ctx,ce:t.ce}}function xl(t=" ",e=0){return ue(Io,null,t,e)}function Pi(t){return t==null||typeof t=="boolean"?ue(Ja):pe(t)?ue(Mi,null,t.slice()):typeof t=="object"?_r(t):ue(Io,null,String(t))}function _r(t){return t.el===null&&t.patchFlag!==-1||t.memo?t:Ys(t)}function Eh(t,e){let i=0;const{shapeFlag:r}=t;if(e==null)e=null;else if(pe(e))i=16;else if(typeof e=="object")if(r&65){const s=e.default;s&&(s._c&&(s._d=!1),Eh(t,s()),s._c&&(s._d=!0));return}else{i=32;const s=e._;!s&&!(wo in e)?e._ctx=qt:s===3&&qt&&(qt.slots._===1?e._=1:(e._=2,t.patchFlag|=1024))}else Ae(e)?(e={default:e,_ctx:qt},i=32):(e=String(e),r&64?(i=16,e=[xl(e)]):i=8);t.children=e,t.shapeFlag|=i}function Th(...t){const e={};for(let i=0;i<t.length;i++){const r=t[i];for(const s in r)if(s==="class")e.class!==r.class&&(e.class=gh([e.class,r.class]));else if(s==="style")e.style=fh([e.style,r.style]);else if(go(s)){const a=e[s],o=r[s];o&&a!==o&&!(pe(a)&&a.includes(o))&&(e[s]=a?[].concat(a,o):o)}else s!==""&&(e[s]=r[s])}return e}function Ei(t,e,i,r=null){vi(t,e,7,[i,r])}const mm=Qd();let Am=0;function _m(t,e,i){const r=t.type,s=(e?e.appContext:t.appContext)||mm,a={uid:Am++,vnode:t,type:r,parent:e,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,scope:new id(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(s.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Gd(r,s),emitsOptions:Ed(r,s),emit:null,emitted:null,propsDefaults:Xe,inheritAttrs:r.inheritAttrs,ctx:Xe,data:Xe,props:Xe,attrs:Xe,slots:Xe,refs:Xe,setupState:Xe,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:i,suspenseId:i?i.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return a.ctx={_:a},a.root=e?e.root:a,a.emit=Ip.bind(null,a),t.ce&&t.ce(a),a}let ut=null;const Wd=()=>ut||qt;let Bh,vs,Eu="__VUE_INSTANCE_SETTERS__";(vs=hl()[Eu])||(vs=hl()[Eu]=[]),vs.push(t=>ut=t),Bh=t=>{vs.length>1?vs.forEach(e=>e(t)):vs[0](t)};const Xs=t=>{Bh(t),t.scope.on()},ns=()=>{ut&&ut.scope.off(),Bh(null)};function jd(t){return t.vnode.shapeFlag&4}let $a=!1;function vm(t,e=!1){$a=e;const{props:i,children:r}=t.vnode,s=jd(t);$p(t,i,s,e),im(t,r);const a=s?xm(t,e):void 0;return $a=!1,a}function xm(t,e){const i=t.type;t.accessCache=Object.create(null),t.proxy=xo(new Proxy(t.ctx,Hp));const{setup:r}=i;if(r){const s=t.setupContext=r.length>1?Cm(t):null;Xs(t),ia();const a=br(r,t,0,[t.props,s]);if(ra(),ns(),ed(a)){if(a.then(ns,ns),e)return a.then(o=>{Tu(t,o,e)}).catch(o=>{yo(o,t,0)});t.asyncDep=a}else Tu(t,a,e)}else qd(t,e)}function Tu(t,e,i){Ae(e)?t.type.__ssrInlineRender?t.ssrRender=e:t.render=e:$e(e)&&(t.setupState=yd(e)),qd(t,i)}let Bu;function qd(t,e,i){const r=t.type;if(!t.render){if(!e&&Bu&&!r.render){const s=r.template||wh(t).template;if(s){const{isCustomElement:a,compilerOptions:o}=t.appContext.config,{delimiters:l,compilerOptions:h}=r,u=yt(yt({isCustomElement:a,delimiters:l},o),h);r.render=Bu(s,u)}}t.render=r.render||_i}{Xs(t),ia();try{Yp(t)}finally{ra(),ns()}}}function ym(t){return t.attrsProxy||(t.attrsProxy=new Proxy(t.attrs,{get(e,i){return Gt(t,"get","$attrs"),e[i]}}))}function Cm(t){const e=i=>{t.exposed=i||{}};return{get attrs(){return ym(t)},slots:t.slots,emit:t.emit,expose:e}}function Dh(t){if(t.exposed)return t.exposeProxy||(t.exposeProxy=new Proxy(yd(xo(t.exposed)),{get(e,i){if(i in e)return e[i];if(i in Ra)return Ra[i](t)},has(e,i){return i in e||i in Ra}}))}function bm(t,e=!0){return Ae(t)?t.displayName||t.name:t.name||e&&t.__name}function Im(t){return Ae(t)&&"__vccOpts"in t}const Et=(t,e)=>_p(t,e,$a);function Jd(t,e,i){const r=arguments.length;return r===2?$e(e)&&!pe(e)?vl(e)?ue(t,null,[e]):ue(t,e):ue(t,null,e):(r>3?i=Array.prototype.slice.call(arguments,2):r===3&&vl(i)&&(i=[i]),ue(t,e,i))}const wm=Symbol.for("v-scx"),Sm=()=>xi(wm),Em="3.3.9",Tm="http://www.w3.org/2000/svg",es=typeof document<"u"?document:null,Du=es&&es.createElement("template"),Bm={insert:(t,e,i)=>{e.insertBefore(t,i||null)},remove:t=>{const e=t.parentNode;e&&e.removeChild(t)},createElement:(t,e,i,r)=>{const s=e?es.createElementNS(Tm,t):es.createElement(t,i?{is:i}:void 0);return t==="select"&&r&&r.multiple!=null&&s.setAttribute("multiple",r.multiple),s},createText:t=>es.createTextNode(t),createComment:t=>es.createComment(t),setText:(t,e)=>{t.nodeValue=e},setElementText:(t,e)=>{t.textContent=e},parentNode:t=>t.parentNode,nextSibling:t=>t.nextSibling,querySelector:t=>es.querySelector(t),setScopeId(t,e){t.setAttribute(e,"")},insertStaticContent(t,e,i,r,s,a){const o=i?i.previousSibling:e.lastChild;if(s&&(s===a||s.nextSibling))for(;e.insertBefore(s.cloneNode(!0),i),!(s===a||!(s=s.nextSibling)););else{Du.innerHTML=r?`<svg>${t}</svg>`:t;const l=Du.content;if(r){const h=l.firstChild;for(;h.firstChild;)l.appendChild(h.firstChild);l.removeChild(h)}e.insertBefore(l,i)}return[o?o.nextSibling:e.firstChild,i?i.previousSibling:e.lastChild]}},Dm=Symbol("_vtc");function Rm(t,e,i){const r=t[Dm];r&&(e=(e?[e,...r]:[...r]).join(" ")),e==null?t.removeAttribute("class"):i?t.setAttribute("class",e):t.className=e}const Mm=Symbol("_vod");function Pm(t,e,i){const r=t.style,s=Ct(i);if(i&&!s){if(e&&!Ct(e))for(const a in e)i[a]==null&&yl(r,a,"");for(const a in i)yl(r,a,i[a])}else{const a=r.display;s?e!==i&&(r.cssText=i):e&&t.removeAttribute("style"),Mm in t&&(r.display=a)}}const Ru=/\s*!important$/;function yl(t,e,i){if(pe(i))i.forEach(r=>yl(t,e,r));else if(i==null&&(i=""),e.startsWith("--"))t.setProperty(e,i);else{const r=Um(t,e);Ru.test(i)?t.setProperty(ta(r),i.replace(Ru,""),"important"):t[r]=i}}const Mu=["Webkit","Moz","ms"],zo={};function Um(t,e){const i=zo[e];if(i)return i;let r=Qi(e);if(r!=="filter"&&r in t)return zo[e]=r;r=_o(r);for(let s=0;s<Mu.length;s++){const a=Mu[s]+r;if(a in t)return zo[e]=a}return e}const Pu="http://www.w3.org/1999/xlink";function Lm(t,e,i,r,s){if(r&&e.startsWith("xlink:"))i==null?t.removeAttributeNS(Pu,e.slice(6,e.length)):t.setAttributeNS(Pu,e,i);else{const a=Qg(e);i==null||a&&!td(i)?t.removeAttribute(e):t.setAttribute(e,a?"":i)}}function Om(t,e,i,r,s,a,o){if(e==="innerHTML"||e==="textContent"){r&&o(r,s,a),t[e]=i??"";return}const l=t.tagName;if(e==="value"&&l!=="PROGRESS"&&!l.includes("-")){t._value=i;const u=l==="OPTION"?t.getAttribute("value"):t.value,c=i??"";u!==c&&(t.value=c),i==null&&t.removeAttribute(e);return}let h=!1;if(i===""||i==null){const u=typeof t[e];u==="boolean"?i=td(i):i==null&&u==="string"?(i="",h=!0):u==="number"&&(i=0,h=!0)}try{t[e]=i}catch{}h&&t.removeAttribute(e)}function Nm(t,e,i,r){t.addEventListener(e,i,r)}function Fm(t,e,i,r){t.removeEventListener(e,i,r)}const Uu=Symbol("_vei");function km(t,e,i,r,s=null){const a=t[Uu]||(t[Uu]={}),o=a[e];if(r&&o)o.value=r;else{const[l,h]=Qm(e);if(r){const u=a[e]=Vm(r,s);Nm(t,l,u,h)}else o&&(Fm(t,l,o,h),a[e]=void 0)}}const Lu=/(?:Once|Passive|Capture)$/;function Qm(t){let e;if(Lu.test(t)){e={};let r;for(;r=t.match(Lu);)t=t.slice(0,t.length-r[0].length),e[r[0].toLowerCase()]=!0}return[t[2]===":"?t.slice(3):ta(t.slice(2)),e]}let Go=0;const zm=Promise.resolve(),Gm=()=>Go||(zm.then(()=>Go=0),Go=Date.now());function Vm(t,e){const i=r=>{if(!r._vts)r._vts=Date.now();else if(r._vts<=i.attached)return;vi(Hm(r,i.value),e,5,[r])};return i.value=t,i.attached=Gm(),i}function Hm(t,e){if(pe(e)){const i=t.stopImmediatePropagation;return t.stopImmediatePropagation=()=>{i.call(t),t._stopped=!0},e.map(r=>s=>!s._stopped&&r&&r(s))}else return e}const Ou=/^on[a-z]/,Ym=(t,e,i,r,s=!1,a,o,l,h)=>{e==="class"?Rm(t,r,s):e==="style"?Pm(t,i,r):go(e)?uh(e)||km(t,e,i,r,o):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):Xm(t,e,r,s))?Om(t,e,r,a,o,l,h):(e==="true-value"?t._trueValue=r:e==="false-value"&&(t._falseValue=r),Lm(t,e,r,s))};function Xm(t,e,i,r){return r?!!(e==="innerHTML"||e==="textContent"||e in t&&Ou.test(e)&&Ae(i)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&t.tagName==="INPUT"||e==="type"&&t.tagName==="TEXTAREA"||Ou.test(e)&&Ct(i)?!1:e in t}const Km=yt({patchProp:Ym},Bm);let Nu;function Wm(){return Nu||(Nu=sm(Km))}const jm=(...t)=>{const e=Wm().createApp(...t),{mount:i}=e;return e.mount=r=>{const s=qm(r);if(!s)return;const a=e._component;!Ae(a)&&!a.render&&!a.template&&(a.template=s.innerHTML),s.innerHTML="";const o=i(s,!1,s instanceof SVGElement);return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),o},e};function qm(t){return Ct(t)?document.querySelector(t):t}const So=Object.assign,Zd=typeof window<"u",$d=t=>t!==null&&typeof t=="object",wr=t=>t!=null,Jm=t=>typeof t=="function",ef=t=>typeof t=="number"||/^\d+(\.\d+)?$/.test(t),Zm=()=>Zd?/ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()):!1;function Fu(t,e){const i=e.split(".");let r=t;return i.forEach(s=>{var a;r=$d(r)&&(a=r[s])!=null?a:""}),r}const Vo=null,Fi=[Number,String],Rh={type:Boolean,default:!0},Wt=t=>({type:String,default:t});var $m=typeof window<"u",fn,Ho;function eA(){if(!fn&&(fn=Br(0),Ho=Br(0),$m)){const t=()=>{fn.value=window.innerWidth,Ho.value=window.innerHeight};t(),window.addEventListener("resize",t,{passive:!0}),window.addEventListener("orientationchange",t,{passive:!0})}return{width:fn,height:Ho}}Zm();const tA=t=>t.stopPropagation();function iA(t,e){(typeof t.cancelable!="boolean"||t.cancelable)&&t.preventDefault(),e&&tA(t)}eA();function gi(t){if(wr(t))return ef(t)?`${t}px`:String(t)}function rA(t){if(wr(t)){if(Array.isArray(t))return{width:gi(t[0]),height:gi(t[1])};const e=gi(t);return{width:e,height:e}}}const sA=/-(\w)/g,tf=t=>t.replace(sA,(e,i)=>i.toUpperCase()),aA=t=>t.replace(/([A-Z])/g,"-$1").toLowerCase().replace(/^-/,""),{hasOwnProperty:nA}=Object.prototype;function oA(t,e,i){const r=e[i];wr(r)&&(!nA.call(t,i)||!$d(r)?t[i]=r:t[i]=rf(Object(t[i]),r))}function rf(t,e){return Object.keys(e).forEach(i=>{oA(t,e,i)}),t}var lA={name:"姓名",tel:"电话",save:"保存",clear:"清空",cancel:"取消",confirm:"确认",delete:"删除",loading:"加载中...",noCoupon:"暂无优惠券",nameEmpty:"请填写姓名",addContact:"添加联系人",telInvalid:"请填写正确的电话",vanCalendar:{end:"结束",start:"开始",title:"日期选择",weekdays:["日","一","二","三","四","五","六"],monthTitle:(t,e)=>`${t}年${e}月`,rangePrompt:t=>`最多选择 ${t} 天`},vanCascader:{select:"请选择"},vanPagination:{prev:"上一页",next:"下一页"},vanPullRefresh:{pulling:"下拉即可刷新...",loosing:"释放即可刷新..."},vanSubmitBar:{label:"合计:"},vanCoupon:{unlimited:"无门槛",discount:t=>`${t}折`,condition:t=>`满${t}元可用`},vanCouponCell:{title:"优惠券",count:t=>`${t}张可用`},vanCouponList:{exchange:"兑换",close:"不使用",enable:"可用",disabled:"不可用",placeholder:"输入优惠码"},vanAddressEdit:{area:"地区",areaEmpty:"请选择地区",addressEmpty:"请填写详细地址",addressDetail:"详细地址",defaultAddress:"设为默认收货地址"},vanAddressList:{add:"新增地址"}};const ku=Br("zh-CN"),Qu=sa({"zh-CN":lA}),hA={messages(){return Qu[ku.value]},use(t,e){ku.value=t,this.add({[t]:e})},add(t={}){rf(Qu,t)}};var uA=hA;function cA(t){const e=tf(t)+".";return(i,...r)=>{const s=uA.messages(),a=Fu(s,e+i)||Fu(s,i);return Jm(a)?a(...r):a}}function Cl(t,e){return e?typeof e=="string"?` ${t}--${e}`:Array.isArray(e)?e.reduce((i,r)=>i+Cl(t,r),""):Object.keys(e).reduce((i,r)=>i+(e[r]?Cl(t,r):""),""):""}function dA(t){return(e,i)=>(e&&typeof e!="string"&&(i=e,e=""),e=e?`${t}__${e}`:t,`${e}${Cl(e,i)}`)}function gs(t){const e=`van-${t}`;return[e,dA(e),cA(e)]}const sf="van-hairline",fA=`${sf}--surround`,gA=`${sf}--top-bottom`;function ps(t){return t.install=e=>{const{name:i}=t;i&&(e.component(i,t),e.component(tf(`-${i}`),t))},t}const af={to:[String,Object],url:String,replace:Boolean};function pA({to:t,url:e,replace:i,$router:r}){t&&r?r[i?"replace":"push"](t):e&&(i?location.replace(e):location.href=e)}function nf(){const t=Wd().proxy;return()=>pA(t)}const[mA,zu]=gs("badge"),AA={dot:Boolean,max:Fi,tag:Wt("div"),color:String,offset:Array,content:Fi,showZero:Rh,position:Wt("top-right")};var _A=Vi({name:mA,props:AA,setup(t,{slots:e}){const i=()=>{if(e.content)return!0;const{content:l,showZero:h}=t;return wr(l)&&l!==""&&(h||l!==0&&l!=="0")},r=()=>{const{dot:l,max:h,content:u}=t;if(!l&&i())return e.content?e.content():wr(h)&&ef(u)&&+u>+h?`${h}+`:u},s=l=>l.startsWith("-")?l.replace("-",""):`-${l}`,a=Et(()=>{const l={background:t.color};if(t.offset){const[h,u]=t.offset,{position:c}=t,[d,f]=c.split("-");e.default?(typeof u=="number"?l[d]=gi(d==="top"?u:-u):l[d]=d==="top"?gi(u):s(u),typeof h=="number"?l[f]=gi(f==="left"?h:-h):l[f]=f==="left"?gi(h):s(h)):(l.marginTop=gi(u),l.marginLeft=gi(h))}return l}),o=()=>{if(i()||t.dot)return ue("div",{class:zu([t.position,{dot:t.dot,fixed:!!e.default}]),style:a.value},[r()])};return()=>{if(e.default){const{tag:l}=t;return ue(l,{class:zu("wrapper")},{default:()=>[e.default(),o()]})}return o()}}});const vA=ps(_A),xA=t=>{},[of,yA]=gs("config-provider"),lf=Symbol(of),CA={tag:Wt("div"),theme:Wt("light"),zIndex:Number,themeVars:Object,themeVarsDark:Object,themeVarsLight:Object,themeVarsScope:Wt("local"),iconPrefix:String};function bA(t){return t.replace(/([a-zA-Z])(\d)/g,"$1-$2")}function IA(t){const e={};return Object.keys(t).forEach(i=>{const r=bA(aA(i));e[`--van-${r}`]=t[i]}),e}function gn(t={},e={}){Object.keys(t).forEach(i=>{t[i]!==e[i]&&document.documentElement.style.setProperty(i,t[i])}),Object.keys(e).forEach(i=>{t[i]||document.documentElement.style.removeProperty(i)})}var wA=Vi({name:of,props:CA,setup(t,{slots:e}){const i=Et(()=>IA(So({},t.themeVars,t.theme==="dark"?t.themeVarsDark:t.themeVarsLight)));if(Zd){const r=()=>{document.documentElement.classList.add(`van-theme-${t.theme}`)},s=(a=t.theme)=>{document.documentElement.classList.remove(`van-theme-${a}`)};Ir(()=>t.theme,(a,o)=>{o&&s(o),r()},{immediate:!0}),Pd(r),Ud(s),Nd(s),Ir(i,(a,o)=>{t.themeVarsScope==="global"&&gn(a,o)}),Ir(()=>t.themeVarsScope,(a,o)=>{o==="global"&&gn({},i.value),a==="global"&&gn(i.value,{})}),t.themeVarsScope==="global"&&gn(i.value,{})}return Ma(lf,t),Up(()=>{t.zIndex!==void 0&&xA(t.zIndex)}),()=>ue(t.tag,{class:yA(),style:t.themeVarsScope==="local"?i.value:void 0},{default:()=>{var r;return[(r=e.default)==null?void 0:r.call(e)]}})}});const[SA,Gu]=gs("icon"),EA=t=>t==null?void 0:t.includes("/"),TA={dot:Boolean,tag:Wt("i"),name:String,size:Fi,badge:Fi,color:String,badgeProps:Object,classPrefix:String};var BA=Vi({name:SA,props:TA,setup(t,{slots:e}){const i=xi(lf,null),r=Et(()=>t.classPrefix||(i==null?void 0:i.iconPrefix)||Gu());return()=>{const{tag:s,dot:a,name:o,size:l,badge:h,color:u}=t,c=EA(o);return ue(vA,Th({dot:a,tag:s,class:[r.value,c?"":`${r.value}-${o}`],style:{color:u,fontSize:gi(l)},content:h},t.badgeProps),{default:()=>{var d;return[(d=e.default)==null?void 0:d.call(e),c&&ue("img",{class:Gu("image"),src:o},null)]}})}}});const bl=ps(BA),[DA,Ua]=gs("loading"),RA=Array(12).fill(null).map((t,e)=>ue("i",{class:Ua("line",String(e+1))},null)),MA=ue("svg",{class:Ua("circular"),viewBox:"25 25 50 50"},[ue("circle",{cx:"50",cy:"50",r:"20",fill:"none"},null)]),PA={size:Fi,type:Wt("circular"),color:String,vertical:Boolean,textSize:Fi,textColor:String};var UA=Vi({name:DA,props:PA,setup(t,{slots:e}){const i=Et(()=>So({color:t.color},rA(t.size))),r=()=>{const a=t.type==="spinner"?RA:MA;return ue("span",{class:Ua("spinner",t.type),style:i.value},[e.icon?e.icon():a])},s=()=>{var a;if(e.default)return ue("span",{class:Ua("text"),style:{fontSize:gi(t.textSize),color:(a=t.textColor)!=null?a:t.color}},[e.default()])};return()=>{const{type:a,vertical:o}=t;return ue("div",{class:Ua([a,{vertical:o}]),"aria-live":"polite","aria-busy":!0},[r(),s()])}}});const LA=ps(UA),[OA,xs]=gs("button"),NA=So({},af,{tag:Wt("button"),text:String,icon:String,type:Wt("default"),size:Wt("normal"),color:String,block:Boolean,plain:Boolean,round:Boolean,square:Boolean,loading:Boolean,hairline:Boolean,disabled:Boolean,iconPrefix:String,nativeType:Wt("button"),loadingSize:Fi,loadingText:String,loadingType:String,iconPosition:Wt("left")});var FA=Vi({name:OA,props:NA,emits:["click"],setup(t,{emit:e,slots:i}){const r=nf(),s=()=>i.loading?i.loading():ue(LA,{size:t.loadingSize,type:t.loadingType,class:xs("loading")},null),a=()=>{if(t.loading)return s();if(i.icon)return ue("div",{class:xs("icon")},[i.icon()]);if(t.icon)return ue(bl,{name:t.icon,class:xs("icon"),classPrefix:t.iconPrefix},null)},o=()=>{let u;if(t.loading?u=t.loadingText:u=i.default?i.default():t.text,u)return ue("span",{class:xs("text")},[u])},l=()=>{const{color:u,plain:c}=t;if(u){const d={color:c?u:"white"};return c||(d.background=u),u.includes("gradient")?d.border=0:d.borderColor=u,d}},h=u=>{t.loading?iA(u):t.disabled||(e("click",u),r())};return()=>{const{tag:u,type:c,size:d,block:f,round:g,plain:m,square:A,loading:_,disabled:x,hairline:b,nativeType:R,iconPosition:E}=t,M=[xs([c,d,{plain:m,block:f,round:g,square:A,loading:_,disabled:x,hairline:b}]),{[fA]:b}];return ue(u,{type:R,class:M,style:l(),disabled:x,onClick:h},{default:()=>[ue("div",{class:xs("content")},[E==="left"&&a(),o(),E==="right"&&a()])]})}}});const kA=ps(FA),QA=()=>{var t;const{scopeId:e}=((t=Wd())==null?void 0:t.vnode)||{};return e?{[e]:""}:null},[zA,ys]=gs("cell"),GA={tag:Wt("div"),icon:String,size:String,title:Fi,value:Fi,label:Fi,center:Boolean,isLink:Boolean,border:Rh,iconPrefix:String,valueClass:Vo,labelClass:Vo,titleClass:Vo,titleStyle:null,arrowDirection:String,required:{type:[Boolean,String],default:null},clickable:{type:Boolean,default:null}},VA=So({},GA,af);var HA=Vi({name:zA,props:VA,setup(t,{slots:e}){const i=nf(),r=()=>{if(e.label||wr(t.label))return ue("div",{class:[ys("label"),t.labelClass]},[e.label?e.label():t.label])},s=()=>{var h;if(e.title||wr(t.title)){const u=(h=e.title)==null?void 0:h.call(e);return Array.isArray(u)&&u.length===0?void 0:ue("div",{class:[ys("title"),t.titleClass],style:t.titleStyle},[u||ue("span",null,[t.title]),r()])}},a=()=>{const h=e.value||e.default;if(h||wr(t.value))return ue("div",{class:[ys("value"),t.valueClass]},[h?h():ue("span",null,[t.value])])},o=()=>{if(e.icon)return e.icon();if(t.icon)return ue(bl,{name:t.icon,class:ys("left-icon"),classPrefix:t.iconPrefix},null)},l=()=>{if(e["right-icon"])return e["right-icon"]();if(t.isLink){const h=t.arrowDirection&&t.arrowDirection!=="right"?`arrow-${t.arrowDirection}`:"arrow";return ue(bl,{name:h,class:ys("right-icon")},null)}};return()=>{var h;const{tag:u,size:c,center:d,border:f,isLink:g,required:m}=t,A=(h=t.clickable)!=null?h:g,_={center:d,required:!!m,clickable:A,borderless:!f};return c&&(_[c]=!!c),ue(u,{class:ys(_),role:A?"button":void 0,tabindex:A?0:void 0,onClick:i},{default:()=>{var x;return[o(),s(),a(),l(),(x=e.extra)==null?void 0:x.call(e)]}})}}});const YA=ps(HA),[XA,Vu]=gs("cell-group"),KA={title:String,inset:Boolean,border:Rh};var WA=Vi({name:XA,inheritAttrs:!1,props:KA,setup(t,{slots:e,attrs:i}){const r=()=>{var a;return ue("div",Th({class:[Vu({inset:t.inset}),{[gA]:t.border&&!t.inset}]},i,QA()),[(a=e.default)==null?void 0:a.call(e)])},s=()=>ue("div",{class:Vu("title",{inset:t.inset})},[e.title?e.title():t.title]);return()=>t.title||e.title?ue(Mi,null,[s(),r()]):r()}});const jA=ps(WA),qA=ps(wA),JA=Vi({__name:"App",setup(t){return(e,i)=>{const r=Bp("router-view");return hm(),dm(as(qA),{theme:"light"},{default:Bd(()=>[ue(r)]),_:1})}}});var ZA=!1;/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */let hf;const Eo=t=>hf=t,uf=Symbol();function Il(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var La;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(La||(La={}));function $A(){const t=rd(!0),e=t.run(()=>Br({}));let i=[],r=[];const s=xo({install(a){Eo(s),s._a=a,a.provide(uf,s),a.config.globalProperties.$pinia=s,r.forEach(o=>i.push(o)),r=[]},use(a){return!this._a&&!ZA?r.push(a):i.push(a),this},_p:i,_a:null,_e:t,_s:new Map,state:e});return s}const cf=()=>{};function Hu(t,e,i,r=cf){t.push(e);const s=()=>{const a=t.indexOf(e);a>-1&&(t.splice(a,1),r())};return!i&&sd()&&Gg(s),s}function Cs(t,...e){t.slice().forEach(i=>{i(...e)})}const e_=t=>t();function wl(t,e){t instanceof Map&&e instanceof Map&&e.forEach((i,r)=>t.set(r,i)),t instanceof Set&&e instanceof Set&&e.forEach(t.add,t);for(const i in e){if(!e.hasOwnProperty(i))continue;const r=e[i],s=t[i];Il(s)&&Il(r)&&t.hasOwnProperty(i)&&!je(r)&&!sr(r)?t[i]=wl(s,r):t[i]=r}return t}const t_=Symbol();function i_(t){return!Il(t)||!t.hasOwnProperty(t_)}const{assign:dr}=Object;function r_(t){return!!(je(t)&&t.effect)}function s_(t,e,i,r){const{state:s,actions:a,getters:o}=e,l=i.state.value[t];let h;function u(){l||(i.state.value[t]=s?s():{});const c=fp(i.state.value[t]);return dr(c,a,Object.keys(o||{}).reduce((d,f)=>(d[f]=xo(Et(()=>{Eo(i);const g=i._s.get(t);return o[f].call(g,g)})),d),{}))}return h=df(t,u,e,i,r,!0),h}function df(t,e,i={},r,s,a){let o;const l=dr({actions:{}},i),h={deep:!0};let u,c,d=[],f=[],g;const m=r.state.value[t];!a&&!m&&(r.state.value[t]={}),Br({});let A;function _(k){let O;u=c=!1,typeof k=="function"?(k(r.state.value[t]),O={type:La.patchFunction,storeId:t,events:g}):(wl(r.state.value[t],k),O={type:La.patchObject,payload:k,storeId:t,events:g});const ce=A=Symbol();Ch().then(()=>{A===ce&&(u=!0)}),c=!0,Cs(d,O,r.state.value[t])}const x=a?function(){const{state:O}=i,ce=O?O():{};this.$patch(we=>{dr(we,ce)})}:cf;function b(){o.stop(),d=[],f=[],r._s.delete(t)}function R(k,O){return function(){Eo(r);const ce=Array.from(arguments),we=[],Ce=[];function be(he){we.push(he)}function De(he){Ce.push(he)}Cs(f,{args:ce,name:k,store:M,after:be,onError:De});let Ee;try{Ee=O.apply(this&&this.$id===t?this:M,ce)}catch(he){throw Cs(Ce,he),he}return Ee instanceof Promise?Ee.then(he=>(Cs(we,he),he)).catch(he=>(Cs(Ce,he),Promise.reject(he))):(Cs(we,Ee),Ee)}}const E={_p:r,$id:t,$onAction:Hu.bind(null,f),$patch:_,$reset:x,$subscribe(k,O={}){const ce=Hu(d,k,O.detached,()=>we()),we=o.run(()=>Ir(()=>r.state.value[t],Ce=>{(O.flush==="sync"?c:u)&&k({storeId:t,type:La.direct,events:g},Ce)},dr({},h,O)));return ce},$dispose:b},M=sa(E);r._s.set(t,M);const V=(r._a&&r._a.runWithContext||e_)(()=>r._e.run(()=>(o=rd()).run(e)));for(const k in V){const O=V[k];if(je(O)&&!r_(O)||sr(O))a||(m&&i_(O)&&(je(O)?O.value=m[k]:wl(O,m[k])),r.state.value[t][k]=O);else if(typeof O=="function"){const ce=R(k,O);V[k]=ce,l.actions[k]=O}}return dr(M,V),dr(Be(M),V),Object.defineProperty(M,"$state",{get:()=>r.state.value[t],set:k=>{_(O=>{dr(O,k)})}}),r._p.forEach(k=>{dr(M,o.run(()=>k({store:M,app:r._a,pinia:r,options:l})))}),m&&a&&i.hydrate&&i.hydrate(M.$state,m),u=!0,c=!0,M}function a_(t,e,i){let r,s;const a=typeof e=="function";typeof t=="string"?(r=t,s=a?i:e):(s=t,r=t.id);function o(l,h){const u=Zp();return l=l||(u?xi(uf,null):null),l&&Eo(l),l=hf,l._s.has(r)||(a?df(r,e,s,l):s_(r,s,l)),l._s.get(r)}return o.$id=r,o}function n_(t){{t=Be(t);const e={};for(const i in t){const r=t[i];(je(r)||sr(r))&&(e[i]=mp(t,i))}return e}}/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */const ws=typeof window<"u";function o_(t){return t.__esModule||t[Symbol.toStringTag]==="Module"}const ke=Object.assign;function Yo(t,e){const i={};for(const r in e){const s=e[r];i[r]=yi(s)?s.map(t):t(s)}return i}const Oa=()=>{},yi=Array.isArray,l_=/\/$/,h_=t=>t.replace(l_,"");function Xo(t,e,i="/"){let r,s={},a="",o="";const l=e.indexOf("#");let h=e.indexOf("?");return l<h&&l>=0&&(h=-1),h>-1&&(r=e.slice(0,h),a=e.slice(h+1,l>-1?l:e.length),s=t(a)),l>-1&&(r=r||e.slice(0,l),o=e.slice(l,e.length)),r=f_(r??e,i),{fullPath:r+(a&&"?")+a+o,path:r,query:s,hash:o}}function u_(t,e){const i=e.query?t(e.query):"";return e.path+(i&&"?")+i+(e.hash||"")}function Yu(t,e){return!e||!t.toLowerCase().startsWith(e.toLowerCase())?t:t.slice(e.length)||"/"}function c_(t,e,i){const r=e.matched.length-1,s=i.matched.length-1;return r>-1&&r===s&&Ks(e.matched[r],i.matched[s])&&ff(e.params,i.params)&&t(e.query)===t(i.query)&&e.hash===i.hash}function Ks(t,e){return(t.aliasOf||t)===(e.aliasOf||e)}function ff(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const i in t)if(!d_(t[i],e[i]))return!1;return!0}function d_(t,e){return yi(t)?Xu(t,e):yi(e)?Xu(e,t):t===e}function Xu(t,e){return yi(e)?t.length===e.length&&t.every((i,r)=>i===e[r]):t.length===1&&t[0]===e}function f_(t,e){if(t.startsWith("/"))return t;if(!t)return e;const i=e.split("/"),r=t.split("/"),s=r[r.length-1];(s===".."||s===".")&&r.push("");let a=i.length-1,o,l;for(o=0;o<r.length;o++)if(l=r[o],l!==".")if(l==="..")a>1&&a--;else break;return i.slice(0,a).join("/")+"/"+r.slice(o-(o===r.length?1:0)).join("/")}var en;(function(t){t.pop="pop",t.push="push"})(en||(en={}));var Na;(function(t){t.back="back",t.forward="forward",t.unknown=""})(Na||(Na={}));function g_(t){if(!t)if(ws){const e=document.querySelector("base");t=e&&e.getAttribute("href")||"/",t=t.replace(/^\w+:\/\/[^\/]+/,"")}else t="/";return t[0]!=="/"&&t[0]!=="#"&&(t="/"+t),h_(t)}const p_=/^[^#]+#/;function m_(t,e){return t.replace(p_,"#")+e}function A_(t,e){const i=document.documentElement.getBoundingClientRect(),r=t.getBoundingClientRect();return{behavior:e.behavior,left:r.left-i.left-(e.left||0),top:r.top-i.top-(e.top||0)}}const To=()=>({left:window.pageXOffset,top:window.pageYOffset});function __(t){let e;if("el"in t){const i=t.el,r=typeof i=="string"&&i.startsWith("#"),s=typeof i=="string"?r?document.getElementById(i.slice(1)):document.querySelector(i):i;if(!s)return;e=A_(s,t)}else e=t;"scrollBehavior"in document.documentElement.style?window.scrollTo(e):window.scrollTo(e.left!=null?e.left:window.pageXOffset,e.top!=null?e.top:window.pageYOffset)}function Ku(t,e){return(history.state?history.state.position-e:-1)+t}const Sl=new Map;function v_(t,e){Sl.set(t,e)}function x_(t){const e=Sl.get(t);return Sl.delete(t),e}let y_=()=>location.protocol+"//"+location.host;function gf(t,e){const{pathname:i,search:r,hash:s}=e,a=t.indexOf("#");if(a>-1){let l=s.includes(t.slice(a))?t.slice(a).length:1,h=s.slice(l);return h[0]!=="/"&&(h="/"+h),Yu(h,"")}return Yu(i,t)+r+s}function C_(t,e,i,r){let s=[],a=[],o=null;const l=({state:f})=>{const g=gf(t,location),m=i.value,A=e.value;let _=0;if(f){if(i.value=g,e.value=f,o&&o===m){o=null;return}_=A?f.position-A.position:0}else r(g);s.forEach(x=>{x(i.value,m,{delta:_,type:en.pop,direction:_?_>0?Na.forward:Na.back:Na.unknown})})};function h(){o=i.value}function u(f){s.push(f);const g=()=>{const m=s.indexOf(f);m>-1&&s.splice(m,1)};return a.push(g),g}function c(){const{history:f}=window;f.state&&f.replaceState(ke({},f.state,{scroll:To()}),"")}function d(){for(const f of a)f();a=[],window.removeEventListener("popstate",l),window.removeEventListener("beforeunload",c)}return window.addEventListener("popstate",l),window.addEventListener("beforeunload",c,{passive:!0}),{pauseListeners:h,listen:u,destroy:d}}function Wu(t,e,i,r=!1,s=!1){return{back:t,current:e,forward:i,replaced:r,position:window.history.length,scroll:s?To():null}}function b_(t){const{history:e,location:i}=window,r={value:gf(t,i)},s={value:e.state};s.value||a(r.value,{back:null,current:r.value,forward:null,position:e.length-1,replaced:!0,scroll:null},!0);function a(h,u,c){const d=t.indexOf("#"),f=d>-1?(i.host&&document.querySelector("base")?t:t.slice(d))+h:y_()+t+h;try{e[c?"replaceState":"pushState"](u,"",f),s.value=u}catch(g){console.error(g),i[c?"replace":"assign"](f)}}function o(h,u){const c=ke({},e.state,Wu(s.value.back,h,s.value.forward,!0),u,{position:s.value.position});a(h,c,!0),r.value=h}function l(h,u){const c=ke({},s.value,e.state,{forward:h,scroll:To()});a(c.current,c,!0);const d=ke({},Wu(r.value,h,null),{position:c.position+1},u);a(h,d,!1),r.value=h}return{location:r,state:s,push:l,replace:o}}function I_(t){t=g_(t);const e=b_(t),i=C_(t,e.state,e.location,e.replace);function r(a,o=!0){o||i.pauseListeners(),history.go(a)}const s=ke({location:"",base:t,go:r,createHref:m_.bind(null,t)},e,i);return Object.defineProperty(s,"location",{enumerable:!0,get:()=>e.location.value}),Object.defineProperty(s,"state",{enumerable:!0,get:()=>e.state.value}),s}function w_(t){return t=location.host?t||location.pathname+location.search:"",t.includes("#")||(t+="#"),I_(t)}function S_(t){return typeof t=="string"||t&&typeof t=="object"}function pf(t){return typeof t=="string"||typeof t=="symbol"}const cr={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},mf=Symbol("");var ju;(function(t){t[t.aborted=4]="aborted",t[t.cancelled=8]="cancelled",t[t.duplicated=16]="duplicated"})(ju||(ju={}));function Ws(t,e){return ke(new Error,{type:t,[mf]:!0},e)}function Wi(t,e){return t instanceof Error&&mf in t&&(e==null||!!(t.type&e))}const qu="[^/]+?",E_={sensitive:!1,strict:!1,start:!0,end:!0},T_=/[.+*?^${}()[\]/\\]/g;function B_(t,e){const i=ke({},E_,e),r=[];let s=i.start?"^":"";const a=[];for(const u of t){const c=u.length?[]:[90];i.strict&&!u.length&&(s+="/");for(let d=0;d<u.length;d++){const f=u[d];let g=40+(i.sensitive?.25:0);if(f.type===0)d||(s+="/"),s+=f.value.replace(T_,"\\$&"),g+=40;else if(f.type===1){const{value:m,repeatable:A,optional:_,regexp:x}=f;a.push({name:m,repeatable:A,optional:_});const b=x||qu;if(b!==qu){g+=10;try{new RegExp(`(${b})`)}catch(E){throw new Error(`Invalid custom RegExp for param "${m}" (${b}): `+E.message)}}let R=A?`((?:${b})(?:/(?:${b}))*)`:`(${b})`;d||(R=_&&u.length<2?`(?:/${R})`:"/"+R),_&&(R+="?"),s+=R,g+=20,_&&(g+=-8),A&&(g+=-20),b===".*"&&(g+=-50)}c.push(g)}r.push(c)}if(i.strict&&i.end){const u=r.length-1;r[u][r[u].length-1]+=.7000000000000001}i.strict||(s+="/?"),i.end?s+="$":i.strict&&(s+="(?:/|$)");const o=new RegExp(s,i.sensitive?"":"i");function l(u){const c=u.match(o),d={};if(!c)return null;for(let f=1;f<c.length;f++){const g=c[f]||"",m=a[f-1];d[m.name]=g&&m.repeatable?g.split("/"):g}return d}function h(u){let c="",d=!1;for(const f of t){(!d||!c.endsWith("/"))&&(c+="/"),d=!1;for(const g of f)if(g.type===0)c+=g.value;else if(g.type===1){const{value:m,repeatable:A,optional:_}=g,x=m in u?u[m]:"";if(yi(x)&&!A)throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);const b=yi(x)?x.join("/"):x;if(!b)if(_)f.length<2&&(c.endsWith("/")?c=c.slice(0,-1):d=!0);else throw new Error(`Missing required param "${m}"`);c+=b}}return c||"/"}return{re:o,score:r,keys:a,parse:l,stringify:h}}function D_(t,e){let i=0;for(;i<t.length&&i<e.length;){const r=e[i]-t[i];if(r)return r;i++}return t.length<e.length?t.length===1&&t[0]===40+40?-1:1:t.length>e.length?e.length===1&&e[0]===40+40?1:-1:0}function R_(t,e){let i=0;const r=t.score,s=e.score;for(;i<r.length&&i<s.length;){const a=D_(r[i],s[i]);if(a)return a;i++}if(Math.abs(s.length-r.length)===1){if(Ju(r))return 1;if(Ju(s))return-1}return s.length-r.length}function Ju(t){const e=t[t.length-1];return t.length>0&&e[e.length-1]<0}const M_={type:0,value:""},P_=/[a-zA-Z0-9_]/;function U_(t){if(!t)return[[]];if(t==="/")return[[M_]];if(!t.startsWith("/"))throw new Error(`Invalid path "${t}"`);function e(g){throw new Error(`ERR (${i})/"${u}": ${g}`)}let i=0,r=i;const s=[];let a;function o(){a&&s.push(a),a=[]}let l=0,h,u="",c="";function d(){u&&(i===0?a.push({type:0,value:u}):i===1||i===2||i===3?(a.length>1&&(h==="*"||h==="+")&&e(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),a.push({type:1,value:u,regexp:c,repeatable:h==="*"||h==="+",optional:h==="*"||h==="?"})):e("Invalid state to consume buffer"),u="")}function f(){u+=h}for(;l<t.length;){if(h=t[l++],h==="\\"&&i!==2){r=i,i=4;continue}switch(i){case 0:h==="/"?(u&&d(),o()):h===":"?(d(),i=1):f();break;case 4:f(),i=r;break;case 1:h==="("?i=2:P_.test(h)?f():(d(),i=0,h!=="*"&&h!=="?"&&h!=="+"&&l--);break;case 2:h===")"?c[c.length-1]=="\\"?c=c.slice(0,-1)+h:i=3:c+=h;break;case 3:d(),i=0,h!=="*"&&h!=="?"&&h!=="+"&&l--,c="";break;default:e("Unknown state");break}}return i===2&&e(`Unfinished custom RegExp for param "${u}"`),d(),o(),s}function L_(t,e,i){const r=B_(U_(t.path),i),s=ke(r,{record:t,parent:e,children:[],alias:[]});return e&&!s.record.aliasOf==!e.record.aliasOf&&e.children.push(s),s}function O_(t,e){const i=[],r=new Map;e=ec({strict:!1,end:!0,sensitive:!1},e);function s(c){return r.get(c)}function a(c,d,f){const g=!f,m=N_(c);m.aliasOf=f&&f.record;const A=ec(e,c),_=[m];if("alias"in c){const R=typeof c.alias=="string"?[c.alias]:c.alias;for(const E of R)_.push(ke({},m,{components:f?f.record.components:m.components,path:E,aliasOf:f?f.record:m}))}let x,b;for(const R of _){const{path:E}=R;if(d&&E[0]!=="/"){const M=d.record.path,G=M[M.length-1]==="/"?"":"/";R.path=d.record.path+(E&&G+E)}if(x=L_(R,d,A),f?f.alias.push(x):(b=b||x,b!==x&&b.alias.push(x),g&&c.name&&!$u(x)&&o(c.name)),m.children){const M=m.children;for(let G=0;G<M.length;G++)a(M[G],x,f&&f.children[G])}f=f||x,(x.record.components&&Object.keys(x.record.components).length||x.record.name||x.record.redirect)&&h(x)}return b?()=>{o(b)}:Oa}function o(c){if(pf(c)){const d=r.get(c);d&&(r.delete(c),i.splice(i.indexOf(d),1),d.children.forEach(o),d.alias.forEach(o))}else{const d=i.indexOf(c);d>-1&&(i.splice(d,1),c.record.name&&r.delete(c.record.name),c.children.forEach(o),c.alias.forEach(o))}}function l(){return i}function h(c){let d=0;for(;d<i.length&&R_(c,i[d])>=0&&(c.record.path!==i[d].record.path||!Af(c,i[d]));)d++;i.splice(d,0,c),c.record.name&&!$u(c)&&r.set(c.record.name,c)}function u(c,d){let f,g={},m,A;if("name"in c&&c.name){if(f=r.get(c.name),!f)throw Ws(1,{location:c});A=f.record.name,g=ke(Zu(d.params,f.keys.filter(b=>!b.optional).map(b=>b.name)),c.params&&Zu(c.params,f.keys.map(b=>b.name))),m=f.stringify(g)}else if("path"in c)m=c.path,f=i.find(b=>b.re.test(m)),f&&(g=f.parse(m),A=f.record.name);else{if(f=d.name?r.get(d.name):i.find(b=>b.re.test(d.path)),!f)throw Ws(1,{location:c,currentLocation:d});A=f.record.name,g=ke({},d.params,c.params),m=f.stringify(g)}const _=[];let x=f;for(;x;)_.unshift(x.record),x=x.parent;return{name:A,path:m,params:g,matched:_,meta:k_(_)}}return t.forEach(c=>a(c)),{addRoute:a,resolve:u,removeRoute:o,getRoutes:l,getRecordMatcher:s}}function Zu(t,e){const i={};for(const r of e)r in t&&(i[r]=t[r]);return i}function N_(t){return{path:t.path,redirect:t.redirect,name:t.name,meta:t.meta||{},aliasOf:void 0,beforeEnter:t.beforeEnter,props:F_(t),children:t.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in t?t.components||null:t.component&&{default:t.component}}}function F_(t){const e={},i=t.props||!1;if("component"in t)e.default=i;else for(const r in t.components)e[r]=typeof i=="object"?i[r]:i;return e}function $u(t){for(;t;){if(t.record.aliasOf)return!0;t=t.parent}return!1}function k_(t){return t.reduce((e,i)=>ke(e,i.meta),{})}function ec(t,e){const i={};for(const r in t)i[r]=r in e?e[r]:t[r];return i}function Af(t,e){return e.children.some(i=>i===t||Af(t,i))}const _f=/#/g,Q_=/&/g,z_=/\//g,G_=/=/g,V_=/\?/g,vf=/\+/g,H_=/%5B/g,Y_=/%5D/g,xf=/%5E/g,X_=/%60/g,yf=/%7B/g,K_=/%7C/g,Cf=/%7D/g,W_=/%20/g;function Mh(t){return encodeURI(""+t).replace(K_,"|").replace(H_,"[").replace(Y_,"]")}function j_(t){return Mh(t).replace(yf,"{").replace(Cf,"}").replace(xf,"^")}function El(t){return Mh(t).replace(vf,"%2B").replace(W_,"+").replace(_f,"%23").replace(Q_,"%26").replace(X_,"`").replace(yf,"{").replace(Cf,"}").replace(xf,"^")}function q_(t){return El(t).replace(G_,"%3D")}function J_(t){return Mh(t).replace(_f,"%23").replace(V_,"%3F")}function Z_(t){return t==null?"":J_(t).replace(z_,"%2F")}function qn(t){try{return decodeURIComponent(""+t)}catch{}return""+t}function $_(t){const e={};if(t===""||t==="?")return e;const r=(t[0]==="?"?t.slice(1):t).split("&");for(let s=0;s<r.length;++s){const a=r[s].replace(vf," "),o=a.indexOf("="),l=qn(o<0?a:a.slice(0,o)),h=o<0?null:qn(a.slice(o+1));if(l in e){let u=e[l];yi(u)||(u=e[l]=[u]),u.push(h)}else e[l]=h}return e}function tc(t){let e="";for(let i in t){const r=t[i];if(i=q_(i),r==null){r!==void 0&&(e+=(e.length?"&":"")+i);continue}(yi(r)?r.map(a=>a&&El(a)):[r&&El(r)]).forEach(a=>{a!==void 0&&(e+=(e.length?"&":"")+i,a!=null&&(e+="="+a))})}return e}function e0(t){const e={};for(const i in t){const r=t[i];r!==void 0&&(e[i]=yi(r)?r.map(s=>s==null?null:""+s):r==null?r:""+r)}return e}const t0=Symbol(""),ic=Symbol(""),Ph=Symbol(""),bf=Symbol(""),Tl=Symbol("");function la(){let t=[];function e(r){return t.push(r),()=>{const s=t.indexOf(r);s>-1&&t.splice(s,1)}}function i(){t=[]}return{add:e,list:()=>t.slice(),reset:i}}function vr(t,e,i,r,s){const a=r&&(r.enterCallbacks[s]=r.enterCallbacks[s]||[]);return()=>new Promise((o,l)=>{const h=d=>{d===!1?l(Ws(4,{from:i,to:e})):d instanceof Error?l(d):S_(d)?l(Ws(2,{from:e,to:d})):(a&&r.enterCallbacks[s]===a&&typeof d=="function"&&a.push(d),o())},u=t.call(r&&r.instances[s],e,i,h);let c=Promise.resolve(u);t.length<3&&(c=c.then(h)),c.catch(d=>l(d))})}function Ko(t,e,i,r){const s=[];for(const a of t)for(const o in a.components){let l=a.components[o];if(!(e!=="beforeRouteEnter"&&!a.instances[o]))if(i0(l)){const u=(l.__vccOpts||l)[e];u&&s.push(vr(u,i,r,a,o))}else{let h=l();s.push(()=>h.then(u=>{if(!u)return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${a.path}"`));const c=o_(u)?u.default:u;a.components[o]=c;const f=(c.__vccOpts||c)[e];return f&&vr(f,i,r,a,o)()}))}}return s}function i0(t){return typeof t=="object"||"displayName"in t||"props"in t||"__vccOpts"in t}function rc(t){const e=xi(Ph),i=xi(bf),r=Et(()=>e.resolve(as(t.to))),s=Et(()=>{const{matched:h}=r.value,{length:u}=h,c=h[u-1],d=i.matched;if(!c||!d.length)return-1;const f=d.findIndex(Ks.bind(null,c));if(f>-1)return f;const g=sc(h[u-2]);return u>1&&sc(c)===g&&d[d.length-1].path!==g?d.findIndex(Ks.bind(null,h[u-2])):f}),a=Et(()=>s.value>-1&&n0(i.params,r.value.params)),o=Et(()=>s.value>-1&&s.value===i.matched.length-1&&ff(i.params,r.value.params));function l(h={}){return a0(h)?e[as(t.replace)?"replace":"push"](as(t.to)).catch(Oa):Promise.resolve()}return{route:r,href:Et(()=>r.value.href),isActive:a,isExactActive:o,navigate:l}}const r0=Vi({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:rc,setup(t,{slots:e}){const i=sa(rc(t)),{options:r}=xi(Ph),s=Et(()=>({[ac(t.activeClass,r.linkActiveClass,"router-link-active")]:i.isActive,[ac(t.exactActiveClass,r.linkExactActiveClass,"router-link-exact-active")]:i.isExactActive}));return()=>{const a=e.default&&e.default(i);return t.custom?a:Jd("a",{"aria-current":i.isExactActive?t.ariaCurrentValue:null,href:i.href,onClick:i.navigate,class:s.value},a)}}}),s0=r0;function a0(t){if(!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)&&!t.defaultPrevented&&!(t.button!==void 0&&t.button!==0)){if(t.currentTarget&&t.currentTarget.getAttribute){const e=t.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return t.preventDefault&&t.preventDefault(),!0}}function n0(t,e){for(const i in e){const r=e[i],s=t[i];if(typeof r=="string"){if(r!==s)return!1}else if(!yi(s)||s.length!==r.length||r.some((a,o)=>a!==s[o]))return!1}return!0}function sc(t){return t?t.aliasOf?t.aliasOf.path:t.path:""}const ac=(t,e,i)=>t??e??i,o0=Vi({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(t,{attrs:e,slots:i}){const r=xi(Tl),s=Et(()=>t.route||r.value),a=xi(ic,0),o=Et(()=>{let u=as(a);const{matched:c}=s.value;let d;for(;(d=c[u])&&!d.components;)u++;return u}),l=Et(()=>s.value.matched[o.value]);Ma(ic,Et(()=>o.value+1)),Ma(t0,l),Ma(Tl,s);const h=Br();return Ir(()=>[h.value,l.value,t.name],([u,c,d],[f,g,m])=>{c&&(c.instances[d]=u,g&&g!==c&&u&&u===f&&(c.leaveGuards.size||(c.leaveGuards=g.leaveGuards),c.updateGuards.size||(c.updateGuards=g.updateGuards))),u&&c&&(!g||!Ks(c,g)||!f)&&(c.enterCallbacks[d]||[]).forEach(A=>A(u))},{flush:"post"}),()=>{const u=s.value,c=t.name,d=l.value,f=d&&d.components[c];if(!f)return nc(i.default,{Component:f,route:u});const g=d.props[c],m=g?g===!0?u.params:typeof g=="function"?g(u):g:null,_=Jd(f,ke({},m,e,{onVnodeUnmounted:x=>{x.component.isUnmounted&&(d.instances[c]=null)},ref:h}));return nc(i.default,{Component:_,route:u})||_}}});function nc(t,e){if(!t)return null;const i=t(e);return i.length===1?i[0]:i}const l0=o0;function h0(t){const e=O_(t.routes,t),i=t.parseQuery||$_,r=t.stringifyQuery||tc,s=t.history,a=la(),o=la(),l=la(),h=up(cr);let u=cr;ws&&t.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const c=Yo.bind(null,U=>""+U),d=Yo.bind(null,Z_),f=Yo.bind(null,qn);function g(U,ee){let J,se;return pf(U)?(J=e.getRecordMatcher(U),se=ee):se=U,e.addRoute(se,J)}function m(U){const ee=e.getRecordMatcher(U);ee&&e.removeRoute(ee)}function A(){return e.getRoutes().map(U=>U.record)}function _(U){return!!e.getRecordMatcher(U)}function x(U,ee){if(ee=ke({},ee||h.value),typeof U=="string"){const S=Xo(i,U,ee.path),P=e.resolve({path:S.path},ee),N=s.createHref(S.fullPath);return ke(S,P,{params:f(P.params),hash:qn(S.hash),redirectedFrom:void 0,href:N})}let J;if("path"in U)J=ke({},U,{path:Xo(i,U.path,ee.path).path});else{const S=ke({},U.params);for(const P in S)S[P]==null&&delete S[P];J=ke({},U,{params:d(S)}),ee.params=d(ee.params)}const se=e.resolve(J,ee),Le=U.hash||"";se.params=c(f(se.params));const y=u_(r,ke({},U,{hash:j_(Le),path:se.path})),C=s.createHref(y);return ke({fullPath:y,hash:Le,query:r===tc?e0(U.query):U.query||{}},se,{redirectedFrom:void 0,href:C})}function b(U){return typeof U=="string"?Xo(i,U,h.value.path):ke({},U)}function R(U,ee){if(u!==U)return Ws(8,{from:ee,to:U})}function E(U){return V(U)}function M(U){return E(ke(b(U),{replace:!0}))}function G(U){const ee=U.matched[U.matched.length-1];if(ee&&ee.redirect){const{redirect:J}=ee;let se=typeof J=="function"?J(U):J;return typeof se=="string"&&(se=se.includes("?")||se.includes("#")?se=b(se):{path:se},se.params={}),ke({query:U.query,hash:U.hash,params:"path"in se?{}:U.params},se)}}function V(U,ee){const J=u=x(U),se=h.value,Le=U.state,y=U.force,C=U.replace===!0,S=G(J);if(S)return V(ke(b(S),{state:typeof S=="object"?ke({},Le,S.state):Le,force:y,replace:C}),ee||J);const P=J;P.redirectedFrom=ee;let N;return!y&&c_(r,se,J)&&(N=Ws(16,{to:P,from:se}),tt(se,se,!0,!1)),(N?Promise.resolve(N):ce(P,se)).catch(F=>Wi(F)?Wi(F,2)?F:Qe(F):de(F,P,se)).then(F=>{if(F){if(Wi(F,2))return V(ke({replace:C},b(F.to),{state:typeof F.to=="object"?ke({},Le,F.to.state):Le,force:y}),ee||P)}else F=Ce(P,se,!0,C,Le);return we(P,se,F),F})}function k(U,ee){const J=R(U,ee);return J?Promise.reject(J):Promise.resolve()}function O(U){const ee=Ki.values().next().value;return ee&&typeof ee.runWithContext=="function"?ee.runWithContext(U):U()}function ce(U,ee){let J;const[se,Le,y]=u0(U,ee);J=Ko(se.reverse(),"beforeRouteLeave",U,ee);for(const S of se)S.leaveGuards.forEach(P=>{J.push(vr(P,U,ee))});const C=k.bind(null,U,ee);return J.push(C),ot(J).then(()=>{J=[];for(const S of a.list())J.push(vr(S,U,ee));return J.push(C),ot(J)}).then(()=>{J=Ko(Le,"beforeRouteUpdate",U,ee);for(const S of Le)S.updateGuards.forEach(P=>{J.push(vr(P,U,ee))});return J.push(C),ot(J)}).then(()=>{J=[];for(const S of y)if(S.beforeEnter)if(yi(S.beforeEnter))for(const P of S.beforeEnter)J.push(vr(P,U,ee));else J.push(vr(S.beforeEnter,U,ee));return J.push(C),ot(J)}).then(()=>(U.matched.forEach(S=>S.enterCallbacks={}),J=Ko(y,"beforeRouteEnter",U,ee),J.push(C),ot(J))).then(()=>{J=[];for(const S of o.list())J.push(vr(S,U,ee));return J.push(C),ot(J)}).catch(S=>Wi(S,8)?S:Promise.reject(S))}function we(U,ee,J){l.list().forEach(se=>O(()=>se(U,ee,J)))}function Ce(U,ee,J,se,Le){const y=R(U,ee);if(y)return y;const C=ee===cr,S=ws?history.state:{};J&&(se||C?s.replace(U.fullPath,ke({scroll:C&&S&&S.scroll},Le)):s.push(U.fullPath,Le)),h.value=U,tt(U,ee,J,C),Qe()}let be;function De(){be||(be=s.listen((U,ee,J)=>{if(!Qr.listening)return;const se=x(U),Le=G(se);if(Le){V(ke(Le,{replace:!0}),se).catch(Oa);return}u=se;const y=h.value;ws&&v_(Ku(y.fullPath,J.delta),To()),ce(se,y).catch(C=>Wi(C,12)?C:Wi(C,2)?(V(C.to,se).then(S=>{Wi(S,20)&&!J.delta&&J.type===en.pop&&s.go(-1,!1)}).catch(Oa),Promise.reject()):(J.delta&&s.go(-J.delta,!1),de(C,se,y))).then(C=>{C=C||Ce(se,y,!1),C&&(J.delta&&!Wi(C,8)?s.go(-J.delta,!1):J.type===en.pop&&Wi(C,20)&&s.go(-1,!1)),we(se,y,C)}).catch(Oa)}))}let Ee=la(),he=la(),_e;function de(U,ee,J){Qe(U);const se=he.list();return se.length?se.forEach(Le=>Le(U,ee,J)):console.error(U),Promise.reject(U)}function et(){return _e&&h.value!==cr?Promise.resolve():new Promise((U,ee)=>{Ee.add([U,ee])})}function Qe(U){return _e||(_e=!U,De(),Ee.list().forEach(([ee,J])=>U?J(U):ee()),Ee.reset()),U}function tt(U,ee,J,se){const{scrollBehavior:Le}=t;if(!ws||!Le)return Promise.resolve();const y=!J&&x_(Ku(U.fullPath,0))||(se||!J)&&history.state&&history.state.scroll||null;return Ch().then(()=>Le(U,ee,y)).then(C=>C&&__(C)).catch(C=>de(C,U,ee))}const at=U=>s.go(U);let ei;const Ki=new Set,Qr={currentRoute:h,listening:!0,addRoute:g,removeRoute:m,hasRoute:_,getRoutes:A,resolve:x,options:t,push:E,replace:M,go:at,back:()=>at(-1),forward:()=>at(1),beforeEach:a.add,beforeResolve:o.add,afterEach:l.add,onError:he.add,isReady:et,install(U){const ee=this;U.component("RouterLink",s0),U.component("RouterView",l0),U.config.globalProperties.$router=ee,Object.defineProperty(U.config.globalProperties,"$route",{enumerable:!0,get:()=>as(h)}),ws&&!ei&&h.value===cr&&(ei=!0,E(s.location).catch(Le=>{}));const J={};for(const Le in cr)Object.defineProperty(J,Le,{get:()=>h.value[Le],enumerable:!0});U.provide(Ph,ee),U.provide(bf,pd(J)),U.provide(Tl,h);const se=U.unmount;Ki.add(U),U.unmount=function(){Ki.delete(U),Ki.size<1&&(u=cr,be&&be(),be=null,h.value=cr,ei=!1,_e=!1),se()}}};function ot(U){return U.reduce((ee,J)=>ee.then(()=>O(J)),Promise.resolve())}return Qr}function u0(t,e){const i=[],r=[],s=[],a=Math.max(e.matched.length,t.matched.length);for(let o=0;o<a;o++){const l=e.matched[o];l&&(t.matched.find(u=>Ks(u,l))?r.push(l):i.push(l));const h=t.matched[o];h&&(e.matched.find(u=>Ks(u,h))||s.push(h))}return[i,r,s]}const c0=a_("basic",{state:()=>({userId:"1234"}),getters:{},actions:{serId(t){this.userId=t}}});var d0=Object.defineProperty,f0=(t,e,i)=>e in t?d0(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,n=(t,e,i)=>(f0(t,typeof e!="symbol"?e+"":e,i),i),w,Wo;let Y=(w=class{constructor(t=1,e=1,i=1,r=1){n(this,"r",0),n(this,"g",0),n(this,"b",0),n(this,"a",0),this.setTo(t,e,i,r)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}hexToRGB(t){return this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}hexToRGBA(t){return this.a=(t>>24&255)/255,this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}static random(t=1){let e=new w;return e.a=t,e.r=t*Math.random(),e.g=t*Math.random(),e.b=t*Math.random(),e}setTo(t,e,i,r){this.r=Math.max(t,0),this.g=Math.max(e,0),this.b=Math.max(i,0),this.a=Math.max(r,0)}setHex(t){if(typeof t!="string"||w.NON_HEX_CHARS.test(t)||!w.VALID_HEX_SIZE.test(t))throw new TypeError("Expected a valid hex string");t=t.replace(/^#/,"");let e=1;t.length===8&&(e=Number.parseInt(t.slice(6,8),16)/255,t=t.slice(0,6)),t.length===4&&(e=Number.parseInt(t.slice(3,4).repeat(2),16)/255,t=t.slice(0,3)),t.length===3&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);const i=Number.parseInt(t,16),r=i>>16,s=i>>8&255,a=i&255,o=e;this.a=o,this.r=r/255,this.g=s/255,this.b=a/255}getHex(){let t=e=>{e*=255;let i=e.toString(16);return i.length===1&&(i="0"+i),i};return t(this.r)+t(this.g)+t(this.b)+t(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,t[3]/255)}clone(){return new w().copyFrom(this)}copyFrom(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}copyFromArray(t,e=255){return this.r=t[0]/e,this.g=t[1]/e,this.b=t[2]/e,this.a=t[3]/e,this}copyFromVector(t){return this.r=t.x,this.g=t.y,this.b=t.z,this.a=t.w,this}static hexRGBColor(t,e=null){return e=e||new w,e.hexToRGB(t),e}static lerp(t,e,i,r){let s=r||new w;return s.r=(i.r-e.r)*t+e.r,s.g=(i.g-e.g)*t+e.g,s.b=(i.b-e.b)*t+e.b,s.a=(i.a-e.a)*t+e.a,r}},n(w,"COLOR_RED",new w(1,0,0,1)),n(w,"COLOR_GREEN",new w(0,1,0,1)),n(w,"COLOR_BLUE",new w(0,0,1,1)),n(w,"COLOR_WHITE",new w(1,1,1,1)),n(w,"COLOR_0",new w),n(w,"COLOR_1",new w),n(w,"COLOR_2",new w),n(w,"HEX_CHARACTERS","a-f\\d"),n(w,"MATCH_3OR4_HEX",`#?[${w.HEX_CHARACTERS}]{3}[${w.HEX_CHARACTERS}]?`),n(w,"MATCH_6OR8_HEX",`#?[${w.HEX_CHARACTERS}]{6}([${w.HEX_CHARACTERS}]{2})?`),n(w,"NON_HEX_CHARS",new RegExp(`[^#${w.HEX_CHARACTERS}]`,"gi")),n(w,"VALID_HEX_SIZE",new RegExp(`^${w.MATCH_3OR4_HEX}$|^${w.MATCH_6OR8_HEX}$`,"i")),n(w,"PRIMARY",4149685),n(w,"PRIMARYDARK",3162015),n(w,"ACCENT",16728193),n(w,"WHITE",16777215),n(w,"IVORY",16777200),n(w,"LIGHTYELLOW",16777184),n(w,"YELLOW",16776960),n(w,"SNOW",16775930),n(w,"FLORALWHITE",16775920),n(w,"LEMONCHIFFON",16775885),n(w,"CORNSILK",16775388),n(w,"SEASHELL",16774638),n(w,"LAVENDERBLUSH",16773365),n(w,"PAPAYAWHIP",16773077),n(w,"BLANCHEDALMOND",16772045),n(w,"MISTYROSE",16770273),n(w,"BISQUE",16770244),n(w,"MOCCASIN",16770229),n(w,"NAVAJOWHITE",16768685),n(w,"PEACHPUFF",16767673),n(w,"GOLD",16766720),n(w,"PINK",16761035),n(w,"LIGHTPINK",16758465),n(w,"ORANGE",16753920),n(w,"LIGHTSALMON",16752762),n(w,"DARKORANGE",16747520),n(w,"CORAL",16744272),n(w,"HOTPINK",16738740),n(w,"TOMATO",16737095),n(w,"ORANGERED",16729344),n(w,"DEEPPINK",16716947),n(w,"FUCHSIA",16711935),n(w,"MAGENTA",16711935),n(w,"RED",16711680),n(w,"OLDLACE",16643558),n(w,"LIGHTGOLDENRODYELLOW",16448210),n(w,"LINEN",16445670),n(w,"ANTIQUEWHITE",16444375),n(w,"SALMON",16416882),n(w,"GHOSTWHITE",16316671),n(w,"MINTCREAM",16121850),n(w,"WHITESMOKE",16119285),n(w,"BEIGE",16119260),n(w,"WHEAT",16113331),n(w,"SANDYBROWN",16032864),n(w,"AZURE",15794175),n(w,"HONEYDEW",15794160),n(w,"ALICEBLUE",15792383),n(w,"KHAKI",15787660),n(w,"LIGHTCORAL",15761536),n(w,"PALEGOLDENROD",15657130),n(w,"VIOLET",15631086),n(w,"DARKSALMON",15308410),n(w,"LAVENDER",15132410),n(w,"LIGHTCYAN",14745599),n(w,"BURLYWOOD",14596231),n(w,"PLUM",14524637),n(w,"GAINSBORO",14474460),n(w,"CRIMSON",14423100),n(w,"PALEVIOLETRED",14381203),n(w,"GOLDENROD",14329120),n(w,"ORCHID",14315734),n(w,"THISTLE",14204888),n(w,"LIGHTGREY",13882323),n(w,"TAN",13808780),n(w,"CHOCOLATE",13789470),n(w,"PERU",13468991),n(w,"INDIANRED",13458524),n(w,"MEDIUMVIOLETRED",13047173),n(w,"SILVER",12632256),n(w,"DARKKHAKI",12433259),n(w,"ROSYBROWN",12357519),n(w,"MEDIUMORCHID",12211667),n(w,"DARKGOLDENROD",12092939),n(w,"FIREBRICK",11674146),n(w,"POWDERBLUE",11591910),n(w,"LIGHTSTEELBLUE",11584734),n(w,"PALETURQUOISE",11529966),n(w,"GREENYELLOW",11403055),n(w,"LIGHTBLUE",11393254),n(w,"DARKGRAY",11119017),n(w,"BROWN",10824234),n(w,"SIENNA",10506797),n(w,"DARKORCHID",10040012),n(w,"PALEGREEN",10025880),n(w,"DARKVIOLET",9699539),n(w,"MEDIUMPURPLE",9662683),n(w,"LIGHTGREEN",9498256),n(w,"DARKSEAGREEN",9419919),n(w,"SADDLEBROWN",9127187),n(w,"DARKMAGENTA",9109643),n(w,"DARKRED",9109504),n(w,"BLUEVIOLET",9055202),n(w,"LIGHTSKYBLUE",8900346),n(w,"SKYBLUE",8900331),n(w,"GRAY",8421504),n(w,"OLIVE",8421376),n(w,"PURPLE",8388736),n(w,"MAROON",8388608),n(w,"AQUAMARINE",8388564),n(w,"CHARTREUSE",8388352),n(w,"LAWNGREEN",8190976),n(w,"MEDIUMSLATEBLUE",8087790),n(w,"LIGHTSLATEGRAY",7833753),n(w,"SLATEGRAY",7372944),n(w,"OLIVEDRAB",7048739),n(w,"SLATEBLUE",6970061),n(w,"DIMGRAY",6908265),n(w,"MEDIUMAQUAMARINE",6737322),n(w,"CORNFLOWERBLUE",6591981),n(w,"CADETBLUE",6266528),n(w,"DARKOLIVEGREEN",5597999),n(w,"INDIGO",4915330),n(w,"MEDIUMTURQUOISE",4772300),n(w,"DARKSLATEBLUE",4734347),n(w,"STEELBLUE",4620980),n(w,"ROYALBLUE",4286945),n(w,"TURQUOISE",4251856),n(w,"MEDIUMSEAGREEN",3978097),n(w,"LIMEGREEN",3329330),n(w,"DARKSLATEGRAY",3100495),n(w,"SEAGREEN",3050327),n(w,"FORESTGREEN",2263842),n(w,"LIGHTSEAGREEN",2142890),n(w,"DODGERBLUE",2003199),n(w,"MIDNIGHTBLUE",1644912),n(w,"AQUA",65535),n(w,"CYAN",65535),n(w,"SPRINGGREEN",65407),n(w,"LIME",65280),n(w,"MEDIUMSPRINGGREEN",64154),n(w,"DARKTURQUOISE",52945),n(w,"DEEPSKYBLUE",49151),n(w,"DARKCYAN",35723),n(w,"TEAL",32896),n(w,"GREEN",32768),n(w,"DARKGREEN",25600),n(w,"BLUE",255),n(w,"MEDIUMBLUE",205),n(w,"DARKBLUE",139),n(w,"NAVY",128),n(w,"BLACK",0),w);class He{static start(e){this._startTime=performance.now(),this._timeLabel=e}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}n(He,"time",0),n(He,"frame",0),n(He,"delta",0),n(He,"_startTime",0),n(He,"_timeLabel","");class Tt{constructor(e=null,i=null){n(this,"target"),n(this,"currentTarget"),n(this,"type"),n(this,"data"),n(this,"param"),n(this,"time",0),n(this,"delay",0),n(this,"mouseCode",0),n(this,"ctrlKey"),n(this,"altKey"),n(this,"shiftKey"),n(this,"targetTouches"),n(this,"changedTouches"),n(this,"touches"),n(this,"_stopImmediatePropagation",!1),n(this,"view"),this.type=e,this.data=i}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Jn{constructor(e=null,i=null,r=null,s=null,a=0){n(this,"id",0),n(this,"current"),this.type=e,this.thisObject=i,this.handler=r,this.param=s,this.priority=a}equalCurrentListener(e,i,r,s){return this.type==e&&this.thisObject==r&&this.handler==i&&this.param==s}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}n(Jn,"event_id_count",0);class Ur{constructor(){n(this,"listeners",{}),n(this,"data")}dispatchEvent(e){var i=this.listeners[e.type];if(i!=null){i=i.slice();for(var r=0;r<i.length;r++){var s=i[r];if(s.handler){try{e.param=s.param,e.currentTarget=s,s.thisObject,s.handler.call(s.thisObject,e)}catch{}if(e.isStopImmediatePropagation)break}}}}destroy(){for(var e in this.listeners)for(var i=this.listeners[e];i.length>0;){var r=i[0];r.handler=null,r.thisObject=null,i.splice(0,1)}}addEventListener(e,i,r,s=null,a=0){if(this.listeners[e]==null&&(this.listeners[e]=[]),!this.hasEventListener(e,i,r)){var o=new Jn(e,r,i,s,a);return o.id=++Jn.event_id_count,o.current=this,this.listeners[e].push(o),this.listeners[e].sort(function(l,h){return h.priority-l.priority}),o.id}for(let l=0;l<this.listeners[e].length;l++){let h=this.listeners[e][l];if(h.equalCurrentListener(e,i,r,s))return h.id}return 0}removeEventListener(e,i,r){if(this.hasEventListener(e,i,r))for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,i,r,a.param)){a.handler=null,a.thisObject=null,this.listeners[e].splice(s,1);return}}}removeEventListenerAt(e){for(var i in this.listeners)for(var r=0;r<this.listeners[i].length;r++){var s=this.listeners[i][r];if(s.id==e)return s.handler=null,s.thisObject=null,this.listeners[i].splice(r,1),!0}return!1}removeAllEventListener(e=null){let i;if(e){if(this.listeners[e]){for(var r=0;r<this.listeners[e].length;r++)i=this.listeners[e][r],i.dispose(),this.listeners[e].splice(r,1);delete this.listeners[e]}}else for(let s in this.listeners){for(var r=0;r<this.listeners[s].length;r++)i=this.listeners[s][r],i.dispose(),this.listeners[s].splice(r,1);delete this.listeners[s]}}containEventListener(e){return this.listeners[e]==null?!1:this.listeners[e].length>0}hasEventListener(e,i=null,r=null){if(this.listeners[e]==null)return!1;if(r&&i)for(var s=0;s<this.listeners[e].length;s++){var a=this.listeners[e][s];if(a.equalCurrentListener(e,i,r,a.param))return!0}return!1}}class Fa extends Tt{constructor(){super(...arguments),n(this,"keyCode",0)}}n(Fa,"KEY_DOWN","onKeyDown"),n(Fa,"KEY_UP","onKeyUp");class j extends Tt{constructor(){super(...arguments),n(this,"pointerId"),n(this,"pointerType"),n(this,"isPrimary"),n(this,"pressure"),n(this,"mouseX"),n(this,"mouseY"),n(this,"movementX"),n(this,"movementY"),n(this,"deltaX"),n(this,"deltaY"),n(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}n(j,"PICK_OVER","onPickOver"),n(j,"PICK_OVER_GUI","onPickOverGUI"),n(j,"PICK_CLICK","onPickClick"),n(j,"PICK_CLICK_GUI","onPickClickGUI"),n(j,"PICK_OUT","onPickOut"),n(j,"PICK_OUT_GUI","onPickOutGUI"),n(j,"PICK_MOVE","onPickMove"),n(j,"PICK_UP","onPickUp"),n(j,"PICK_UP_GUI","onPickUpGUI"),n(j,"PICK_DOWN","onPickDown"),n(j,"PICK_DOWN_GUI","onPickDownGUI"),n(j,"POINTER_RIGHT_CLICK","onPointerRightClick"),n(j,"POINTER_MID_UP","onPointerMidUp"),n(j,"POINTER_MID_DOWN","onPointerMidDown"),n(j,"POINTER_CLICK","onPointerClick"),n(j,"POINTER_MOVE","onPointerMove"),n(j,"POINTER_DOWN","onPointerDown"),n(j,"POINTER_UP","onPointerUp"),n(j,"POINTER_OUT","onPointerOut"),n(j,"POINTER_OVER","onPointerOver"),n(j,"POINTER_WHEEL","onPointerWheel");const K=class{constructor(t=0,e=0,i=0,r=0){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),n(this,"index",0),this.set(t,e,i,r),this.index=K._index++}static get ZERO(){return new K(0,0,0)}static get ONE(){return new K(1,1,1)}static get LEFT(){return new K(-1,0,0)}static get RIGHT(){return new K(1,0,0)}static get UP(){return new K(0,1,0)}static get DOWN(){return new K(0,-1,0)}static get BACK(){return new K(0,0,-1)}static get FORWARD(){return new K(0,0,1)}set a(t){this.w=t}set r(t){this.x=t}set g(t){this.y=t}set b(t){this.z=t}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(t,e,i,r,s){s==K.Z_AXIS?(e.x=t.y,e.y=-t.x,i.x=-t.y,i.y=t.x,e.scaleBy(r*.5),i.scaleBy(r*.5)):s==K.Y_AXIS&&(e.x=t.z,e.z=-t.x,i.x=-t.z,i.z=t.x,e.scaleBy(r*.5),i.scaleBy(r*.5))}static pointToLine(t,e,i){let r=0,s,a,o;if(s=K.distance(t,e),a=K.distance(t,i),o=K.distance(e,i),o<=1e-6||a<=1e-6)return r=0,r;if(s<=1e-6||o*o>=s*s+a*a)return r=a,r;if(a*a>=s*s+o*o)return r=o,r;let l=(s+a+o)/2;return r=2*Math.sqrt(l*(l-s)*(l-a)*(l-o))/s,r}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static getPoints(t,e){let i=[];for(let r=0;r<t;r++){const s=new K(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);i.push(s)}return i}static getPointNumbers(t,e){let i=[];for(let r=0;r<t;r++)i.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return i}static getAngle(t,e){let i=t.dotProduct(e)/(t.length*e.length);return Math.acos(i)*180/Math.PI}static sqrMagnitude(t){return t.x*t.x+t.y*t.y+t.z*t.z}static getZYAngle(t,e){return this.calAngle(t.y,t.z,e.y,e.z)}static sub(t,e,i=null){return i=i||new K,i.x=t.x-e.x,i.y=t.y-e.y,i.z=t.z-e.z,i}static add(t,e,i=null){return i=i||new K,i.x=t.x+e.x,i.y=t.y+e.y,i.z=t.z+e.z,i}static smoothDamp(t,e,i,r,s,a){return null}static distance(t,e){var i=t.x-e.x,r=t.y-e.y,s=t.z-e.z;return Math.sqrt(i*i+r*r+s*s)}static squareDistance(t,e){var i=t.x-e.x,r=t.y-e.y,s=t.z-e.z;return i*i+r*r+s*s}static distanceXZ(t,e){var i=t.x-e.x,r=0,s=t.z-e.z;return Math.sqrt(i*i+r*r+s*s)}set(t,e,i,r=1){return this.x=t,this.y=e,this.z=i,this.w=r,this}add(t,e=null){e||(e=new K);var i=this.x,r=this.y,s=this.z,a=this.w,o=t.x,l=t.y,h=t.z,u=t.w;return e.setTo(i+o,r+l,s+h,a+u),e}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}distanceToSquared(t){let e=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return e*e+i*i+r*r}addXYZW(t,e,i,r,s=null){s||(s=new K);var a=this.x,o=this.y,l=this.z,h=this.w,u=t,c=e,d=i,f=r;return s.setTo(a+u,o+c,l+d,h+f),s}clone(){return new K(this.x,this.y,this.z,this.w)}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}decrementBy(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}equals(t,e=!1){return this.x==t.x&&this.y==t.y&&this.z==t.z&&(!e||this.w==t.w)}incrementBy(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}divide(t){return t instanceof K?new K(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(t=1){let e=this;if(this.length!=0){var i=t/this.length;return this.x*=i,this.y*=i,this.z*=i,e}return e}applyQuaternion(t){const e=this.x,i=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,h=l*e+a*r-o*i,u=l*i+o*e-s*r,c=l*r+s*i-a*e,d=-s*e-a*i-o*r;return this.x=h*l+d*-s+u*-o-c*-a,this.y=u*l+d*-a+c*-s-h*-o,this.z=c*l+d*-o+h*-a-u*-s,this}scaleBy(t){return this.x*=t,this.y*=t,this.z*=t,this}mul(t){let e=new K;return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scale(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}scaleToRef(t,e){return e||(e=new K),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}setTo(t,e,i,r=1){this.x=t,this.y=e,this.z=i,this.w=r}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}subtract(t,e=null){return e||(e=new K),e.setTo(this.x-t.x,this.y-t.y,this.z-t.z),e}multiply(t,e=null){e||(e=new K);var i=this.x,r=this.y,s=this.z,a=t.x,o=t.y,l=t.z;return e.setTo(i*a,r*o,s*l),e}divided(t,e=null){e||(e=new K);var i=this.x,r=this.y,s=this.z,a=t.x,o=t.y,l=t.z;return e.setTo(i/a,r/o,s/l),e}div(t,e){e||(e=new K);var i=this.x,r=this.y,s=this.z,a=this.w;return e.setTo(i/t,r/t,s/t,a/t),e}lerp(t,e,i){var r=t.x,s=t.y,a=t.z,o=t.w,l=e.x,h=e.y,u=e.z,c=e.w;this.x=(l-r)*i+r,this.y=(h-s)*i+s,this.z=(u-a)*i+a,this.w=(c-o)*i+o}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let t=Math.abs(this.x),e=Math.abs(this.y);t>e?this.x>0?this.copyFrom(K.RIGHT):this.copyFrom(K.LEFT):this.y>0?this.copyFrom(K.DOWN):this.copyFrom(K.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(t){t.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),t.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),t.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(t,e=null){return e=e||new K,e.x=this.y*t.z-this.z*t.y,e.y=this.z*t.x-this.x*t.z,e.z=this.x*t.y-this.y*t.x,e.w=1,e}crossVectors(t,e){return t.crossProduct(e,this),this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}setFromArray(t,e=0){this.x=t[e],this.y=t[e+1],this.z=t[e+2]}divideScalar(t){return this.multiplyScalar(1/t)}clampLength(t,e){let i=this.length;return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}setScalar(t){return this.x=t,this.y=t,this.z=t,this}static calAngle(t,e,i,r){const s=o(i,r,t,e);let a=Math.acos(s)*180/Math.PI;return i<t&&(a=-a),a;function o(h,u,c,d){let f=[h-c,u-d];return l(f,[0,-1])}function l(h,u){let c=h[0]*u[0]+h[1]*u[1],d=Math.sqrt(h[0]*h[0]+h[1]*h[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return c/d}}static pointInsideTriangle(t,e,i,r){return K.HELP_0.setTo(t.x,t.z,0),K.HELP_1.setTo(e.x,e.z,0),K.HELP_2.setTo(i.x,i.z,0),K.HELP_3.setTo(r.x,r.z,0),K.pointInsideTriangle2d()}static pointInsideTriangle2d(){return K.productXY(K.HELP_1,K.HELP_2,K.HELP_3)>=0?K.productXY(K.HELP_1,K.HELP_2,K.HELP_0)>=0&&K.productXY(K.HELP_2,K.HELP_3,K.HELP_0)>=0&&K.productXY(K.HELP_3,K.HELP_1,K.HELP_0)>=0:K.productXY(K.HELP_1,K.HELP_2,K.HELP_0)<=0&&K.productXY(K.HELP_2,K.HELP_3,K.HELP_0)<=0&&K.productXY(K.HELP_3,K.HELP_1,K.HELP_0)<=0}static productXY(t,e,i){var r=(t.x-i.x)*(e.y-i.y)-(t.y-i.y)*(e.x-i.x);return r>-1e-5&&r<1e-5&&(r=0),r}static serialize(t){return new K(t.x,t.y,t.z,t.w)}};let p=K;n(p,"MAX",new K(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),n(p,"MIN",new K(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),n(p,"SAFE_MAX",new K(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),n(p,"SAFE_MIN",new K(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),n(p,"X_AXIS",new K(1,0,0)),n(p,"neg_X_AXIS",new K(-1,0,0)),n(p,"Y_AXIS",new K(0,1,0)),n(p,"Z_AXIS",new K(0,0,1)),n(p,"HELP_0",new K),n(p,"HELP_1",new K),n(p,"HELP_2",new K),n(p,"EPSILON",1e-5),n(p,"HELP_3",new K),n(p,"HELP_4",new K),n(p,"HELP_5",new K),n(p,"HELP_6",new K),n(p,"_index",0);class g0{constructor(e){n(this,"canvasX"),n(this,"canvasY"),n(this,"identifier"),n(this,"clientX"),n(this,"clientY"),n(this,"pageX"),n(this,"pageY"),n(this,"screenX"),n(this,"screenY"),this.canvasX=e.clientX,this.canvasY=e.clientY,this.identifier=e.identifier,this.clientX=e.clientX,this.clientY=e.clientY,this.pageX=e.pageX,this.pageY=e.pageY,this.screenX=e.screenX,this.screenY=e.screenY}}class p0 extends Ur{constructor(){super(...arguments),n(this,"canvasX",0),n(this,"canvasY",0),n(this,"isMouseDown",!1),n(this,"isRightMouseDown",!1),n(this,"canvas"),n(this,"mouseX",0),n(this,"mouseY",0),n(this,"wheelDelta",0),n(this,"mouseOffsetX",0),n(this,"mouseOffsetY",0),n(this,"mouseLastX",0),n(this,"mouseLastY",0),n(this,"_time",0),n(this,"_keyStatus"),n(this,"_mouseStatus"),n(this,"_isTouchStart"),n(this,"_keyEvent3d"),n(this,"_pointerEvent3D"),n(this,"_windowsEvent3d"),n(this,"_gp",!1),n(this,"_oldPosition1",null),n(this,"_oldPosition2",null),n(this,"_downTime",0)}initCanvas(e){this.canvas=e,e.onpointerdown=r=>{r.button==0?this.mouseStart(r):r.button==1?this.middleDown(r):r.button==2&&this.mouseStart(r)},e.onpointerup=r=>{r.button==0?this.mouseEnd(r):r.button==1?this.middleUp(r):r.button==2&&this.mouseEnd(r)},e.onpointerenter=r=>{this.mouseOver(r)},e.onpointermove=r=>{this.mouseMove(r)},e.onpointercancel=r=>{this.mouseEnd(r)},e.onpointerleave=r=>{this.mouseEnd(r)},e.onpointerout=r=>{this.mouseEnd(r)},e.addEventListener("click",r=>{r.button==2?(this.isRightMouseDown=!1,this.rightClick(r)):r.button==0&&(this.isMouseDown=!1,this.mouseClick(r))},!0),e.addEventListener("wheel",r=>this.mouseWheel(r),{passive:!1}),window.addEventListener("keydown",r=>this.keyDown(r),!0),window.addEventListener("keyup",r=>this.keyUp(r),!0),e.oncontextmenu=function(){return!1};let i=this.canvas.getBoundingClientRect();this.canvasX=i.left,this.canvasY=i.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new Fa,this._pointerEvent3D=new j,this._windowsEvent3d=new Tt}onPinch(e,i,r,s){this._oldPosition1=new p(e,i),this._oldPosition2=new p(r,s)}onSwipe(e,i){this.mouseX=e,this.mouseY=i,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var i=new Array,r=0;r<e.length;r++){var s=new g0(e[r]);i.push(s)}return i}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=j.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}middleDown(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=j.POINTER_MID_DOWN,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}middleUp(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=j.POINTER_MID_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=j.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=j.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=j.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=j.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=j.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=j.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=Fa.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=Fa.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,i){return Math.atan2(i,e)*180/Math.PI}GetSlideDirection(e,i,r,s){var a=i-s,o=r-e,l=0;if(Math.abs(o)<2&&Math.abs(a)<2)return l;var h=this.GetSlideAngle(o,a);return h>=-45&&h<45?l=4:h>=45&&h<135?l=1:h>=-135&&h<-45?l=2:(h>=135&&h<=180||h>=-180&&h<-135)&&(l=3),l}}const m0="0.7.1";let ci={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},zi={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},zt={none:"none",front:"front",back:"back"},ar={nearest:"nearest",linear:"linear"},Uh={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},le={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},pn={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"};class ds extends Tt{}n(ds,"RESIZE","resize");class A0 extends Ur{constructor(){super(...arguments),n(this,"adapter"),n(this,"device"),n(this,"context"),n(this,"aspect"),n(this,"presentationSize",[0,0]),n(this,"presentationFormat"),n(this,"canvas"),n(this,"windowWidth"),n(this,"windowHeight"),n(this,"canvasConfig"),n(this,"super",1),n(this,"_pixelRatio",1),n(this,"_resizeEvent")}get pixelRatio(){return this._pixelRatio}async init(e){var i;if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");const r=this.canvas.clientWidth,s=this.canvas.clientHeight;r!=this.canvas.clientWidth&&(this.canvas.style.width=r+"px"),s!=this.canvas.clientHeight&&(this.canvas.style.height=s+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e!=null&&e.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");return this._pixelRatio=((i=this.canvasConfig)==null?void 0:i.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2),this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"srgb"}),this._resizeEvent=new ds(ds.RESIZE,{width:this.windowWidth,height:this.windowHeight}),new ResizeObserver(()=>{this.updateSize(),Lt.destroyTexture()}).observe(this.canvas),this.updateSize(),!0}updateSize(){let e=Math.floor(this.canvas.clientWidth*this.pixelRatio*this.super),i=Math.floor(this.canvas.clientHeight*this.pixelRatio*this.super);(e!=this.windowWidth||i!=this.windowHeight)&&(this.canvas.width=this.windowWidth=e,this.canvas.height=this.windowHeight=i,this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight,this._resizeEvent.data.width=this.windowWidth,this._resizeEvent.data.height=this.windowHeight,this.dispatchEvent(this._resizeEvent))}}let D=new A0;class ht{}n(ht,"colorBufferTex_NAME","colorBufferTex"),n(ht,"positionBufferTex_NAME","positionBufferTex"),n(ht,"normalBufferTex_NAME","normalBufferTex"),n(ht,"materialBufferTex_NAME","materialBufferTex"),n(ht,"zBufferTexture_NAME","zBufferTexture"),n(ht,"zPreDepthTexture_NAME","zPreDepthTexture"),n(ht,"outTex_NAME","outTex");var vt=(t=>(t[t.Default=1]="Default",t[t.IgnoreDepthPass=2]="IgnoreDepthPass",t[t.Sky=6]="Sky",t[t.Particle=10]="Particle",t[t.SkinnedMesh=16]="SkinnedMesh",t[t.MorphTarget=32]="MorphTarget",t[t.Terrain=64]="Terrain",t[t.UI=128]="UI",t))(vt||{});class Zi{static addMask(e,i){return e|i}static removeMask(e,i){return e&~i}static hasMask(e,i){return(e&i)==i}}function Bl(t,e){let i=t.__NonSerialize__;i||(i=t.__NonSerialize__={},i.__NonSerialize__=!0),i[e]=!0}function oc(t,e){let i;for(;t&&(t=t.__proto__,t&&(i=t.__NonSerialize__),!i););return i&&i[e]}function er(t,e,i,r,s){let a=t.__EditorInspector__;a||(a=t.__EditorInspector__=new Map);let o=a.get(t.constructor.name);o||(o=new Map,a.set(t.constructor.name,o)),o.set(e,{p1:i,p2:r,p3:s})}function Ci(t,e,i,r,s){let a=window.__Component__;a||(a=window.__Component__={}),a[e]=t}function _0(t){let e=window.__Component__;return e[t]?e[t]:null}function Lr(t,e,i,r,s){let a=window.__shader__;a||(a=window.__shader__={}),a[e]=t}function v0(t){let e=window.__shader__;return e[t]?e[t]:null}var x0=Object.defineProperty,y0=Object.getOwnPropertyDescriptor,lc=(t,e,i,r)=>{for(var s=r>1?void 0:r?y0(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&x0(e,i,s),s};const Aa=(Wo=class{constructor(){n(this,"__refection"),n(this,"__size",0)}getValueType(){if(!this.__refection){let t=this;this.__refection=[];for(const e in t)if(!oc(this,e)){const i=t[e];let r={name:e,type:i.constructor.name};this.__refection.push(r)}}return this.__refection}static getValueSize(t){switch(t.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return t.byteLength;case"Vector2":return 2*4;case"Vector3":return 3*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let e=0;for(let i=0,r=t.length;i<r;i++)e+=Aa.getValueSize(t[i]);return e}return 0}static Ref(t){return this.Get(t).getValueType()}static Get(t){let e=Aa.__cacheStruct.get(t.prototype);return e||(e=new t,Aa.__cacheStruct.set(t.prototype,e)),e}static GetSize(t){let e=this.Get(t);if(e.__size==0){for(const i in e)if(!oc(e,i)){const r=e[i];e.__size+=Aa.getValueSize(r)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}},n(Wo,"__cacheStruct",new Map),Wo);let nr=Aa;lc([Bl],nr.prototype,"__refection",2),lc([Bl],nr.prototype,"__size",2);class C0{constructor(){n(this,"byteOffset"),n(this,"byteSize"),n(this,"offset",0),n(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(e){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,e,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(e){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,e,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(e){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,e,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(e){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,e,!0)}setX(e){this.x=e}setXY(e,i){this.x=e,this.y=i}setXYZ(e,i,r){this.x=e,this.y=i,this.z=r}setXYZW(e,i,r,s){this.x=e,this.y=i,this.z=r,this.w=s}setVector2Array(e){for(let i=0;i<e.length;i++){const r=e[i];this.dataBytes.setFloat32((i*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((i*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(e){for(let i=0;i<e.length;i++){const r=e[i];this.dataBytes.setFloat32((i*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((i*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((i*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(e){for(let i=0;i<e.length;i++){const r=e[i];this.dataBytes.setFloat32((i*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((i*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((i*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((i*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(e){for(let i=0;i<e.length;i++){const r=e[i];this.dataBytes.setFloat32((i*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((i*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((i*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((i*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(e,i=0){this.dataBytes.setInt8(i*Int8Array.BYTES_PER_ELEMENT,e)}getInt8(e=0){return this.dataBytes.getInt8(e*Int8Array.BYTES_PER_ELEMENT)}setInt16(e,i=0){this.dataBytes.setInt16(i*Int16Array.BYTES_PER_ELEMENT,e,!0)}getInt16(e=0){return this.dataBytes.getInt16(e*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(e,i=0){this.dataBytes.setInt32(i*Int32Array.BYTES_PER_ELEMENT,e,!0)}getInt32(e=0){return this.dataBytes.getInt32(e*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(e,i=0){this.dataBytes.setFloat32(i*Float32Array.BYTES_PER_ELEMENT,e,!0)}getFloat(e=0){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(e,i=0){this.dataBytes.setUint8(i*Uint8Array.BYTES_PER_ELEMENT,e)}getUint8(e=0){return this.dataBytes.getUint8(e*Uint8Array.BYTES_PER_ELEMENT)}setUint16(e,i=0){this.dataBytes.setUint16(i*Uint16Array.BYTES_PER_ELEMENT,e,!0)}getUint16(e=0){return this.dataBytes.getUint16(e*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(e,i=0){this.dataBytes.setUint32(i*Uint32Array.BYTES_PER_ELEMENT,e,!0)}getUint32(e=0){return this.dataBytes.getUint32(e*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(e,i){for(let r=0;r<i.length;r++){const s=i[r];this.dataBytes.setFloat32((e+r)*Float32Array.BYTES_PER_ELEMENT,s,!0)}}setFloat32Array(e,i){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Float32Array.BYTES_PER_ELEMENT,i.length).set(i)}setArrayBuffer(e,i){i instanceof Uint8Array?this.setUint8Array(e,i):i instanceof Uint16Array?this.setUint16Array(e,i):i instanceof Uint32Array?this.setUint32Array(e,i):i instanceof Int8Array?this.setInt8Array(e,i):i instanceof Int16Array?this.setInt16Array(e,i):i instanceof Int32Array?this.setInt32Array(e,i):i instanceof Float32Array&&this.setFloat32Array(e,i)}setInt8Array(e,i){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int8Array.BYTES_PER_ELEMENT).set(i)}setInt16Array(e,i){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int16Array.BYTES_PER_ELEMENT).set(i)}setInt32Array(e,i){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int32Array.BYTES_PER_ELEMENT).set(i)}setUint8Array(e,i){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint8Array.BYTES_PER_ELEMENT).set(i)}setUint16Array(e,i){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint16Array.BYTES_PER_ELEMENT).set(i)}setUint32Array(e,i){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint32Array.BYTES_PER_ELEMENT).set(i)}setData(e,i){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,i,!0)}setVector2(e,i){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,i.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,i.y,!0)}setVector3(e,i){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,i.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,i.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,i.z,!0)}setVector4(e,i){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,i.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,i.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,i.z,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,i.w,!0)}setColor(e,i){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,i.r,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,i.g,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,i.b,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,i.a,!0)}getData(e){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(e){this.dataBytes.setFloat32(this.offset,e,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(e){this.dataBytes.setInt8(this.offset,e),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(e){this.dataBytes.setInt16(this.offset,e,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(e){this.dataBytes.setInt32(this.offset,e,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(e){this.dataBytes.setUint8(this.offset,e),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(e){this.dataBytes.setUint16(this.offset,e,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(e){this.dataBytes.setUint32(this.offset,e,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(e){this.writeFloat(e.x),this.writeFloat(e.y)}writeVector3(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z)}writeVector4(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z),this.writeFloat(e.w)}writeRGBColor(e){this.writeFloat(e.r),this.writeFloat(e.g),this.writeFloat(e.b)}writeArray(e){for(let i=0;i<e.length;i++){const r=e[i];this.writeFloat(r)}}writeFloat32Array(e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt8Array(e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt16Array(e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt32Array(e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint8Array(e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint16Array(e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint32Array(e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class tn{constructor(){n(this,"shareDataBuffer"),n(this,"_byteOffset",0)}allocation(e){this.shareDataBuffer&&this.shareDataBuffer.byteLength<e?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(e)}allocation_node(e){if(this._byteOffset+e>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,e,this.shareDataBuffer.byteLength),null;let i=new C0;return i.byteOffset=this._byteOffset,i.byteSize=e,i.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,i.byteSize),this._byteOffset+=i.byteSize,i}allocation_memory(e){return this._byteOffset+e.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,e.byteSize,this.shareDataBuffer.byteLength),null):(e.byteOffset=this._byteOffset,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e)}reset(){this._byteOffset=0}destroy(e){this.shareDataBuffer=null,this._byteOffset=0}}class Or{constructor(){n(this,"bufferType"),n(this,"buffer"),n(this,"memory"),n(this,"memoryNodes"),n(this,"seek"),n(this,"outFloat32Array"),n(this,"byteSize"),n(this,"usage"),n(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),n(this,"mapAsyncBuffersOutstanding",0),n(this,"mapAsyncReady"),n(this,"_readBuffer"),n(this,"_dataView"),n(this,"_readFlag",!1),this.mapAsyncReady=[]}debug(){}reset(e=!1,i=0,r){this.seek=0,this.memory.reset(),e&&this.createBuffer(this.usage,i,r)}setBoolean(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(i?1:0)}setFloat(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(i)}setInt8(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setInt8(i)}setInt16(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setInt16(i)}setInt32(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setInt32(i)}setUint8(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setUint8(i)}setUint16(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setUint16(i)}setUint32(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setUint32(i)}setVector2(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(e,r)),r.setXY(i.x,i.y)}setVector3(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(e,r)),r.setXYZ(i.x,i.y,i.z)}setVector4(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(i.x,i.y,i.z,i.w)}setVector4Array(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*i.length),this.memoryNodes.set(e,r)),r.setVector4Array(i)}setColor(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(i.r,i.g,i.b,i.a)}setColorArray(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*i.length),this.memoryNodes.set(e,r)),r.setColorArray(i)}setMatrix(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,i.rawData)}setMatrixArray(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4*i.length),this.memoryNodes.set(e,r));for(let s=0;s<i.length;s++){const a=i[s];r.setFloat32Array(s*16,a.rawData)}}setArray(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(i.length*4),this.memoryNodes.set(e,r)),r.setArray(0,i)}setFloat32Array(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(i.length*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,i)}setInt32Array(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(i.length*4),this.memoryNodes.set(e,r)),r.setInt32Array(0,i)}setUint32Array(e,i){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(i.length*4),this.memoryNodes.set(e,r)),r.setUint32Array(0,i)}setStruct(e,i,r,s){let a=nr.Ref(e);nr.GetSize(e);let o=i,l=this.memoryNodes.get(o);l.reset();let h=r;s&&(h=h[s]);for(let u=0;u<a.length;u++){const c=a[u];let d=h[c.name];this.writeValue(l,c,d)}}writeValue(e,i,r){switch(i.type){case"Boolean":e.writeFloat(r);break;case"Number":e.writeFloat(r);break;case"Float32Array":e.writeFloat32Array(r);break;case"Vector2":e.writeVector2(r);break;case"Vector3":e.writeVector3(r);break;case"Vector4":e.writeVector4(r);break;case"Color":e.writeRGBColor(r);break;case"Array":e.writeArray(r);break}}setStructArray(e,i,r){let s=i.length;for(let a=0;a<s;a++){const o=i[a];this.setStruct(e,a,o,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){D.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}mapAsyncWrite(e,i){let r=D.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,i);new Float32Array(s.getMappedRange(0,i*4)).set(a),s.unmap();const o=r.createCommandEncoder();o.copyBufferToBuffer(s,0,this.buffer,0,i*4),r.queue.submit([o.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}destroy(e){this.memoryNodes&&this.memoryNodes.forEach(i=>{i.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(e,i,r,s){let a=D.device;this.buffer&&this.destroy(),this.byteSize=i*4,this.usage=e,this.buffer=a.createBuffer({label:s,size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new tn,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}resizeBuffer(e,i){this.createBuffer(this.usage,e,i)}createNewBuffer(e,i){let r=D.device,s=i*4,a=e;return this.buffer&&this.destroy(),r.createBuffer({size:s,usage:a,mappedAtCreation:!1})}createBufferByStruct(e,i,r){let s=nr.GetSize(i),a=s*r,o=D.device;this.buffer=o.createBuffer({label:"StructStorageGPUBuffer",size:a,usage:e,mappedAtCreation:!1}),this.memory=new tn,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(a);for(let l=0;l<r;l++){let h=l,u=this.memoryNodes.get(h);u||(u=this.memory.allocation_node(s),this.memoryNodes.set(h,u))}}readBuffer(){return this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=D.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1})),this._readFlag||this.read(),this.outFloat32Array}async read(){this._readFlag=!0;let e=D.device.createCommandEncoder();e.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),D.device.queue.submit([e.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const i=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(i),0),this._readBuffer.unmap(),this._readFlag=!1}}var Hi=(t=>(t[t.IndicesGPUBuffer=0]="IndicesGPUBuffer",t[t.VertexGPUBuffer=1]="VertexGPUBuffer",t[t.UniformGPUBuffer=2]="UniformGPUBuffer",t[t.StorageGPUBuffer=3]="StorageGPUBuffer",t[t.ComputeGPUBuffer=4]="ComputeGPUBuffer",t[t.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",t[t.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",t))(Hi||{});class At extends Or{constructor(e,i=0,r){super(),this.bufferType=Hi.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|i,e,r,"StorageGPUBuffer")}}class an extends Or{constructor(e,i){super(),this.bufferType=Hi.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,e,i,"UniformGPUBuffer")}genUniformNodes(){}}class Ue{static getMorphTargetShaderBinding(e,i){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${i})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${i+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${i+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetAttr(e){return`@location(${e}) vIndex: f32,`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}n(Ue,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let bi=function(t=16,e=16){var i="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],s;if(e=e||i.length,t)for(s=0;s<t;s++)r[s]=i[0|Math.random()*e];else{var a;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",s=0;s<36;s++)r[s]||(a=0|Math.random()*16,r[s]=i[s==19?a&3|8:a])}return r.join("")},hc=1e6,If=function(){return hc++,hc},b0=(...t)=>function(...e){t.forEach(i=>i.apply(this,e))};const Ke=class{constructor(t=0,e=0){n(this,"x",0),n(this,"y",0),this.x=t,this.y=e}static getAngle(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static slerp(t,e,i){let r=new Ke,s=t.dot(e);if(s<0&&(e.x=-e.x,e.y=-e.y,s=-s),s>.9995)return r.x=t.x+i*(e.x-t.x),r.y=t.y+i*(e.y-t.y),r;let a=Math.acos(s),o=Math.sin(a),l=Math.sin((1-i)*a)/o,h=Math.sin(i*a)/o;return r.x=l*t.x+h*e.x,r.y=l*t.y+h*e.y,r}static lerp(t,e,i){return Ke.HELP_0.copyFrom(t),Ke.HELP_1.copyFrom(e),Ke.HELP_0.scale(i),Ke.HELP_1.scale(1-i),new Ke(Ke.HELP_0.x+Ke.HELP_1.x,Ke.HELP_0.y+Ke.HELP_1.y)}set(t=0,e=0){return this.x=t,this.y=e,this}distance(t){return Math.sqrt(Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2))}add(t,e){return e=e||new Ke,e.x=this.x+t.x,e.y=this.y+t.y,e}sub(t,e){return e=e||new Ke,e.x=this.x-t.x,e.y=this.y-t.y,e}scale(t){return this.x=this.x*t,this.y=this.y*t,this}multiply(t,e){return e=e||new Ke,e.x=this.x*t,e.y=this.y*t,e}multiplyScaler(t){return this.x*=t,this.y*=t,this}divide(t,e){return e=e||new Ke,e.x=this.x/t,e.y=this.y/t,e}neg(t){return t||(t=new Ke),t.x=-t.x,t.y=-t.y,t}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(t){return Math.atan2(t.y-this.y,t.x-this.x)}unt(t){t=t||new Ke;let e=this.abs();return t.x=this.x/e,t.y=this.y/e,t}angleTo(t){let e=t.x-this.x,i=t.y-this.y;return Math.atan2(i,e)}equals(t){return Math.abs(this.x-t.x)<1e-6&&Math.abs(this.y-t.y)<1e-6}pal(t){let e=this.unt(),i=t.unt();return e.equals(i)?1:e.equals(i.neg())?-1:0}clone(){return new Ke(this.x,this.y)}copyFrom(t){return this.x=t.x,this.y=t.y,this}dot(t){return this.x*t.x+this.y*t.y}normalize(){let t=this.abs();return this.x=this.x/t,this.y=this.y/t,this}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}};let Ne=Ke;n(Ne,"HELP_0",new Ke),n(Ne,"HELP_1",new Ke),n(Ne,"ZERO",new Ke(0,0)),n(Ne,"SAFE_MAX",new Ke(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),n(Ne,"SAFE_MIN",new Ke(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));const it=class{constructor(t=0,e=0,i=0,r=0){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),this.x=t,this.y=e,this.z=i,this.w=r}get width(){return this.z}get height(){return this.w}static crossVectors(t,e,i){i=i||new it;var r=t.x,s=t.y,a=t.z,o=e.x,l=e.y,h=e.z;return i.x=s*h-a*l,i.y=a*o-r*h,i.z=r*l-s*o,i}static distance(t,e){let i=t.x-e.x,r=t.y-e.y,s=t.z-e.z,a=t.w-e.w;return Math.sqrt(i*i+r*r+s*s+a*a)}set(t,e,i,r){return this.x=t,this.y=e,this.z=i,this.w=r,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}clone(){return new it(this.x,this.y,this.z,this.w)}};let oe=it;n(oe,"X_AXIS",new it(1,0,0)),n(oe,"Y_AXIS",new it(0,1,0)),n(oe,"Z_AXIS",new it(0,0,1)),n(oe,"HELP_0",new it),n(oe,"HELP_1",new it),n(oe,"HELP_2",new it),n(oe,"EPSILON",1e-5),n(oe,"HELP_3",new it),n(oe,"HELP_4",new it),n(oe,"HELP_5",new it),n(oe,"HELP_6",new it),n(oe,"ZERO",new it),n(oe,"ONE",new it(1,1,1,1)),n(oe,"LEFT",new it(-1,0,0)),n(oe,"RIGHT",new it(1,0,0)),n(oe,"UP",new it(0,-1,0)),n(oe,"DOWN",new it(0,1,0)),n(oe,"BACK",new it(0,0,-1)),n(oe,"FORWARD",new it(0,0,1));var Dt=(t=>(t[t.Number=0]="Number",t[t.Vector2=1]="Vector2",t[t.Vector3=2]="Vector3",t[t.Vector4=3]="Vector4",t[t.Color=4]="Color",t[t.Float32Array=5]="Float32Array",t))(Dt||{});class Vr{constructor(e){n(this,"size"),n(this,"memoryInfo"),n(this,"bindOnChange"),n(this,"_data"),n(this,"_type",Dt.Number),n(this,"_x",0),n(this,"_y",0),n(this,"_z",0),n(this,"_w",0),this.data=e}get data(){return this._data}set data(e){this._data=e,this._type=Dt.Number,e instanceof Ne?(this.size=2,this._x=e.x,this._y=e.y,this._type=Dt.Vector2):e instanceof p?(this.size=3,this._x=e.x,this._y=e.y,this._z=e.z,this._type=Dt.Vector3):e instanceof oe?(this.size=4,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._type=Dt.Vector4):e instanceof Y?(this.size=4,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this._type=Dt.Color):e instanceof Float32Array?(this.size=e.length,this._type=Dt.Float32Array):(this.size=1,this._x=e,this._data=e,this._type=Dt.Number)}getColor(e){return e?e.copyFrom(this._data):e=this._data,e}get color(){return new Y(this._data.r,this._data.g,this._data.b,this._data.a)}set color(e){(this._x!=e.r||this._y!=e.g||this._z!=e.b||this._w!=e.a)&&(this._data.r=e.r,this._data.g=e.g,this._data.b=e.b,this._data.a=e.a,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this.onChange())}get value(){return this._x}set value(e){this._x!=e&&(this._data=e,this._x=e,this.onChange())}get vector2(){return this._data}set vector2(e){(this._x!=e.x||this._y!=e.y)&&(this._data.x=e.x,this._data.y=e.y,this._x=e.x,this._y=e.y,this.onChange())}get vector3(){return this._data}set vector3(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._x=e.x,this._y=e.y,this._z=e.z,this.onChange())}get vector4(){return this._data}set vector4(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z||this._w!=e.w)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._data.w=e.w,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(e){this._data.set(e),this.onChange()}update(){switch(this._type){case Dt.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case Dt.Vector2:this.memoryInfo.setVector2(0,this._data);break;case Dt.Vector3:this.memoryInfo.setVector3(0,this._data);break;case Dt.Vector4:this.memoryInfo.setVector4(0,this._data);break;case Dt.Color:this.memoryInfo.setColor(0,this._data);break;case Dt.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}class wf{constructor(){n(this,"instanceID"),n(this,"shaderVariant"),n(this,"vsEntryPoint","main"),n(this,"fsEntryPoint","main"),n(this,"bindGroups"),n(this,"shaderReflection"),n(this,"defineValue"),n(this,"constValues"),n(this,"uniforms"),n(this,"materialDataUniformBuffer"),n(this,"_bufferDic"),n(this,"_shaderChange",!0),n(this,"_valueChange",!1),this.instanceID=bi(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(e,i){this._bufferDic.has(e)?this._bufferDic.set(e,i):(this._bufferDic.set(e,i),this.noticeBufferChange(e))}setStructStorageBuffer(e,i){this._bufferDic.has(e)?(this._bufferDic.set(e,i),this.noticeBufferChange(e)):this._bufferDic.set(e,i)}setUniformBuffer(e,i){this._bufferDic.has(e)?(this._bufferDic.set(e,i),this.noticeBufferChange(e)):this._bufferDic.set(e,i)}setDefine(e,i){(this.defineValue[e]==null||this.defineValue[e]!=i)&&(this.defineValue[e]=i,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[e]=i}hasDefine(e){return this.defineValue[e]!=null}deleteDefine(e){delete this.defineValue[e],this.noticeShaderChange()}setUniformFloat(e,i){this.uniforms[e]?this.uniforms[e].value=i:(this.uniforms[e]=new Vr(i),this.noticeValueChange())}setUniformVector2(e,i){this.uniforms[e]?this.uniforms[e].vector2=i:(this.uniforms[e]=new Vr(i),this.noticeValueChange())}setUniformVector3(e,i){this.uniforms[e]?this.uniforms[e].vector3=i:this.uniforms[e]=new Vr(i)}setUniformVector4(e,i){this.uniforms[e]?this.uniforms[e].vector4=i:this.uniforms[e]=new Vr(i)}setUniformColor(e,i){this.uniforms[e]?this.uniforms[e].color=i:this.uniforms[e]=new Vr(i)}setUniformArray(e,i){this.uniforms[e]?this.uniforms[e].float32Array(i):this.uniforms[e]=new Vr(i)}setUniform(e,i){this.uniforms[e]?this.uniforms[e].data=i:this.uniforms[e]=new Vr(i)}getUniform(e){return this.uniforms[e].data}getUniformFloat(e){return this.uniforms[e].data}getUniformVector2(e){return this.uniforms[e].data}getUniformVector3(e){return this.uniforms[e].data}getUniformVector4(e){return this.uniforms[e].data}getUniformColor(e){return this.uniforms[e].color}getBuffer(e){return this._bufferDic[e].data}noticeBufferChange(e){}applyUniform(){this.materialDataUniformBuffer&&this._valueChange&&this.materialDataUniformBuffer.apply()}destroy(e){}}var os=(t=>(t[t.u32=1]="u32",t[t.f32=1]="f32",t[t["vec2<f32>"]=2]="vec2<f32>",t[t["vec3<f32>"]=3]="vec3<f32>",t[t["vec4<f32>"]=4]="vec4<f32>",t[t.float32=1]="float32",t[t.float32x2=2]="float32x2",t[t.float32x3=3]="float32x3",t[t.float32x4=4]="float32x4",t))(os||{});let I0=[null,pn.float32,pn.float32x2,pn.float32x3,pn.float32x4],w0=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class Zn{}n(Zn,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(0) fragUV: vec2<f32>,
      @location(1) vWorldPos: vec4<f32>,
      @location(2) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(0) position: vec3<f32>,
      @location(1) normal: vec3<f32>,
      @location(2) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),n(Zn,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(1) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(2) o_Normal: vec4<f32>,
          @location(3) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `);let S0=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 
      
      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`,E0=`


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns ±1
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth : f32, near:f32, far:f32) -> f32 {
      let pt = pow((far / near),depth);
      return near * pt / (far / near);
    }

   


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

`,T0=`
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  transformUV1:vec4<f32>,
                  transformUV2:vec4<f32>,

                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,
                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,
                  ao: f32,

                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,
                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,
                  clearcoatColor: vec4<f32>,
                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,B0=`


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,D0=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;class rn{static groupBindingAndFunctions(e,i){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${i})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${i+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${i+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}let R0=`
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${Ue.getMorphTargetShaderBinding(3,0)}
        ${rn.groupBindingAndFunctions(3,2)} 
    #else
        #if USE_MORPHTARGETS
            ${Ue.getMorphTargetShaderBinding(3,0)}
        #endif

        #if USE_SKELETON
            ${rn.groupBindingAndFunctions(3,0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(4) TANGENT: vec4<f32>,
                @location(5) joints0: vec4<f32>,
                @location(6) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(7) joints1: vec4<f32>,
                    @location(8) weights1: vec4<f32>,
                    ${Ue.getMorphTargetAttr(9)}
                #else
                    ${Ue.getMorphTargetAttr(7)}
                #endif
            #else
                @location(4) joints0: vec4<f32>,
                @location(5) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(6) joints1: vec4<f32>,
                    @location(7) weights1: vec4<f32>,
                    ${Ue.getMorphTargetAttr(8)}
                #else
                    ${Ue.getMorphTargetAttr(6)}
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(4) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(5) joints0: vec4<f32>,
                    @location(6) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(7) joints1: vec4<f32>,
                        @location(8) weights1: vec4<f32>,
                    #endif
                #else
                    @location(4) joints0: vec4<f32>,
                    @location(5) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(6) joints1: vec4<f32>,
                        @location(7) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    ${Ue.getMorphTargetAttr(5)}
                #else
                    ${Ue.getMorphTargetAttr(4)}
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(0) index: f32,
    @location(1) varying_UV0: vec2<f32>,
    @location(2) varying_UV1: vec2<f32>,
    @location(3) varying_ViewPos: vec4<f32>,
    @location(4) varying_Clip: vec4<f32>,
    @location(5) varying_WPos: vec4<f32>,
    @location(6) varying_WNormal: vec3<f32>,
    @location(7) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(8) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(9) varying_Tangent: vec4<f32>,
    #endif

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${Ue.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${Ue.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,M0=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,P0=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,U0=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,L0=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2Depth(ORI_VertexVarying.fragCoord.z,globalUniform.near,globalUniform.far) ;
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


`,O0=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,N0=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,F0=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class Jt{}n(Jt,"Cascades",4);let Sf=`

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${Jt.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    empty1: i32,
    empty2: i32,
    empty3: i32,

  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`,k0=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,Ef=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Q0=`
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`,z0=`

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,G0=`
    struct FragmentVarying {
        @location(0) index: f32,
        @location(1) fragUV0: vec2<f32>,
        @location(2) fragUV1: vec2<f32>,
        @location(3) viewPosition: vec4<f32>,
        @location(4) fragPosition: vec4<f32>,
        @location(5) vWorldPos: vec4<f32>,
        @location(6) vWorldNormal: vec3<f32>,
        @location(7) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(8) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(9) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,Tf=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`,V0=`
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,
    }
`,H0=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,Y0=`
    #if USE_SHADOWMAPING
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    #endif

    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }
    var<private> shadowStrut: ShadowStruct ;

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${Jt.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {
      #if USE_SHADOWMAPING
        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }
      #endif
    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
          var totalWeight = 0.0;
          var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
          let v = max(NoL, 0.0) ;
          var bias = shadowBias / v;
          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
              
              // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
              var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
              if ((shadowPos.z - bias ) < depth) {
                visibility += 1.0 ;
              }
              totalWeight += 1.0;
            }
          }
          visibility /= totalWeight;
          visibility += 0.001;
        }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              for (var x: f32 = -offset; x < offset; x += offset / (samples * 0.5)) {
                for (var y: f32 = -offset; y < offset; y += offset / (samples * 0.5)) {
                  for (var z: f32 = -offset; z < offset; z += offset / (samples * 0.5)) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
              }
              shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
          #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    shadowStrut.pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`,X0=`
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,K0=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness ;//pow(roughness,5.0) ;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , alpha);
        let G = GeometrySmith(Context.NoV,Context.NoL, alpha );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return (col.rgb) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        // var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return fragData.EnvColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let NdotV = max(dot(N,V),0.0);
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));

        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);

        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }
`,W0=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;


      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * vec3f(kdLast) * fragData.Albedo.rgb ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
          // ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,1.0,1.0);
      #endif
      
      var color = specColor + indirectResult ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      var retColor = (LinearToGammaSpace(color.rgb));
      retColor += fragData.Emissive.xyz ;
      ORI_FragmentOutput.color = vec4<f32>( retColor.rgb * fragData.Albedo.a ,fragData.Albedo.a) ;
  }

  `,j0=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`,q0=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,J0=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = gammaToLiner(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif


        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`,Z0=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,$0=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,ev=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(0) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,tv=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,iv=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,rv=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,uc=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`,sv=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`,av=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,nv=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,ov=`
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt / LUMEN) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              // var shadow = 0.0 ;
              // if(light.castShadow>=0){
              //     #if USE_SHADOWMAPING
              //       shadow = shadowStrut.directShadowVisibility[i32(light.castShadow)] ; 
              //     #endif
              // }

              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `,lv=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `,hv=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        
        UnLit();

        // ORI_FragmentOutput.color = vec4<f32>( 1.0,0.0,0.0,1.0) ;
    }
`,uv=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,cv=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(0) fragUV: vec2<f32>,
            @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(0) position: vec3<f32>, @location(1) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,dv=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,fv=`
#include "GlobalUniform"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

@fragment
fn main(@location(0) fragUV: vec2<f32>, @location(1) vWorldPos: vec4<f32>, @location(2) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,cc=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(0) o_Position: vec4<f32>,
    @location(1) o_Normal: vec4<f32>,
    @location(2) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,gv=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Ue.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${rn.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(4) TANGENT: vec4<f32>,
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
                ${Ue.getMorphTargetAttr(9)}
            #else
                ${Ue.getMorphTargetAttr(7)}
            #endif
        #else
            @location(4) joints0: vec4<f32>,
            @location(5) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(6) joints1: vec4<f32>,
                @location(7) weights1: vec4<f32>,
                ${Ue.getMorphTargetAttr(8)}
            #else
                ${Ue.getMorphTargetAttr(6)}
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(4) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(5) joints0: vec4<f32>,
                @location(6) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(7) joints1: vec4<f32>,
                    @location(8) weights1: vec4<f32>,
                #endif
            #else
                @location(4) joints0: vec4<f32>,
                @location(5) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(6) joints1: vec4<f32>,
                    @location(7) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                ${Ue.getMorphTargetAttr(5)}
            #else
                ${Ue.getMorphTargetAttr(4)}
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${Ue.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,pv=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(0) fragUV: vec2<f32>,
    @location(1) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Ue.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${rn.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        @location(5) joints0: vec4<f32>,
        @location(6) weights0: vec4<f32>,
        @location(7) joints1: vec4<f32>,
        @location(8) weights1: vec4<f32>,
        ${Ue.getMorphTargetAttr(9)}
    #else
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        @location(6) joints1: vec4<f32>,
        @location(7) weights1: vec4<f32>,
        ${Ue.getMorphTargetAttr(8)}
    #endif
    #else
    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
            #endif
        #else
            @location(4) joints0: vec4<f32>,
            @location(5) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(6) joints1: vec4<f32>,
                @location(7) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            ${Ue.getMorphTargetAttr(5)}
        #else
            ${Ue.getMorphTargetAttr(4)}
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${Ue.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${Ue.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,mv=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,Av=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(0) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(0) fragUV: vec2<f32> , @location(1) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,_v=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(0) vID: f32 ,
        @location(1) vPos: vec3<f32> ,
        @location(2) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${Ue.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${rn.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(4) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(5) joints0: vec4<f32>,
            @location(6) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(7) joints1: vec4<f32>,
                @location(8) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            ${Ue.getMorphTargetAttr(5)}
        #endif
    #elseif USE_SKELETON
        @location(4) joints0: vec4<f32>,
        @location(5) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(6) joints1: vec4<f32>,
            @location(7) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        ${Ue.getMorphTargetAttr(4)}
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${Ue.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,vv=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(0) vID: f32, @location(1) vPos:vec3<f32> ,  @location(2) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`;class W{static init(){W.register("MathShader",E0),W.register("FastMathShader",Q0),W.register("MatrixShader",av),W.register("GlobalUniform",Sf),W.register("WorldMatrixUniform",Ef),W.register("NormalMap_frag",z0),W.register("LightingFunction_frag",S0),W.register("PhysicMaterialUniform_frag",T0),W.register("UnLitMaterialUniform_frag",B0),W.register("VideoUniform_frag",M0),W.register("InstanceUniform",k0),W.register("Inline_vert",U0),W.register("VertexAttributes_vert",R0),W.register("Common_vert",O0),W.register("Common_frag",L0),W.register("FragmentVarying",G0),W.register("ColorPassFragmentOutput",Tf),W.register("ClusterLight",nv),W.register("ShadingInput",V0),W.register("IESProfiles_frag",H0),W.register("ShadowMapping_frag",Y0),W.register("Irradiance_frag",X0),W.register("IrradianceVolumeData_frag",P0),W.register("BrdfLut_frag",N0),W.register("EnvMap_frag",F0),W.register("ColorUtil_frag",uc),W.register("ColorUtil",uc),W.register("BRDF_frag",K0),W.register("Hair_frag",ov),W.register("BxDF_frag",W0),W.register("BsDF_frag",lv),W.register("UnLit_frag",D0),W.register("UnLit",hv),W.register("Clearcoat_frag",j0),W.register("LitShader",q0),W.register("PBRLItShader",J0),W.register("ClusterDebug_frag",w0),W.register("BxdfDebug_frag",Z0),W.register("GenerayRandomDir",sv),W.register("Quad_vert_wgsl",ev),W.register("Quad_frag_wgsl",tv),W.register("Quad_depth2d_frag_wgsl",iv),W.register("Quad_depthCube_frag_wgsl",rv),W.register("sky_vs_frag_wgsl",Zn.sky_vs_frag_wgsl),W.register("sky_fs_frag_wgsl",Zn.sky_fs_frag_wgsl),W.register("LambertShader",uv),W.register("QuadGlsl_vs",cv),W.register("QuadGlsl_fs",dv),W.register("SkyGBuffer_fs",fv),W.register("gbuffer_vs",cc),W.register("gbuffer_fs",cc),W.register("castPointShadowMap_vert",pv),W.register("shadowCastMap_frag",mv),W.register("shadowCastMap_vert",gv),W.register("directionShadowCastMap_frag",Av),W.register("ZPass_shader_vs",_v),W.register("ZPass_shader_fs",vv)}static register(e,i){W[e.toLowerCase()]||(W[e.toLowerCase()]=i)}static getShader(e){return W[e.toLowerCase()],W[e.toLowerCase()]}}class li{static parse(e,i){return e=this.filterComment(e),e=this.parsePreprocess(new dc,e,i),e=this.parseAutoBindingForGroupX(e,1),e}static parseComputeShader(e,i){return e=this.filterComment(e),e=this.parsePreprocess(new dc,e,i),e}static parsePreprocess(e,i,r){let s=i.indexOf("#");if(s==-1)return i;let a=i.substring(0,s),o=i.indexOf(`
`,i.lastIndexOf("#")),l=i.substring(s,o),h=i.substring(o);return a+this.parsePreprocessCommand(e,l,r)+h}static parseAutoBindingForGroupX(e,i){let r=0,s="",a=new Map;for(;r<e.length;){let o=e.indexOf("@group(",r);if(o==-1){s+=e.substring(r);break}let l=e.indexOf(")",o),h=Number.parseInt(e.substring(o+7,l));if(o=e.indexOf("@binding(",l),l=e.indexOf(")",o),s+=e.substring(r,o),h==i)if(a.has(h)){let u=a.get(h)+1;s+=`@binding(${u})`,a.set(h,u)}else s+="@binding(0)",a.set(h,0);else s+=e.substring(o,l+1);r=l+1}return s}static parsePreprocessCommand(e,i,r){let s="",a=i.split(`
`),o=[!1],l=[!1];for(let h=0;h<a.length;h++){let u=a[h],c=o[o.length-1];if(u.trim().indexOf("#")!=0){c||(s+=u+`
`);continue}let d=u.trim();if(d.indexOf("#if")!=-1){if(c&&o.length>1){o.push(c);continue}let f=d.substring(3).trim();c=!this.parseCondition(f,r),o.push(c),l.push(!c);continue}else if(d.indexOf("#elseif")!=-1||d.indexOf("#else")!=-1&&d.indexOf(" if")!=-1){if(l[l.length-1]){o.pop(),c=!0,o.push(c);continue}if(o.pop(),c=o[o.length-1],c&&o.length>1){o.push(c);continue}let f=d.substring(d.indexOf("if")+2).trim();f==""&&console.error(`preprocess command error, conditions missing: ${d}`),c=!this.parseCondition(f,r),o.push(c),l.push(!c);continue}else if(d.indexOf("#else")!=-1){o.pop(),c&&o.length>1&&o[o.length-1]?o.push(c):o.push(!c);continue}else if(d.indexOf("#endif")!=-1){o.pop(),l.pop();continue}else if(d.indexOf("#include")!=-1){let f="",g=d.charAt(d.length-1);if(g==">"?f=this.extract(d,"<",">"):f=this.extract(d,g,g),!e.includeMap.has(f)){e.includeMap.set(f,!0);let m=W.getShader(f);if(!m)throw`${d} error: '${f}' not found`;m=this.filterComment(m),m=this.parsePreprocess(e,m,r),s+=m+`\r
`}continue}else if(d.indexOf("#define ")!=-1){let f=d.substring(d.indexOf("#define ")+8).trim(),g=f.indexOf(" "),m=f,A="";g!=-1&&(m=f.substring(0,g).trim(),A=f.substring(g+1).trim()),r[m]=A;continue}else throw"nonsupport: "+d}return s}static parseCondition(e,i){let r=i[e];return r==null?!1:r==!0||r!=0}static filterComment(e){let i="",r=!0,s=!0;for(let a=0;a<e.length;){let o=r?e.indexOf("//",a):-1,l=s?e.indexOf("/*",a):-1;if(o==-1&&l==-1){i+=e.substring(a);break}r=o!=-1,s=l!=-1,o!=-1&&l!=-1&&(o<l?l=-1:o=-1),o!=-1?(l=e.indexOf(`
`,o),i+=e.substring(a,o),a=l!=-1?l:e.length):l!=-1&&(o=e.indexOf("*/",l),i+=e.substring(a,l),a=o+2)}return i}static extract(e,i,r){let s=e.indexOf(i)+i.length,a=e.indexOf(r,s);return e.substring(s,a).trim()}}class dc{constructor(){n(this,"includeMap",new Map)}}const Pn=class{constructor(){n(this,"attributes",[]),n(this,"vs_variables",[]),n(this,"fs_variables",[]),n(this,"cs_variables",[]),n(this,"groups",[]),n(this,"variables",{}),n(this,"useSplit",!1)}static parser(t,e){e.shaderReflection||(e.shaderReflection=new Pn),t.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(t),e.shaderReflection.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(t))}static parser2(t,e){e.shaderReflection||(e.shaderReflection=new Pn);let i=e.shaderReflection;t.indexOf("@vertex")!=-1?(i.attributes=this.parserVertex(e.vsEntryPoint,t),i.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?i.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(i.cs_variables=this.parserVariables(t)),t.indexOf("splitTexture")!=-1&&(i.useSplit=!0)}static combineShaderReflectionVarInfo(t,e){for(const i of e){t.groups[i.group]||(t.groups[i.group]=[]);let r=i;if(t.groups[i.group][i.binding]){let s=t.groups[i.group][i.binding],a=i;if(s.dataFields)for(let o=0;o<s.dataFields.length;o++)s.dataFields[o];if(a.dataFields)for(let o=0;o<a.dataFields.length;o++)a.dataFields[o]}t.groups[i.group][i.binding]=r,t.variables[i.varName]=r}}static final(t){let e=t.shaderReflection;this._shaderReflectionMap.set(t.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(t,e){if(e.shaderVariant!=null){let i=li.parse(t,e.defineValue);Pn.parser2(i,e)}}static poolGetReflection(t){return this._shaderReflectionMap.get(t)}static genShaderVar(t){let e=`${t.vs}${t.fs}${t.compute}`;e+="|";for(const i in t.uniforms)e+=i+":";e+="|";for(const i in t.constValues)e+=i+":",e+=t.constValues[i];e+="|";for(const i in t.defines)e+=i+":",e+=t.defines[i];e+="|";for(const i in t.shaderState)e+=i+":",e+=t.shaderState[i]+";";return e}static genShaderVariant(t){let e="";for(const i in t.uniforms)e+=i+":";e+="|";for(const i in t.constValues)e+=i+":",e+=t.constValues[i];e+="|";for(const i in t.defineValue)e+=i+":",e+=t.defineValue[i];return e}static genRenderShaderVariant(t){let e=`RenderShader(${t.vsName},${t.fsName})`;e+="|",e+=this.genShaderVariant(t),e+="|";for(const i in t.shaderState)e+=i+":",e+=t.shaderState[i]+";";return e}static genComputeShaderVariant(t){let e=`ComputeShader(${t.instanceID})`;return e+="|",e+=this.genShaderVariant(t),e}combine(t){let e=t.shaderReflection,i=t.defines,r={};for(let a=0;a<this.attributes.length;a++){let o=this.attributes[a];i[o.name]&&(r[o.name]=o)}let s=e.attributes.length;for(let a=0;a<s;a++){const o=e.attributes[a];if(!r[o.name])this.attributes.push(o);else{let l=r[o.name];l.location==o.location&&l.name!=o.name&&console.log("location must same!")}}}static parserVariables(t){let e=0,i=[];for(;e<t.length;){let r=t.indexOf("@group(",e);if(r<0)break;let s=t.indexOf(";",r);e=s;let a=t.substring(r,s),o=this.extract(a,"@group(",")"),l=this.extract(a,"@binding(",")"),h="",u="var";a.indexOf("var<")!=-1?(h=this.extract(a,">",":"),u=this.extract(a,"var<",">").replace(",","-").replaceAll(" ","")):h=this.extract(a,"var",":");let c=a.substring(a.lastIndexOf(":")+1).trim(),d={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};d.group=Number.parseInt(o),d.binding=Number.parseInt(l),d.varType=u,d.varName=h,d.dataType=c,d.dataIsBuiltinType=this.isBuiltinTypes(d.dataType),d.dataIsBuiltinType||(d.dataFields=this.parserStructFields(t,d.dataType)),i.push(d)}return i}static extract(t,e,i){let r=t.indexOf(e)+e.length,s=t.indexOf(i,r);return t.substring(r,s).trim()}static isBuiltinTypes(t){switch(t){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=t.indexOf("<");if(e!=-1)switch(t.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(t.substring(e+1,t.lastIndexOf(">")))}break}return!1}static parserStructFields(t,e){let i=[],r=0;for(;r<t.length;){let s=t.indexOf("struct ",r);if(s<0)break;let a=t.indexOf("{",s);if(r=a,t.substring(s+6,a).trim()===e){s=t.indexOf("{",s),a=t.indexOf("}",s);let o=t.substring(s+1,a).split(",");for(let l of o){let h=l.indexOf(":");if(h!=-1){let u={name:l.substring(0,h).trim(),type:l.substring(h+1).trim()};i.push(u)}}break}}return i}static parserVertexOld(t){let e=[],i=t.split("fn main(")[1].split("->")[0],r=i.split("@");if(r&&r.length>1)for(let a=1;a<r.length;a++){let o=r[a].replace(/\s*$/g,"");o=o.replaceAll(",",""),o=o.replaceAll(`
`,""),o=o.replaceAll("  "," "),this.parserAttribute(o,e)}else{var s=i.split(":")[1];s=s.replaceAll("  ",""),s=s.replaceAll(" ",""),s=s.replaceAll(")",""),s=t.split(`struct ${s}`)[1];let a=s.indexOf("{"),o=s.indexOf("}");s=s.slice(a,o),r=s.split("@");for(let l=1;l<r.length;l++){let h=r[l].replace(/\s*$/g,"");h=h.replaceAll(`
`,""),h=h.split(",")[0],h=h.replaceAll("  "," "),this.parserAttribute(h,e)}}return e}static parserVertex(t,e){let i=[],r=e.split(`fn ${t}(`)[1].split("->")[0],s=r.split("@");if(s&&s.length>1)for(let o=1;o<s.length;o++){let l=s[o].replace(/\s*$/g,"");l=l.replaceAll(",",""),l=l.replaceAll(`
`,""),l=l.replaceAll("  "," "),this.parserAttribute(l,i)}else{var a=r.split(":")[1];a=a.replaceAll("  ",""),a=a.replaceAll(" ",""),a=a.replaceAll(")",""),a=e.split(`struct ${a}`)[1];let o=a.indexOf("{"),l=a.indexOf("}");a=a.slice(o,l),s=a.split("@");for(let h=1;h<s.length;h++){let u=s[h].replace(/\s*$/g,"");u=u.replaceAll(`
`,""),u=u.split(",")[0],u=u.replaceAll("  "," "),this.parserAttribute(u,i)}}return i}static parserAttribute(t,e){let i={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(t.indexOf("builtin")!=-1){i.type="builtin";var r=t.match(/\((.+?)\)/g)[0];r=t.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),i.location=parseInt(r);let s=t.split(":");i.name=s[0].split(" ")[1],i.name=i.name.replaceAll("  "," "),i.name=i.name.replaceAll(" ",""),i.valueType=s[1],i.valueType=i.valueType.replaceAll("  "," "),i.valueType=i.valueType.replaceAll(" ",""),i.valueType=i.valueType.replaceAll("\r",""),i.valueType=i.valueType.replaceAll(")",""),i.valueType=i.valueType.replaceAll(")",""),i.size=os[i.valueType],e.push(i)}else if(t.indexOf("location")!=-1){i.type="location";var r=t.match(/\((.+?)\)/g)[0];r=t.match(/\((.+?)\)/g)[0],r=r.replace("(",""),r=r.replaceAll(")",""),i.location=parseInt(r);let a=t.split(":");i.name=a[0].split(" ")[1],i.name=i.name.replaceAll("  "," "),i.name=i.name.replaceAll(" ",""),i.valueType=a[1],i.valueType=i.valueType.replaceAll("  "," "),i.valueType=i.valueType.replaceAll(" ",""),i.valueType=i.valueType.replaceAll("\r",""),i.valueType=i.valueType.replaceAll(")",""),i.valueType=i.valueType.replaceAll(")",""),i.size=os[i.valueType],e.push(i)}i.format=I0[os[i.valueType]]}};let si=Pn;n(si,"_shaderReflectionMap",new Map);class di extends wf{constructor(e){super(),n(this,"entryPoint","CsMain"),n(this,"workerSizeX",1),n(this,"workerSizeY",0),n(this,"workerSizeZ",0),n(this,"_computePipeline"),n(this,"_csShaderModule"),n(this,"_destCS"),n(this,"_sourceCS"),n(this,"_storageTextureDic"),n(this,"_sampleTextureDic"),n(this,"_groupsShaderReflectionVarInfos"),n(this,"_groupCache",{}),this._sourceCS=e,si.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,i){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,i)}setSamplerTexture(e,i){this._sampleTextureDic.set(e,i)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let i=0;i<this.bindGroups.length;++i)e.setBindGroup(i,this.bindGroups[i]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,i,r,s){let a=this._bufferDic.get(i);if(a){let o={binding:r,resource:{buffer:a.buffer,offset:0,size:a.memory.shareDataBuffer.byteLength}};s.push(o)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${i} is missing!`)}noticeBufferChange(e){let i=this._groupCache[e];i&&this.genGroups(i.groupIndex,i.infos,!0)}genGroups(e,i,r=!1){if(!this.bindGroups[e]||r){const s=i[e];let a=[];for(let l=0;l<s.length;++l){const h=s[l];if(h)switch(h.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,h.varName,h.binding,a),this._groupCache[h.varName]={groupIndex:e,infos:i};break;case"var":if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let d={binding:h.binding,resource:c.gpuSampler};a.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this._sampleTextureDic.get(u);if(c){let d={binding:h.binding,resource:c.gpuSampler_comparison};a.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture_storage")!=-1){let u=this._storageTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),Me.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}else if(h.dataType.indexOf("texture")!=-1){let u=this._sampleTextureDic.get(h.varName);if(u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c),Me.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${h.varName} is missing! `)}break;default:console.error("unprocessed type:",h.varType);break}}let o=D.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:a});this.bindGroups[e]=o}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=D.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let i=0;i<e.groups.length;++i){let r=e.groups[i];this._groupsShaderReflectionVarInfos[i]=r,this.genGroups(i,this._groupsShaderReflectionVarInfos)}D.addEventListener(ds.RESIZE,i=>{for(let r=0;r<e.groups.length;++r){let s=e.groups[r];this._groupsShaderReflectionVarInfos[r]=s,this.genGroups(r,this._groupsShaderReflectionVarInfos,!0)}},this)}preCompileShader(e){for(const i in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,i)){const r=this.constValues[i];e=e.replaceAll(`&${i}`,r.toString())}this._destCS=li.parseComputeShader(e,this.defineValue)}compileShader(){let e=D.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(i=>{i.messages.length>0&&console.log(this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=si.genComputeShaderVariant(this);let e=si.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(si.getShaderReflection2(this._destCS,this),si.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}class ai{static start(e){let i=this.profilerLabelMap.get(e);i||(i={lable:e,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(e,i)),i.start=performance.now(),i.end=performance.now(),i.count=0,i.child.clear()}static end(e){let i=this.profilerLabelMap.get(e);i&&(i.end=performance.now(),i.total=i.end-i.start)}static countStart(e,i=""){let r=this.profilerLabelMap.get(e);if(r&&(r.count++,i!="")){let s=r.child.get(i);s||(s={lable:i,start:0,end:0,total:0,count:0}),s.start=performance.now(),s.end=performance.now(),s.count=0,r.child.set(i,s)}}static countEnd(e,i){let r=this.profilerLabelMap.get(e);if(r&&i!=""){let s=r.child.get(i);s||(s={lable:i,start:0,end:0,total:0,count:0}),s.end=performance.now(),s.total=s.end-s.start,s.count++}}static print(e){let i=this.profilerLabelMap.get(e);i&&console.log("performance",e,i.total+" ms")}}n(ai,"profilerLabelMap",new Map);const xv=`var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `,Yr=class{static async init(t){await new Promise(e=>{const i=document.createElement("script");i.async=!0,i.type="text/javascript",i.src=URL.createObjectURL(new Blob([xv])),document.head.appendChild(i),i.onload=()=>{let r=()=>{this.wasm=window.wasmMatrix,this.wasm&&this.wasm.calledRun?e(!0):setTimeout(r,20)};r()}}),this.allocMatrix(t)}static allocMatrix(t){t>te.maxCount&&console.error(`The maximum allocation size is exceeded! current:${t}, limit:${te.maxCount}`),this.wasm._allocation(t),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.matrixBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*t),this.matrixSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*t),this.matrixContinuedSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*t),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,Yr.stateStruct*t),te.allocMatrix(t)}static updateAllContinueTransform(t,e,i){this.wasm._updateAllMatrixContinueTransform(t,e,i)}static setParent(t,e,i){this.matrixStateBuffer[t*Yr.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[t*Yr.stateStruct+3]=i}static setTranslate(t,e,i,r){this.matrixSRTBuffer[t*9+6]=e,this.matrixSRTBuffer[t*9+7]=i,this.matrixSRTBuffer[t*9+8]=r}static setRotation(t,e,i,r){this.matrixSRTBuffer[t*9+3]=e%360,this.matrixSRTBuffer[t*9+4]=i%360,this.matrixSRTBuffer[t*9+5]=r%360}static setScale(t,e,i,r){this.matrixSRTBuffer[t*9+0]=e,this.matrixSRTBuffer[t*9+1]=i,this.matrixSRTBuffer[t*9+2]=r}static setContinueTranslate(t,e,i,r){(e!=0||i!=0||r!=0)&&(this.matrixContinuedSRTBuffer[t*9+6]=e,this.matrixContinuedSRTBuffer[t*9+7]=i,this.matrixContinuedSRTBuffer[t*9+8]=r,this.matrixStateBuffer[t*Yr.stateStruct+1]=1)}static setContinueRotation(t,e,i,r){(e!=0||i!=0||r!=0)&&(this.matrixContinuedSRTBuffer[t*9+3]=e,this.matrixContinuedSRTBuffer[t*9+4]=i,this.matrixContinuedSRTBuffer[t*9+5]=r,this.matrixStateBuffer[t*Yr.stateStruct+1]=1)}static setContinueScale(t,e,i,r){(e!=0||i!=0||r!=0)&&(this.matrixContinuedSRTBuffer[t*9+0]=e,this.matrixContinuedSRTBuffer[t*9+1]=i,this.matrixContinuedSRTBuffer[t*9+2]=r,this.matrixStateBuffer[t*Yr.stateStruct+1]=1)}};let ve=Yr;n(ve,"matrixBuffer"),n(ve,"matrixSRTBuffer"),n(ve,"matrixContinuedSRTBuffer"),n(ve,"matrixStateBuffer"),n(ve,"matrixBufferPtr"),n(ve,"matrixSRTBufferPtr"),n(ve,"matrixContinuedSRTBufferPtr"),n(ve,"matrixStateBufferPtr"),n(ve,"wasm"),n(ve,"stateStruct",4);class ki{}n(ki,"AXIS_ANGLE","axisAngle"),n(ki,"EULER_ANGLES","eulerAngles"),n(ki,"QUATERNION","quaternion");const Nt=class{constructor(t=0,e=0,i=0,r=1){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"w",1),this.x=t,this.y=e,this.z=i,this.w=r}static identity(){return Nt._zero}static quaternionToMatrix(t,e){let i=t.x*2,r=t.y*2,s=t.z*2,a=t.x*i,o=t.y*r,l=t.z*s,h=t.x*r,u=t.x*s,c=t.y*s,d=t.w*i,f=t.w*r,g=t.w*s;e.rawData[0]=1-(o+l),e.rawData[1]=h+g,e.rawData[2]=u-f,e.rawData[3]=0,e.rawData[4]=h-g,e.rawData[5]=1-(a+l),e.rawData[6]=c+d,e.rawData[7]=0,e.rawData[8]=u+f,e.rawData[9]=c-d,e.rawData[10]=1-(a+o),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(t=0,e=0,i=0,r=1){this.x=t,this.y=e,this.z=i,this.w=r}divide(t){return t instanceof Nt?new Nt(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}setFromArray(t){return this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3],this}multiply(t,e){var i=t.w,r=t.x,s=t.y,a=t.z,o=e.w,l=e.x,h=e.y,u=e.z;this.w=i*o-r*l-s*h-a*u,this.x=i*l+r*o+s*u-a*h,this.y=i*h-r*u+s*o+a*l,this.z=i*u+r*h-s*l+a*o}multiplyVector(t,e=null){e||(e=new Nt);var i=t.x,r=t.y,s=t.z;return e.w=-this.x*i-this.y*r-this.z*s,e.x=this.w*i+this.y*s-this.z*r,e.y=this.w*r-this.x*s+this.z*i,e.z=this.w*s+this.x*r-this.y*i,e}fromAxisAngle(t,e){e*=Math.PI/180;var i=e*.5,r=Math.sin(i);this.w=Math.cos(i),this.x=t.x*r,this.y=t.y*r,this.z=t.z*r,this.normalize()}toAxisAngle(t){var e=this.x*this.x+this.y*this.y+this.z*this.z,i=0;return e>0?(i=2*Math.acos(this.w),e=1/Math.sqrt(e),t.x=this.x*e,t.y=this.y*e,t.z=this.z*e):(i=0,t.x=1,t.y=0,t.z=0),i}slerp(t,e,i){var r=t.w,s=t.x,a=t.y,o=t.z,l=e.w,h=e.x,u=e.y,c=e.z,d=r*l+s*h+a*u+o*c;if(d<0&&(d=-d,l=-l,h=-h,u=-u,c=-c),d<.95){var f=Math.acos(d),g=1/Math.sin(f),m=Math.sin(f*(1-i))*g,A=Math.sin(f*i)*g;this.w=r*m+l*A,this.x=s*m+h*A,this.y=a*m+u*A,this.z=o*m+c*A}else{this.w=r+i*(l-r),this.x=s+i*(h-s),this.y=a+i*(u-a),this.z=o+i*(c-o);var _=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=_,this.x*=_,this.y*=_,this.z*=_}}lerp(t,e,i){var r=t.w,s=t.x,a=t.y,o=t.z,l=e.w,h=e.x,u=e.y,c=e.z,d;r*l+s*h+a*u+o*c<0&&(l=-l,h=-h,u=-u,c=-c),this.w=r+i*(l-r),this.x=s+i*(h-s),this.y=a+i*(u-a),this.z=o+i*(c-o),d=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=d,this.x*=d,this.y*=d,this.z*=d}fromEulerAngles(t,e,i){t*=We,e*=We,i*=We;var r=t*.5,s=e*.5,a=i*.5,o=Math.cos(r),l=Math.sin(r),h=Math.cos(s),u=Math.sin(s),c=Math.cos(a),d=Math.sin(a);return this.w=o*h*c+l*u*d,this.x=l*h*c-o*u*d,this.y=o*u*c+l*h*d,this.z=o*h*d-l*u*c,this}setFromRotationMatrix(t){const e=t.rawData,i=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],h=e[2],u=e[6],c=e[10],d=i+o+c;if(d>0){const f=.5/Math.sqrt(d+1);this.w=.25/f,this.x=(u-l)*f,this.y=(s-h)*f,this.z=(a-r)*f}else if(i>o&&i>c){const f=2*Math.sqrt(1+i-o-c);this.w=(u-l)/f,this.x=.25*f,this.y=(r+a)/f,this.z=(s+h)/f}else if(o>c){const f=2*Math.sqrt(1+o-i-c);this.w=(s-h)/f,this.x=(r+a)/f,this.y=.25*f,this.z=(l+u)/f}else{const f=2*Math.sqrt(1+c-i-o);this.w=(a-r)/f,this.x=(s+h)/f,this.y=(l+u)/f,this.z=.25*f}return this}getEulerAngles(t){var e,i,r,s,a,o,l,h;return t||(t=new p),s=this.x,a=this.y,o=this.z,l=this.w,h=2*(l*a-s*o),h<=-.99999?(e=2*Math.atan2(s,l),i=-Math.PI/2,r=0):h>=.99999?(e=2*Math.atan2(s,l),i=Math.PI/2,r=0):(e=Math.atan2(2*(l*s+a*o),1-2*(s*s+a*a)),i=Math.asin(h),r=Math.atan2(2*(l*o+s*a),1-2*(a*a+o*o))),t.set(e,i,r).scaleBy(nn)}normalize(t=1){var e=t/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(t){var e=t.decompose(ki.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(t=null){t||(t=new Nt);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var i=1/e;t.w=this.w*i,t.x=-this.x*i,t.y=-this.y*i,t.z=-this.z*i}return t}clone(){return new Nt(this.x,this.y,this.z,this.w)}transformVector(t,e=null){var i,r,s,a,o=t.x,l=t.y,h=t.z;return e||(e=new p),a=-this.x*o-this.y*l-this.z*h,i=this.w*o+this.y*h-this.z*l,r=this.w*l-this.x*h+this.z*o,s=this.w*h+this.x*l-this.y*o,e.x=-a*this.x+i*this.w-r*this.z+s*this.y,e.y=-a*this.y+i*this.z+r*this.w-s*this.x,e.z=-a*this.z-i*this.y+r*this.x+s*this.w,e}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,this}mul(t,e,i){let r=i||new Nt;return r.x=t.w*e.x+t.x*e.w+t.y*e.z-t.z*e.y,r.y=t.w*e.y+t.y*e.w+t.z*e.x-t.x*e.z,r.z=t.w*e.z+t.z*e.w+t.x*e.y-t.y*e.x,r.w=t.w*e.w-t.x*e.x-t.y*e.y-t.z*e.z,r}clampf(t,e,i){if(e>i){var r=e;e=i,i=r}return t<e?e:t<i?t:i}static serialize(t){return new Nt(t.x,t.y,t.z,t.w)}};let ye=Nt;n(ye,"HELP_0",new Nt(0,0,0,1)),n(ye,"HELP_1",new Nt(0,0,0,1)),n(ye,"HELP_2",new Nt(0,0,0,1)),n(ye,"_zero",new Nt(0,0,0,1)),n(ye,"CALCULATION_QUATERNION",new Nt);let nn=180/Math.PI,We=Math.PI/180;function ni(t,e,i){return Math.max(e,Math.min(i,t))}class oi{static gaussFunction(e,i,r,s){let a=Math.pow(e-r,2),o=2*Math.pow(s,2),l=-1*(a/o),h=Math.pow(Math.E,l);return Math.round(h*i)}static computeGaussian(e,i){return 1/Math.sqrt(2*Math.PI*i)*Math.exp(-(e*e)/(2*i*i))}static gaussCoef(e){e<.5&&(e=.5);let i=Math.exp(.726*.726)/e,r=Math.exp(-i),s=Math.exp(-2*i),a=(1-r)*(1-r)/(1+2*i*r-s),o=a,l=a*(i-1)*r,h=a*(i+1)*r,u=-a*s,c=2*r,d=-s,f=(o+l)/(1-c-d),g=(h+u)/(1-c-d);return new Float32Array([o,l,h,u,c,d,f,g])}static clampf(e,i,r){if(i>r){let s=i;i=r,r=s}return e<i?i:e<r?e:r}static normalizeAngle(e){for(;e>180;)e-=360;for(;e<-180;)e+=360;return e}static fract(e){return e-Math.floor(e)}static getRandDirXZ(e){let i=e*Math.random(),r=360*Math.random()*We,s=Math.cos(r)*i,a=Math.sin(r)*i;return{x:s,z:a}}static getRandDirXYZ(e){let i=e*Math.random(),r=360*Math.random()*We,s=Math.cos(r)*i,a=Math.tan(r)*i,o=Math.sin(r)*i;return new p(s,a,o)}static getCycleXYZ(e){let i=e*Math.random(),r=360*Math.random()*We,s=Math.cos(r)*i,a=e*Math.random()-e*.5,o=Math.sin(r)*i;return new p(s,a,o)}static angle(e,i){let r=Ne.HELP_0,s=Ne.HELP_1;return r.set(e.x,e.z),s.set(i.x,i.z),Math.acos((r.x*s.x+r.y*s.y)/(r.abs()*s.abs()))}static angle_360(e,i){let r=p.HELP_0;return e.crossProduct(i,r),r.z>0?oi.angle(e,i):360-oi.angle(e,i)}getRotationY(e){return oi.normalizeAngle(Math.atan2(e.z,e.x)*nn)}static fromToRotation(e,i,r=null){r||(r=new ye);let s=te.help_matrix_2;return te.fromToRotation(e,i,s),r.fromMatrix(s),r}static getEularDir_yUp(e){let i=ye.HELP_0;return i.fromEulerAngles(0,e,0),i.transformVector(p.Z_AXIS,p.HELP_5),p.HELP_5}static transformVector(e,i,r=null){r||(r=new p);let s=e.rawData,a=s[0],o=s[1],l=s[2],h=s[3],u=s[4],c=s[5],d=s[6],f=s[7],g=s[8],m=s[9],A=s[10],_=s[11],x=s[12],b=s[13],R=s[14],E=s[15],M=i.x,G=i.y,V=i.z;return r.x=a*M+u*G+g*V+x,r.y=o*M+c*G+m*V+b,r.z=l*M+d*G+A*V+R,r.w=h*M+f*G+_*V+E,r}}let fc=function(t,e,i){let r=i-e;return Math.floor(t/r)%2==0?t%r+e:i-t%r+e},gc=function(t,e,i){let r=i-e;return t%r+e};function ri(t,e){return t instanceof p&&e instanceof p||t instanceof ye&&e instanceof ye?t.x*e.x+t.y*e.y+t.z*e.z:t.x*e.x+t.y*e.y}function yv(t){return ri(t,t)}function Bf(t,e){return t-Math.floor(t/e)*e}const Z=class{constructor(t=!1){if(n(this,"index",0),n(this,"offset",0),n(this,"rawData"),n(this,"_position"),Z.useCount>=Z.allocCount){let e=Z.allocCount+Z.allocOnceCount;ve.allocMatrix(e)}this.index=Z.useCount,this.offset=Z.wasmMatrixPtr+this.index*Z.blockBytes,Z.dynamicGlobalMatrixRef[this.index]=this,Z.useCount++,this.rawData=new Float32Array(Z.dynamicMatrixBytes.buffer,this.offset,16),this._position=new p,this.identity()}static allocMatrix(t){this.allocCount=t,Z.dynamicMatrixBytes=ve.matrixBuffer,Z.buffer=Z.dynamicMatrixBytes.buffer,Z.wasmMatrixPtr=ve.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=Z.wasmMatrixPtr+e.index*Z.blockBytes,e.rawData=new Float32Array(Z.dynamicMatrixBytes.buffer,e.offset,16)}),Z.help_matrix_0||(Z.help_matrix_0=new Z),Z.help_matrix_1||(Z.help_matrix_1=new Z),Z.help_matrix_2||(Z.help_matrix_2=new Z),Z.helpMatrix||(Z.helpMatrix=new Z),Z.helpMatrix2||(Z.helpMatrix2=new Z),Z._getEulerMatrix||(Z._getEulerMatrix=new Z),Z._getEulerMatrix.identity()}static fromToRotation(t,e,i){return i||(i=new Z),i.transformDir(t,e),i}static getAxisRotation(t,e,i,r){let s=new Z,a=r*(Math.PI/180),o=Math.cos(a),l=Math.sin(a),h=1-o,u,c;return s.rawData[0]=o+t*t*h,s.rawData[5]=o+e*e*h,s.rawData[10]=o+i*i*h,u=t*e*h,c=i*l,s.rawData[1]=u+c,s.rawData[4]=u-c,u=t*i*h,c=e*l,s.rawData[8]=u+c,s.rawData[2]=u-c,u=e*i*h,c=t*l,s.rawData[9]=u-c,s.rawData[6]=u+c,s}static sanitizeEuler(t){Z.makePositive(t)}static makePositive(t){let e=-1e-4,i=Math.PI*2-1e-4;t.x<e?t.x+=2*Math.PI:t.x>i&&(t.x-=2*Math.PI),t.y<e?t.y+=2*Math.PI:t.y>i&&(t.y-=2*Math.PI),t.z<e?t.z+=2*Math.PI:t.z>i&&(t.z-=2*Math.PI)}static matrixToEuler(t,e){return t.get(1,2)<.999?t.get(1,2)>-.999?(e.x=Math.asin(-t.get(1,2)),e.y=Math.atan2(t.get(0,2),t.get(2,2)),e.z=Math.atan2(t.get(1,0),t.get(1,1)),Z.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(t.get(0,1),t.get(0,0)),e.z=0,Z.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-t.get(0,1),t.get(0,0)),e.z=0,Z.sanitizeEuler(e),!1)}static matrixMultiply(t,e,i){Z.wasm.Matrix_Multiply(t.index,e.index,i.index)}static matrixAppend(t,e,i){Z.wasm.Matrix_Append(t.index,e.index,i.index)}static matrixRotateY(t,e){Z.wasm.Matrix_Append(t,e.index)}static matrixRotate(t,e,i){Z.wasm.Matrix_Rotate(t,e,i.index)}lookAt(t,e,i=p.Y_AXIS){let r=this.rawData,s=e.subtract(t,p.HELP_0);s.length<1e-4&&(s.z=1),s.normalize();let a=i.crossProduct(s,p.HELP_1);a.length<1e-4&&(Math.abs(i.z)>.9999?s.x+=1e-4:s.z+=1e-4,s.normalize()),a=i.crossProduct(s,a).normalize();let o=s.crossProduct(a,p.HELP_2).normalize();r[0]=a.x,r[1]=o.x,r[2]=s.x,r[3]=0,r[4]=a.y,r[5]=o.y,r[6]=s.y,r[7]=0,r[8]=a.z,r[9]=o.z,r[10]=s.z,r[11]=0,r[12]=-a.dotProduct(t),r[13]=-o.dotProduct(t),r[14]=-s.dotProduct(t),r[15]=1}multiply(t){let e=this.rawData,i=t.rawData,r=Z.float32Array;r[0]=e[0]*i[0]+e[1]*i[4]+e[2]*i[8]+e[3]*i[12],r[1]=e[0]*i[1]+e[1]*i[5]+e[2]*i[9]+e[3]*i[13],r[2]=e[0]*i[2]+e[1]*i[6]+e[2]*i[10]+e[3]*i[14],r[3]=e[0]*i[3]+e[1]*i[7]+e[2]*i[11]+e[3]*i[15],r[4]=e[4]*i[0]+e[5]*i[4]+e[6]*i[8]+e[7]*i[12],r[5]=e[4]*i[1]+e[5]*i[5]+e[6]*i[9]+e[7]*i[13],r[6]=e[4]*i[2]+e[5]*i[6]+e[6]*i[10]+e[7]*i[14],r[7]=e[4]*i[3]+e[5]*i[7]+e[6]*i[11]+e[7]*i[15],r[8]=e[8]*i[0]+e[9]*i[4]+e[10]*i[8]+e[11]*i[12],r[9]=e[8]*i[1]+e[9]*i[5]+e[10]*i[9]+e[11]*i[13],r[10]=e[8]*i[2]+e[9]*i[6]+e[10]*i[10]+e[11]*i[14],r[11]=e[8]*i[3]+e[9]*i[7]+e[10]*i[11]+e[11]*i[15],r[12]=e[12]*i[0]+e[13]*i[4]+e[14]*i[8]+e[15]*i[12],r[13]=e[12]*i[1]+e[13]*i[5]+e[14]*i[9]+e[15]*i[13],r[14]=e[12]*i[2]+e[13]*i[6]+e[14]*i[10]+e[15]*i[14],r[15]=e[12]*i[3]+e[13]*i[7]+e[14]*i[11]+e[15]*i[15],e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15]}multiplyMatrices(t,e){const i=t.rawData,r=e.rawData,s=this.rawData,a=i[0],o=i[4],l=i[8],h=i[12],u=i[1],c=i[5],d=i[9],f=i[13],g=i[2],m=i[6],A=i[10],_=i[14],x=i[3],b=i[7],R=i[11],E=i[15],M=r[0],G=r[4],V=r[8],k=r[12],O=r[1],ce=r[5],we=r[9],Ce=r[13],be=r[2],De=r[6],Ee=r[10],he=r[14],_e=r[3],de=r[7],et=r[11],Qe=r[15];return s[0]=a*M+o*O+l*be+h*_e,s[4]=a*G+o*ce+l*De+h*de,s[8]=a*V+o*we+l*Ee+h*et,s[12]=a*k+o*Ce+l*he+h*Qe,s[1]=u*M+c*O+d*be+f*_e,s[5]=u*G+c*ce+d*De+f*de,s[9]=u*V+c*we+d*Ee+f*et,s[13]=u*k+c*Ce+d*he+f*Qe,s[2]=g*M+m*O+A*be+_*_e,s[6]=g*G+m*ce+A*De+_*de,s[10]=g*V+m*we+A*Ee+_*et,s[14]=g*k+m*Ce+A*he+_*Qe,s[3]=x*M+b*O+R*be+E*_e,s[7]=x*G+b*ce+R*De+E*de,s[11]=x*V+b*we+R*Ee+E*et,s[15]=x*k+b*Ce+R*he+E*Qe,this}multiplyPoint3(t,e){e||(e=new p);let i=this.rawData;return e.x=i[0]*t.x+i[4]*t.y+i[8]*t.z+i[12],e.y=i[1]*t.x+i[5]*t.y+i[9]*t.z+i[13],e.z=i[2]*t.x+i[6]*t.y+i[10]*t.z+i[14],e}multiplyVector4(t,e){e||(e=new p);let i=this.rawData,r=t.x,s=t.y,a=t.z,o=i[3]*r+i[7]*s+i[11]*a+i[15];return o=o||1,e.x=(i[0]*r+i[4]*s+i[8]*a+i[12])/o,e.y=(i[1]*r+i[5]*s+i[9]*a+i[13])/o,e.z=(i[2]*r+i[6]*s+i[10]*a+i[14])/o,e.w=1,e}transformVector4(t,e){let i=this.rawData;e||(e=new p);let r=t.x,s=t.y,a=t.z,o=t.w;return e.x=r*i[0]+s*i[4]+a*i[8]+o*i[12],e.y=r*i[1]+s*i[5]+a*i[9]+o*i[13],e.z=r*i[2]+s*i[6]+a*i[10]+o*i[14],e.w=r*i[3]+s*i[7]+a*i[11]+o*i[15],e}perspectiveMultiplyPoint3(t,e){let i=p.HELP_2,r,s=this.rawData;if(i.x=s[0]*t.x+s[4]*t.y+s[8]*t.z+s[12],i.y=s[1]*t.x+s[5]*t.y+s[9]*t.z+s[13],i.z=s[2]*t.x+s[6]*t.y+s[10]*t.z+s[14],r=s[3]*t.x+s[7]*t.y+s[11]*t.z+s[15],Math.abs(r)>1e-7){let a=1/r;return e.x=i.x*a,e.y=i.y*a,e.z=i.z*a,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(t,e,i,r){let s=this.rawData,a=t*We/2,o=Math.cos(a)/Math.sin(a);s[0]=-o/e,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=o,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=r/(r-i),s[11]=1,s[12]=0,s[13]=0,s[14]=-i*r/(r-i),s[15]=0}perspective3(t,e,i,r){var s=Math.tan(t*Math.PI/360)*i,a=s*e;this.frustum(-a,a,-s,s,i,r)}frustum(t,e,i,r,s,a){var o=this.rawData;o[0]=-2*s/(e-t),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2*s/(r-i),o[6]=0,o[7]=0,o[8]=(e+t)/(e-t),o[9]=(r+i)/(r-i),o[10]=a/(a-s),o[11]=1,o[12]=0,o[13]=0,o[14]=-a*s/(a-s),o[15]=0}ortho(t,e,i,r){let s=this.rawData;return s[0]=2/t,s[1]=0,s[2]=0,s[3]=0,s[4]=0,s[5]=2/e,s[6]=0,s[7]=0,s[8]=0,s[9]=0,s[10]=1/(r-i),s[11]=0,s[12]=0,s[13]=0,s[14]=i/(i-r),s[15]=1,this}orthoZO(t,e,i,r,s,a){let o=this.rawData,l=1/(t-e),h=1/(i-r),u=1/(s-a);return o[0]=-2*l,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=-2*h,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=u,o[11]=0,o[12]=(t+e)*l,o[13]=(r+i)*h,o[14]=s*u,o[15]=1,this}orthoOffCenter(t,e,i,r,s,a){let o=this.rawData;o[0]=2/(e-t),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(r-i),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(a-s),o[11]=0,o[12]=(t+e)/(t-e),o[13]=(r+i)/(i-r),o[14]=s/(s-a),o[15]=1}transformDir(t,e){let i=this.rawData,r=1e-6,s=p.ZERO;e.crossProduct(t,s);let a=e.dotProduct(t);if(a>1-r)this.identity();else{let o,l,h,u,c,d=s.dotProduct(s),f=(1-a)/d;o=f*s.x,l=f*s.z,h=o*s.y,u=o*s.z,c=l*s.y,i[0]=a+o*s.x,i[1]=h-s.z,i[2]=u+s.y,i[4]=h+s.z,i[5]=a+f*s.y*s.y,i[6]=c-s.x,i[8]=u-s.y,i[9]=c+s.x,i[10]=a+l*s.z,i[3]=0,i[7]=0,i[11]=0,i[15]=1}}append(t){let e=this.rawData,i=e[0],r=e[4],s=e[8],a=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],f=e[10],g=e[14],m=e[3],A=e[7],_=e[11],x=e[15];e[0]=i*t.rawData[0]+o*t.rawData[4]+c*t.rawData[8]+m*t.rawData[12],e[1]=i*t.rawData[1]+o*t.rawData[5]+c*t.rawData[9]+m*t.rawData[13],e[2]=i*t.rawData[2]+o*t.rawData[6]+c*t.rawData[10]+m*t.rawData[14],e[3]=i*t.rawData[3]+o*t.rawData[7]+c*t.rawData[11]+m*t.rawData[15],e[4]=r*t.rawData[0]+l*t.rawData[4]+d*t.rawData[8]+A*t.rawData[12],e[5]=r*t.rawData[1]+l*t.rawData[5]+d*t.rawData[9]+A*t.rawData[13],e[6]=r*t.rawData[2]+l*t.rawData[6]+d*t.rawData[10]+A*t.rawData[14],e[7]=r*t.rawData[3]+l*t.rawData[7]+d*t.rawData[11]+A*t.rawData[15],e[8]=s*t.rawData[0]+h*t.rawData[4]+f*t.rawData[8]+_*t.rawData[12],e[9]=s*t.rawData[1]+h*t.rawData[5]+f*t.rawData[9]+_*t.rawData[13],e[10]=s*t.rawData[2]+h*t.rawData[6]+f*t.rawData[10]+_*t.rawData[14],e[11]=s*t.rawData[3]+h*t.rawData[7]+f*t.rawData[11]+_*t.rawData[15],e[12]=a*t.rawData[0]+u*t.rawData[4]+g*t.rawData[8]+x*t.rawData[12],e[13]=a*t.rawData[1]+u*t.rawData[5]+g*t.rawData[9]+x*t.rawData[13],e[14]=a*t.rawData[2]+u*t.rawData[6]+g*t.rawData[10]+x*t.rawData[14],e[15]=a*t.rawData[3]+u*t.rawData[7]+g*t.rawData[11]+x*t.rawData[15]}add(t){let e=this.rawData,i=e[0],r=e[4],s=e[8],a=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],f=e[10],g=e[14],m=e[3],A=e[7],_=e[11],x=e[15],b=t.rawData[0],R=t.rawData[4],E=t.rawData[8],M=t.rawData[12],G=t.rawData[1],V=t.rawData[5],k=t.rawData[9],O=t.rawData[13],ce=t.rawData[2],we=t.rawData[6],Ce=t.rawData[10],be=t.rawData[14],De=t.rawData[3],Ee=t.rawData[7],he=t.rawData[11],_e=t.rawData[15];return e[0]=i+b,e[1]=o+G,e[2]=c+ce,e[3]=m+De,e[4]=r+R,e[5]=l+V,e[6]=d+we,e[7]=A+Ee,e[8]=s+E,e[9]=h+k,e[10]=f+Ce,e[11]=_+he,e[12]=a+M,e[13]=u+O,e[14]=g+be,e[15]=x+_e,this}sub(t){let e=this.rawData,i=e[0],r=e[4],s=e[8],a=e[12],o=e[1],l=e[5],h=e[9],u=e[13],c=e[2],d=e[6],f=e[10],g=e[14],m=e[3],A=e[7],_=e[11],x=e[15],b=t.rawData[0],R=t.rawData[4],E=t.rawData[8],M=t.rawData[12],G=t.rawData[1],V=t.rawData[5],k=t.rawData[9],O=t.rawData[13],ce=t.rawData[2],we=t.rawData[6],Ce=t.rawData[10],be=t.rawData[14],De=t.rawData[3],Ee=t.rawData[7],he=t.rawData[11],_e=t.rawData[15];return e[0]=i-b,e[1]=o-G,e[2]=c-ce,e[3]=m-De,e[4]=r-R,e[5]=l-V,e[6]=d-we,e[7]=A-Ee,e[8]=s-E,e[9]=h-k,e[10]=f-Ce,e[11]=_-he,e[12]=a-M,e[13]=u-O,e[14]=g-be,e[15]=x-_e,this}mult(t){let e=this.rawData;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[7]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e[11]*=t,e[12]*=t,e[13]*=t,e[14]*=t,e[15]*=t,this}appendRotation(t,e){let i=Z.getAxisRotation(e.x,e.y,e.z,t);this.append(i)}createByRotation(t,e){let i=Z.helpMatrix,r,s,a=t*We;r=Math.sin(a),s=Math.cos(a),e.x==1&&(i.rawData[0]=1,i.rawData[1]=0,i.rawData[2]=0,i.rawData[3]=0,i.rawData[4]=0,i.rawData[5]=s,i.rawData[6]=r,i.rawData[7]=0,i.rawData[8]=0,i.rawData[9]=-r,i.rawData[10]=s,i.rawData[11]=0,i.rawData[12]=0,i.rawData[13]=0,i.rawData[14]=0,i.rawData[15]=1),e.y==1&&(i.rawData[0]=s,i.rawData[1]=0,i.rawData[2]=-r,i.rawData[3]=0,i.rawData[4]=0,i.rawData[5]=1,i.rawData[6]=0,i.rawData[7]=0,i.rawData[8]=r,i.rawData[9]=0,i.rawData[10]=s,i.rawData[11]=0,i.rawData[12]=0,i.rawData[13]=0,i.rawData[14]=0,i.rawData[15]=1),e.z==1&&(i.rawData[0]=s,i.rawData[1]=r,i.rawData[2]=0,i.rawData[3]=0,i.rawData[4]=-r,i.rawData[5]=s,i.rawData[6]=0,i.rawData[7]=0,i.rawData[8]=0,i.rawData[9]=0,i.rawData[10]=1,i.rawData[11]=0,i.rawData[12]=0,i.rawData[13]=0,i.rawData[14]=0,i.rawData[15]=1),this.append(i)}appendScale(t,e,i){Z.helpMatrix.createByScale(t,e,i),this.append(Z.helpMatrix)}createByScale(t,e,i){let r=this.rawData;r[0]=t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=i,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1}appendTranslation(t,e,i){let r=this.rawData;r[12]+=t,r[13]+=e,r[14]+=i}clone(){let t=new Z;return t.copyFrom(this),t}copyRowFrom(t,e){let i=this.rawData;switch(t){case 0:i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w;break;case 1:i[4]=e.x,i[5]=e.y,i[6]=e.z,i[7]=e.w;break;case 2:i[8]=e.x,i[9]=e.y,i[10]=e.z,i[11]=e.w;break;case 3:i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=e.w;break}}copyRowTo(t,e){let i=this.rawData;switch(t){case 0:e.x=i[0],e.y=i[1],e.z=i[2],e.w=i[3];break;case 1:e.x=i[4],e.y=i[5],e.z=i[6],e.w=i[7];break;case 2:e.x=i[8],e.y=i[9],e.z=i[10],e.w=i[11];break;case 3:e.x=i[12],e.y=i[13],e.z=i[14],e.w=i[15];break}}copyFrom(t){let e=this.rawData;return e[0]=t.rawData[0],e[1]=t.rawData[1],e[2]=t.rawData[2],e[3]=t.rawData[3],e[4]=t.rawData[4],e[5]=t.rawData[5],e[6]=t.rawData[6],e[7]=t.rawData[7],e[8]=t.rawData[8],e[9]=t.rawData[9],e[10]=t.rawData[10],e[11]=t.rawData[11],e[12]=t.rawData[12],e[13]=t.rawData[13],e[14]=t.rawData[14],e[15]=t.rawData[15],this}copyRawDataTo(t,e=0,i=!1){let r=this.rawData;t[0+e]=r[0],t[1+e]=r[1],t[2+e]=r[2],t[3+e]=r[3],t[4+e]=r[4],t[5+e]=r[5],t[6+e]=r[6],t[7+e]=r[7],t[8+e]=r[8],t[9+e]=r[9],t[10+e]=r[10],t[11+e]=r[11],t[12+e]=r[12],t[13+e]=r[13],t[14+e]=r[14],t[15+e]=r[15]}copyColFrom(t,e){let i=this.rawData;switch(t){case 0:i[0]=e.x,i[4]=e.y,i[8]=e.z,i[12]=e.w;break;case 1:i[1]=e.x,i[5]=e.y,i[9]=e.z,i[13]=e.w;break;case 2:i[2]=e.x,i[6]=e.y,i[10]=e.z,i[14]=e.w;break;case 3:i[3]=e.x,i[7]=e.y,i[11]=e.z,i[15]=e.w;break}}copyColTo(t,e){let i=this.rawData;switch(t){case 0:e.x=i[0],e.y=i[4],e.z=i[8],e.w=i[12];break;case 1:e.x=i[1],e.y=i[5],e.z=i[9],e.w=i[13];break;case 2:e.x=i[2],e.y=i[6],e.z=i[10],e.w=i[14];break;case 3:e.x=i[3],e.y=i[7],e.z=i[11],e.w=i[15];break}}copyToMatrix3D(t){t.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(t){return this.compose(Z._zero,t,Z._one),this}decompose(t="eulerAngles",e){let i=ye.CALCULATION_QUATERNION,r=e||Z._prs;this.copyRawDataTo(Z.decomposeRawData);let s=Z.decomposeRawData,a=r[0];a.x=s[12],a.y=s[13],a.z=s[14],s[12]=0,s[13]=0,s[14]=0;let o=r[2];o.x=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]),o.y=Math.sqrt(s[4]*s[4]+s[5]*s[5]+s[6]*s[6]),o.z=Math.sqrt(s[8]*s[8]+s[9]*s[9]+s[10]*s[10]),s[0]*(s[5]*s[10]-s[6]*s[9])-s[1]*(s[4]*s[10]-s[6]*s[8])+s[2]*(s[4]*s[9]-s[5]*s[8])<0&&(o.z=-o.z),s[0]/=o.x,s[1]/=o.x,s[2]/=o.x,s[4]/=o.y,s[5]/=o.y,s[6]/=o.y,s[8]/=o.z,s[9]/=o.z,s[10]/=o.z;let l=r[1],h;switch(t){case ki.AXIS_ANGLE:l.w=Math.acos((s[0]+s[5]+s[10]-1)/2);let u=Math.sqrt((s[6]-s[9])*(s[6]-s[9])+(s[8]-s[2])*(s[8]-s[2])+(s[1]-s[4])*(s[1]-s[4]));l.x=(s[6]-s[9])/u,l.y=(s[8]-s[2])/u,l.z=(s[1]-s[4])/u;break;case ki.QUATERNION:h=s[0]+s[5]+s[10],h>0?(l.w=Math.sqrt(1+h)/2,l.x=(s[6]-s[9])/(4*l.w),l.y=(s[8]-s[2])/(4*l.w),l.z=(s[1]-s[4])/(4*l.w)):s[0]>s[5]&&s[0]>s[10]?(l.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,l.w=(s[6]-s[9])/(4*l.x),l.y=(s[1]+s[4])/(4*l.x),l.z=(s[8]+s[2])/(4*l.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,l.x=(s[1]+s[4])/(4*l.y),l.w=(s[8]-s[2])/(4*l.y),l.z=(s[6]+s[9])/(4*l.y)):(l.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,l.x=(s[8]+s[2])/(4*l.z),l.y=(s[6]+s[9])/(4*l.z),l.w=(s[1]-s[4])/(4*l.z));break;case ki.EULER_ANGLES:h=s[0]+s[5]+s[10],h>0?(i.w=Math.sqrt(1+h)/2,i.x=(s[6]-s[9])/(4*i.w),i.y=(s[8]-s[2])/(4*i.w),i.z=(s[1]-s[4])/(4*i.w)):s[0]>s[5]&&s[0]>s[10]?(i.x=Math.sqrt(1+s[0]-s[5]-s[10])/2,i.w=(s[6]-s[9])/(4*i.x),i.y=(s[1]+s[4])/(4*i.x),i.z=(s[8]+s[2])/(4*i.x)):s[5]>s[10]?(l.y=Math.sqrt(1+s[5]-s[0]-s[10])/2,i.x=(s[1]+s[4])/(4*i.y),i.w=(s[8]-s[2])/(4*i.y),i.z=(s[6]+s[9])/(4*i.y)):(i.z=Math.sqrt(1+s[10]-s[0]-s[5])/2,i.x=(s[8]+s[2])/(4*i.z),i.y=(s[6]+s[9])/(4*i.z),i.w=(s[1]-s[4])/(4*i.z)),i.getEulerAngles(l);break}return r[0]=a,r[1]=l,r[2]=o,r}static getEuler(t,e,i=!0,r){return t||(t=new p),Z._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(t,i,r),t}compose(t,e,i){const r=this.rawData,s=e.x,a=e.y,o=e.z,l=e.w,h=s+s,u=a+a,c=o+o,d=s*h,f=s*u,g=s*c,m=a*u,A=a*c,_=o*c,x=l*h,b=l*u,R=l*c,E=i.x,M=i.y,G=i.z;return r[0]=(1-(m+_))*E,r[1]=(f+R)*E,r[2]=(g-b)*E,r[3]=0,r[4]=(f-R)*M,r[5]=(1-(d+_))*M,r[6]=(A+x)*M,r[7]=0,r[8]=(g+b)*G,r[9]=(A-x)*G,r[10]=(1-(d+m))*G,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}deltaTransformVector(t,e){e||(e=new p);let i=this.rawData,r=t.x,s=t.y,a=t.z;return e.x=r*i[0]+s*i[4]+a*i[8],e.y=r*i[1]+s*i[5]+a*i[9],e.z=r*i[2]+s*i[6]+a*i[10],e.w=r*i[3]+s*i[7]+a*i[11],e}identity(){let t=this.rawData;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}fill(t){let e=this.rawData;e[1]=t,e[2]=t,e[3]=t,e[4]=t,e[6]=t,e[7]=t,e[8]=t,e[9]=t,e[11]=t,e[12]=t,e[13]=t,e[14]=t,e[0]=t,e[5]=t,e[10]=t,e[15]=t}invers33(){let t=this.rawData,e=t[5]*t[10]-t[9]*t[6],i=t[8]*t[6]-t[4]*t[10],r=t[4]*t[9]-t[8]*t[5],s=t[9]*t[2]-t[1]*t[10],a=t[0]*t[10]-t[8]*t[2],o=t[8]*t[1]-t[0]*t[9],l=t[1]*t[6]-t[5]*t[2],h=t[4]*t[2]-t[0]*t[6],u=t[0]*t[5]-t[4]*t[1],c=t[0]*e+t[4]*s+t[8]*l;if(Math.abs(c)>1e-11){let d=1/c;t[0]=d*e,t[4]=d*i,t[8]=d*r,t[1]=d*s,t[5]=d*a,t[9]=d*o,t[2]=d*l,t[6]=d*h,t[10]=d*u}}invert(){let t=this.determinant,e=Math.abs(t)>1e-11,i=this.rawData;if(e){t=1/t;let r=i[0],s=i[4],a=i[8],o=i[12],l=i[1],h=i[5],u=i[9],c=i[13],d=i[2],f=i[6],g=i[10],m=i[14],A=i[3],_=i[7],x=i[11],b=i[15];i[0]=t*(h*(g*b-m*x)-u*(f*b-m*_)+c*(f*x-g*_)),i[1]=-t*(l*(g*b-m*x)-u*(d*b-m*A)+c*(d*x-g*A)),i[2]=t*(l*(f*b-m*_)-h*(d*b-m*A)+c*(d*_-f*A)),i[3]=-t*(l*(f*x-g*_)-h*(d*x-g*A)+u*(d*_-f*A)),i[4]=-t*(s*(g*b-m*x)-a*(f*b-m*_)+o*(f*x-g*_)),i[5]=t*(r*(g*b-m*x)-a*(d*b-m*A)+o*(d*x-g*A)),i[6]=-t*(r*(f*b-m*_)-s*(d*b-m*A)+o*(d*_-f*A)),i[7]=t*(r*(f*x-g*_)-s*(d*x-g*A)+a*(d*_-f*A)),i[8]=t*(s*(u*b-c*x)-a*(h*b-c*_)+o*(h*x-u*_)),i[9]=-t*(r*(u*b-c*x)-a*(l*b-c*A)+o*(l*x-u*A)),i[10]=t*(r*(h*b-c*_)-s*(l*b-c*A)+o*(l*_-h*A)),i[11]=-t*(r*(h*x-u*_)-s*(l*x-u*A)+a*(l*_-h*A)),i[12]=-t*(s*(u*m-c*g)-a*(h*m-c*f)+o*(h*g-u*f)),i[13]=t*(r*(u*m-c*g)-a*(l*m-c*d)+o*(l*g-u*d)),i[14]=-t*(r*(h*m-c*f)-s*(l*m-c*d)+o*(l*f-h*d)),i[15]=t*(r*(h*g-u*f)-s*(l*g-u*d)+a*(l*f-h*d))}return e}transformPoint(t,e){let i=this.rawData;e||(e=new p);let r=t.x,s=t.y,a=t.z;return e.x=r*i[0]+s*i[4]+a*i[8]+i[12],e.y=r*i[1]+s*i[5]+a*i[9]+i[13],e.z=r*i[2]+s*i[6]+a*i[10]+i[14],e}transformVector(t,e){let i=this.rawData;e||(e=new p);let r=t.x,s=t.y,a=t.z;return e.x=r*i[0]+s*i[4]+a*i[8],e.y=r*i[1]+s*i[5]+a*i[9],e.z=r*i[2]+s*i[6]+a*i[10],e}transpose(){let t=this.rawData;for(let e=0;e<Z.helpMatrix.rawData.length;e++)Z.helpMatrix.rawData[e]=t[e];t[1]=Z.helpMatrix.rawData[4],t[2]=Z.helpMatrix.rawData[8],t[3]=Z.helpMatrix.rawData[12],t[4]=Z.helpMatrix.rawData[1],t[6]=Z.helpMatrix.rawData[9],t[7]=Z.helpMatrix.rawData[13],t[8]=Z.helpMatrix.rawData[2],t[9]=Z.helpMatrix.rawData[6],t[11]=Z.helpMatrix.rawData[14],t[12]=Z.helpMatrix.rawData[3],t[13]=Z.helpMatrix.rawData[7],t[14]=Z.helpMatrix.rawData[11]}get determinant(){let t=this.rawData;return(t[0]*t[5]-t[4]*t[1])*(t[10]*t[15]-t[14]*t[11])-(t[0]*t[9]-t[8]*t[1])*(t[6]*t[15]-t[14]*t[7])+(t[0]*t[13]-t[12]*t[1])*(t[6]*t[11]-t[10]*t[7])+(t[4]*t[9]-t[8]*t[5])*(t[2]*t[15]-t[14]*t[3])-(t[4]*t[13]-t[12]*t[5])*(t[2]*t[11]-t[10]*t[3])+(t[8]*t[13]-t[12]*t[9])*(t[2]*t[7]-t[6]*t[3])}getPosition(t){t||(t=new p);let e=this.rawData;return t.x=e[12],t.y=e[13],t.z=e[14],t}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(t){let e=this.rawData;e[12]=t.x,e[13]=t.y,e[14]=t.z}get scale(){let t=this.rawData;return new p(t[0],t[5],t[10])}set scale(t){let e=this.rawData;e[0]=t.x,e[5]=t.y,e[10]=t.z}toString(){let t=this.rawData;return"matrix3d("+Math.round(t[0]*1e3)/1e3+","+Math.round(t[1]*1e3)/1e3+","+Math.round(t[2]*1e3)/1e3+","+Math.round(t[3]*1e3)/1e3+","+Math.round(t[4]*1e3)/1e3+","+Math.round(t[5]*1e3)/1e3+","+Math.round(t[6]*1e3)/1e3+","+Math.round(t[7]*1e3)/1e3+","+Math.round(t[8]*1e3)/1e3+","+Math.round(t[9]*1e3)/1e3+","+Math.round(t[10]*1e3)/1e3+","+Math.round(t[11]*1e3)/1e3+","+Math.round(t[12]*1e3)/1e3+","+Math.round(t[13]*1e3)/1e3+","+Math.round(t[14]*1e3)/1e3+","+Math.round(t[15]*1e3)/1e3+")"}lerp(t,e,i){this.copyFrom(e).sub(t).mult(i).add(t)}get(t,e){return this.rawData[t+e*4]}set(t,e,i){this.rawData[t+e*4]=i}getMaxScaleOnAxis(){let t=this.rawData,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,r))}translate(t){let e=this.get(0,0)*t.x+this.get(0,1)*t.y+this.get(0,2)*t.z+this.get(0,3),i=this.get(1,0)*t.x+this.get(1,1)*t.y+this.get(1,2)*t.z+this.get(1,3),r=this.get(2,0)*t.x+this.get(2,1)*t.y+this.get(2,2)*t.z+this.get(2,3),s=this.get(3,0)*t.x+this.get(3,1)*t.y+this.get(3,2)*t.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,i),this.set(2,3,r),this.set(3,3,s),this}setTRInverse(t,e){e=e.inverse(),ye.quaternionToMatrix(e,this),this.translate(new p(-t.x,-t.y,-t.z))}setScale(t){return this.set(0,0,t.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,t.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,t.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(t,e,i){return this.setElements(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),r=Math.sin(e),s=1-i,a=t.x,o=t.y,l=t.z,h=s*a,u=s*o;return this.setElements(h*a+i,h*o-r*l,h*l+r*o,0,h*o+r*l,u*o+i,u*l-r*a,0,h*l-r*o,u*l+r*a,s*l*l+i,0,0,0,0,1),this}static transpose(t,e){e||(e=new Z);let i=t.rawData,r=e.rawData;return r[0]=i[0],r[1]=i[4],r[2]=i[8],r[3]=i[12],r[4]=i[1],r[5]=i[5],r[6]=i[9],r[7]=i[13],r[8]=i[2],r[9]=i[6],r[10]=i[10],r[11]=i[14],r[12]=i[3],r[13]=i[7],r[14]=i[11],r[15]=i[15],e}static inverse(t,e){e||(e=new Z);let i=t.rawData,r=e.rawData;r[0]=i[5]*i[10]*i[15]-i[5]*i[14]*i[11]-i[6]*i[9]*i[15]+i[6]*i[13]*i[11]+i[7]*i[9]*i[14]-i[7]*i[13]*i[10],r[1]=-i[1]*i[10]*i[15]+i[1]*i[14]*i[11]+i[2]*i[9]*i[15]-i[2]*i[13]*i[11]-i[3]*i[9]*i[14]+i[3]*i[13]*i[10],r[2]=i[1]*i[6]*i[15]-i[1]*i[14]*i[7]-i[2]*i[5]*i[15]+i[2]*i[13]*i[7]+i[3]*i[5]*i[14]-i[3]*i[13]*i[6],r[3]=-i[1]*i[6]*i[11]+i[1]*i[10]*i[7]+i[2]*i[5]*i[11]-i[2]*i[9]*i[7]-i[3]*i[5]*i[10]+i[3]*i[9]*i[6],r[4]=-i[4]*i[10]*i[15]+i[4]*i[14]*i[11]+i[6]*i[8]*i[15]-i[6]*i[12]*i[11]-i[7]*i[8]*i[14]+i[7]*i[12]*i[10],r[5]=i[0]*i[10]*i[15]-i[0]*i[14]*i[11]-i[2]*i[8]*i[15]+i[2]*i[12]*i[11]+i[3]*i[8]*i[14]-i[3]*i[12]*i[10],r[6]=-i[0]*i[6]*i[15]+i[0]*i[14]*i[7]+i[2]*i[4]*i[15]-i[2]*i[12]*i[7]-i[3]*i[4]*i[14]+i[3]*i[12]*i[6],r[7]=i[0]*i[6]*i[11]-i[0]*i[10]*i[7]-i[2]*i[4]*i[11]+i[2]*i[8]*i[7]+i[3]*i[4]*i[10]-i[3]*i[8]*i[6],r[8]=i[4]*i[9]*i[15]-i[4]*i[13]*i[11]-i[5]*i[8]*i[15]+i[5]*i[12]*i[11]+i[7]*i[8]*i[13]-i[7]*i[12]*i[9],r[9]=-i[0]*i[9]*i[15]+i[0]*i[13]*i[11]+i[1]*i[8]*i[15]-i[1]*i[12]*i[11]-i[3]*i[8]*i[13]+i[3]*i[12]*i[9],r[10]=i[0]*i[5]*i[15]-i[0]*i[13]*i[7]-i[1]*i[4]*i[15]+i[1]*i[12]*i[7]+i[3]*i[4]*i[13]-i[3]*i[12]*i[5],r[11]=-i[0]*i[5]*i[11]+i[0]*i[9]*i[7]+i[1]*i[4]*i[11]-i[1]*i[8]*i[7]-i[3]*i[4]*i[9]+i[3]*i[8]*i[5],r[12]=-i[4]*i[9]*i[14]+i[4]*i[13]*i[10]+i[5]*i[8]*i[14]-i[5]*i[12]*i[10]-i[6]*i[8]*i[13]+i[6]*i[12]*i[9],r[13]=i[0]*i[9]*i[14]-i[0]*i[13]*i[10]-i[1]*i[8]*i[14]+i[1]*i[12]*i[10]+i[2]*i[8]*i[13]-i[2]*i[12]*i[9],r[14]=-i[0]*i[5]*i[14]+i[0]*i[13]*i[6]+i[1]*i[4]*i[14]-i[1]*i[12]*i[6]-i[2]*i[4]*i[13]+i[2]*i[12]*i[5],r[15]=i[0]*i[5]*i[10]-i[0]*i[9]*i[6]-i[1]*i[4]*i[10]+i[1]*i[8]*i[6]+i[2]*i[4]*i[9]-i[2]*i[8]*i[5];let s=i[0]*r[0]+i[1]*r[4]+i[2]*r[8]+i[3]*r[12];for(let a=0;a<16;a++)r[a]/=s;return e}makeEuler(t,e,i="XYZ"){const r=this.rawData,s=r[0],a=r[4],o=r[8],l=r[1],h=r[5],u=r[9],c=r[2],d=r[6],f=r[10];switch(i){case"XYZ":t.y=Math.asin(ni(o,-1,1)),Math.abs(o)<.9999999?(t.x=Math.atan2(-u,f),t.z=Math.atan2(-a,s)):(t.x=Math.atan2(d,h),t.z=0);break;case"YXZ":t.x=Math.asin(-ni(u,-1,1)),Math.abs(u)<.9999999?(t.y=Math.atan2(o,f),t.z=Math.atan2(l,h)):(t.y=Math.atan2(-c,s),t.z=0);break;case"ZXY":t.x=Math.asin(ni(d,-1,1)),Math.abs(d)<.9999999?(t.y=Math.atan2(-c,f),t.z=Math.atan2(-a,h)):(t.y=0,t.z=Math.atan2(l,s));break;case"ZYX":t.y=Math.asin(-ni(c,-1,1)),Math.abs(c)<.9999999?(t.x=Math.atan2(d,f),t.z=Math.atan2(l,s)):(t.x=0,t.z=Math.atan2(-a,h));break;case"YZX":t.z=Math.asin(ni(l,-1,1)),Math.abs(l)<.9999999?(t.x=Math.atan2(-u,h),t.y=Math.atan2(-c,s)):(t.x=0,t.y=Math.atan2(o,f));break;case"XZY":t.z=Math.asin(-ni(a,-1,1)),Math.abs(a)<.9999999?(t.x=Math.atan2(d,h),t.y=Math.atan2(o,s)):(t.x=Math.atan2(-u,f),t.y=0);break}return e&&t.multiplyScalar(nn),t}setElements(t,e,i,r,s,a,o,l,h,u,c,d,f,g,m,A){const _=this.rawData;return _[0]=t,_[4]=e,_[8]=i,_[12]=r,_[1]=s,_[5]=a,_[9]=o,_[13]=l,_[2]=h,_[6]=u,_[10]=c,_[14]=d,_[3]=f,_[7]=g,_[11]=m,_[15]=A,this}makeMatrix44ByQuaternion(t,e,i){this.identity(),ye.quaternionToMatrix(i,this),this.appendTranslation(t.x,t.y,t.z),this.appendScale(e.x,e.y,e.z)}};let te=Z;n(te,"blockBytes",16*4),n(te,"block",16),n(te,"allocCount",1e3),n(te,"allocOnceCount",1e3),n(te,"maxCount",50*1e4),n(te,"useCount",0),n(te,"buffer"),n(te,"wasmMatrixPtr",0),n(te,"dynamicMatrixBytes"),n(te,"dynamicGlobalMatrixRef"),n(te,"wasm"),n(te,"help_matrix_0"),n(te,"help_matrix_1"),n(te,"help_matrix_2"),n(te,"helpMatrix"),n(te,"helpMatrix2"),n(te,"_getEulerMatrix"),n(te,"_zero",new p(0,0,0)),n(te,"_one",new p(1,1,1)),n(te,"_prs",[new p,new p,new p]),n(te,"float32Array",new Float32Array(16).fill(0)),n(te,"decomposeRawData",new Float32Array(16).fill(0));function Cv(t,e,i){for(let r=0;r<4;r++)i.rawData[r]=t.rawData[r]*e.rawData[0]+t.rawData[r+4]*e.rawData[1]+t.rawData[r+8]*e.rawData[2]+t.rawData[r+12]*e.rawData[3],i.rawData[r+4]=t.rawData[r]*e.rawData[4]+t.rawData[r+4]*e.rawData[5]+t.rawData[r+8]*e.rawData[6]+t.rawData[r+12]*e.rawData[7],i.rawData[r+8]=t.rawData[r]*e.rawData[8]+t.rawData[r+4]*e.rawData[9]+t.rawData[r+8]*e.rawData[10]+t.rawData[r+12]*e.rawData[11],i.rawData[r+12]=t.rawData[r]*e.rawData[12]+t.rawData[r+4]*e.rawData[13]+t.rawData[r+8]*e.rawData[14]+t.rawData[r+12]*e.rawData[15]}function Dl(t,e,i,r){let s=r.rawData,a=t.x*We,o=t.y*We,l=t.z*We,h=0,u=a*.5,c=o*.5,d=l*.5,f=Math.cos(u),g=Math.sin(u),m=Math.cos(c),A=Math.sin(c),_=Math.cos(d),x=Math.sin(d);h=f*m*_+g*A*x,a=g*m*_-f*A*x,o=f*A*_+g*m*x,l=f*m*x-g*A*_;let b=a+a,R=o+o,E=l+l,M=a*b,G=a*R,V=a*E,k=o*R,O=o*E,ce=l*E,we=h*b,Ce=h*R,be=h*E,De=i.x,Ee=i.y,he=i.z;s[0]=(1-(k+ce))*De,s[1]=(G+be)*De,s[2]=(V-Ce)*De,s[3]=0,s[4]=(G-be)*Ee,s[5]=(1-(M+ce))*Ee,s[6]=(O+we)*Ee,s[7]=0,s[8]=(V+Ce)*he,s[9]=(O-we)*he,s[10]=(1-(M+k))*he,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1}function bv(t,e,i){let r=t.rawData,s=i.rawData,a=r[0],o=r[4],l=r[8],h=r[12],u=r[1],c=r[5],d=r[9],f=r[13],g=r[2],m=r[6],A=r[10],_=r[14],x=r[3],b=r[7],R=r[11],E=r[15];s[0]=a*e.rawData[0]+u*e.rawData[4]+g*e.rawData[8]+x*e.rawData[12],s[1]=a*e.rawData[1]+u*e.rawData[5]+g*e.rawData[9]+x*e.rawData[13],s[2]=a*e.rawData[2]+u*e.rawData[6]+g*e.rawData[10]+x*e.rawData[14],s[3]=a*e.rawData[3]+u*e.rawData[7]+g*e.rawData[11]+x*e.rawData[15],s[4]=o*e.rawData[0]+c*e.rawData[4]+m*e.rawData[8]+b*e.rawData[12],s[5]=o*e.rawData[1]+c*e.rawData[5]+m*e.rawData[9]+b*e.rawData[13],s[6]=o*e.rawData[2]+c*e.rawData[6]+m*e.rawData[10]+b*e.rawData[14],s[7]=o*e.rawData[3]+c*e.rawData[7]+m*e.rawData[11]+b*e.rawData[15],s[8]=l*e.rawData[0]+d*e.rawData[4]+A*e.rawData[8]+R*e.rawData[12],s[9]=l*e.rawData[1]+d*e.rawData[5]+A*e.rawData[9]+R*e.rawData[13],s[10]=l*e.rawData[2]+d*e.rawData[6]+A*e.rawData[10]+R*e.rawData[14],s[11]=l*e.rawData[3]+d*e.rawData[7]+A*e.rawData[11]+R*e.rawData[15],s[12]=h*e.rawData[0]+f*e.rawData[4]+_*e.rawData[8]+E*e.rawData[12],s[13]=h*e.rawData[1]+f*e.rawData[5]+_*e.rawData[9]+E*e.rawData[13],s[14]=h*e.rawData[2]+f*e.rawData[6]+_*e.rawData[10]+E*e.rawData[14],s[15]=h*e.rawData[3]+f*e.rawData[7]+_*e.rawData[11]+E*e.rawData[15]}function pc(t,e,i){let r=t.rawData,s=r[0],a=r[1],o=r[2],l=r[3],h=r[4],u=r[5],c=r[6],d=r[7],f=r[8],g=r[9],m=r[10],A=r[11],_=r[12],x=r[13],b=r[14],R=r[15],E=e.rawData,M=i.rawData,G=E[0],V=E[1],k=E[2],O=E[3];return M[0]=G*s+V*h+k*f+O*_,M[1]=G*a+V*u+k*g+O*x,M[2]=G*o+V*c+k*m+O*b,M[3]=G*l+V*d+k*A+O*R,G=E[4],V=E[5],k=E[6],O=E[7],M[4]=G*s+V*h+k*f+O*_,M[5]=G*a+V*u+k*g+O*x,M[6]=G*o+V*c+k*m+O*b,M[7]=G*l+V*d+k*A+O*R,G=E[8],V=E[9],k=E[10],O=E[11],M[8]=G*s+V*h+k*f+O*_,M[9]=G*a+V*u+k*g+O*x,M[10]=G*o+V*c+k*m+O*b,M[11]=G*l+V*d+k*A+O*R,G=E[12],V=E[13],k=E[14],O=E[15],M[12]=G*s+V*h+k*f+O*_,M[13]=G*a+V*u+k*g+O*x,M[14]=G*o+V*c+k*m+O*b,M[15]=G*l+V*d+k*A+O*R,M}var dt=(t=>(t[t.None=0]="None",t[t.PointLight=1]="PointLight",t[t.DirectionLight=2]="DirectionLight",t[t.SpotLight=3]="SpotLight",t[t.SkyLight=4]="SkyLight",t))(dt||{});class $n extends nr{constructor(){super(...arguments),n(this,"index",-1),n(this,"lightType",-1),n(this,"radius",.5),n(this,"linear",1),n(this,"lightPosition",new p),n(this,"lightMatrixIndex",-1),n(this,"direction",new p),n(this,"quadratic",.032),n(this,"lightColor",new Y(1,1,1,1)),n(this,"intensity",1),n(this,"innerAngle",0),n(this,"outerAngle",1),n(this,"range",100),n(this,"castShadowIndex",-1),n(this,"lightTangent",p.FORWARD),n(this,"iesIndex",-1)}}n($n,"lightSize",24);const Df=class{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(t,e,i){this.init();let r=this.componentsUpdateList.get(t);r||(r=new Map,this.componentsUpdateList.set(t,r)),r.set(e,i)}static unBindUpdate(t,e){this.init();let i=this.componentsUpdateList.get(t);i&&i.delete(e)}static bindLateUpdate(t,e,i){this.init();let r=this.componentsLateUpdateList.get(t);r||(r=new Map,this.componentsLateUpdateList.set(t,r)),r.set(e,i)}static unBindLateUpdate(t,e){this.init();let i=this.componentsLateUpdateList.get(t);i&&i.delete(e)}static bindBeforeUpdate(t,e,i){this.init();let r=this.componentsBeforeUpdateList.get(t);r||(r=new Map,this.componentsBeforeUpdateList.set(t,r)),r.set(e,i)}static unBindBeforeUpdate(t,e){this.init();let i=this.componentsBeforeUpdateList.get(t);i&&i.delete(e)}static bindCompute(t,e,i){this.init();let r=this.componentsComputeList.get(t);r||(r=new Map,this.componentsComputeList.set(t,r)),r.set(e,i)}static unBindCompute(t,e){this.init();let i=this.componentsComputeList.get(t);i&&i.delete(e)}static bindGraphic(t,e,i){this.init();let r=this.graphicComponent.get(t);r||(r=new Map,this.graphicComponent.set(t,r)),r.set(e,i)}static unBindGraphic(t,e){this.init();let i=this.graphicComponent.get(t);i&&i.delete(e)}static appendWaitStart(t){this.init();let e=this.waitStartComponent.get(t.object3D);e?e.indexOf(t)==-1&&e.push(t):this.waitStartComponent.set(t.object3D,[t])}static removeWaitStart(t,e){this.init();let i=Df.waitStartComponent.get(t);if(i){let r=i.indexOf(e);r!=-1&&i.splice(r)}}static bindEnablePick(t,e,i){this.init();let r=this.componentsEnablePickerList.get(t);r||(r=new Map,this.componentsEnablePickerList.set(t,r)),r.set(e,i)}static unBindEnablePick(t,e){this.init();let i=this.componentsEnablePickerList.get(t);i&&i.delete(e)}};let Oe=Df;n(Oe,"componentsUpdateList"),n(Oe,"componentsLateUpdateList"),n(Oe,"componentsBeforeUpdateList"),n(Oe,"componentsComputeList"),n(Oe,"componentsEnablePickerList"),n(Oe,"graphicComponent"),n(Oe,"waitStartComponent"),n(Oe,"_init",!1);class Zt{constructor(){n(this,"object3D",null),n(this,"_eventDispatcher"),n(this,"_enable",!0),n(this,"__isStart",!1),n(this,"isDestroyed")}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new Ur),this._eventDispatcher}set eventDispatcher(e){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(e){var i,r;this._enable!=e&&(this._enable=e,this._enable?(i=this.onEnable)==null||i.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(e){this.init(e)}__start(){var e,i;this.transform&&this.transform.scene3D&&this._enable&&((e=this.onEnable)==null||e.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((i=this.start)==null||i.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var e;this.transform&&this.transform.scene3D&&((e=this.onDisable)==null||e.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(e){}start(){}stop(){}cloneTo(e){}copyComponent(e){return this}_onUpdate(e){e!=null?Oe.bindUpdate(this.transform.view3D,this,e):Oe.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(e){e!=null?Oe.bindLateUpdate(this.transform.view3D,this,e):Oe.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(e){e!=null?Oe.bindBeforeUpdate(this.transform.view3D,this,e):Oe.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(e){e!=null?Oe.bindCompute(this.transform.view3D,this,e):Oe.unBindCompute(this.transform.view3D,this)}_onGraphic(e){e!=null?Oe.bindGraphic(this.transform.view3D,this,e):Oe.unBindGraphic(this.transform.view3D,this)}beforeDestroy(e){Oe.removeWaitStart(this.object3D,this)}destroy(e){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class jo{constructor(){n(this,"value",0),n(this,"inv_base",0)}static get(e,i){let r=0,s=1/i;for(;e>0;)r+=e%i*s,e/=i,s/=i;return r}getBase(e,i){let r=this.inv_base=1/i;for(;e>0;)this.value+=r*(e%i),e/=i,r*=this.inv_base}next(){let e=1-this.value-1e-7;if(this.inv_base<e)this.value+=this.inv_base;else{let i=this.inv_base,r;do r=i,i*=this.inv_base;while(i>=e);this.value+=r+i-1}}get(){return this.value}}const Ss=class{constructor(t,e){n(this,"origin",new p),n(this,"length",Number.MAX_VALUE),n(this,"_vector",new p),n(this,"_dir",new p),n(this,"_v0",new p),n(this,"_v1",new p),n(this,"_v2",new p),n(this,"_E1",new p),n(this,"_E2",new p),n(this,"_P",new p),n(this,"_T",new p),n(this,"_Q",new p),this.origin.copyFrom(t||new p),this._dir.copyFrom(e||new p),this._dir.normalize()}get direction(){return this._dir}set direction(t){this._dir.copyFrom(t),this._dir.normalize()}clone(){return new Ss(this.origin,this.direction)}intersectBox(t,e){let i=this.direction,r=this.origin,s,a,o,l,h,u;const c=1/i.x,d=1/i.y,f=1/i.z,g=t.min,m=t.max;return s=((c>=0?g.x:m.x)-r.x)*c,a=((c>=0?m.x:g.x)-r.x)*c,o=((d>=0?g.y:m.y)-r.y)*d,l=((d>=0?m.y:g.y)-r.y)*d,s>l||o>a||(o>s&&(s=o),l<a&&(a=l),h=((f>=0?g.z:m.z)-r.z)*f,u=((f>=0?m.z:g.z)-r.z)*f,s>u||h>a)||(h>s&&(s=h),u<a&&(a=u),a<0)?null:(e||(e=new p),this.pointAt(s>=0?s:a,e))}pointAt(t,e){return e||(e=new p),e.copy(this.direction),e.multiplyScalar(t),e.add(this.origin,e),e}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this._dir.copy(t._dir),this.length=t.length,this}setApproxDirection(t){this._dir=t.normalize()}setOrigin(t){this.origin.copyFrom(t)}getOrigin(){return this.origin}getPoint(t){return this._dir.scaleBy(t),this.origin.add(this._dir)}sqrDistToPoint(t){let e=this._dir,i=t.subtract(this.origin),r=ri(i,e),s=ri(e,e),a=r/s,o=this.getPoint(a);return yv(t.subtract(o))}applyMatrix(t){this.origin=t.transformPoint(this.origin),this._dir=t.transformVector(this._dir)}pointInTriangle(t,e,i,r){let s=this._v0,a=this._v1,o=this._v2;r.subtract(e,s),i.subtract(e,a),t.subtract(e,o);let l=p.dot(s,s),h=p.dot(s,a),u=p.dot(s,o),c=p.dot(a,a),d=p.dot(a,o),f=1/(l*c-h*h),g=(c*u-h*d)*f,m=(l*d-h*u)*f;return g>=0&&m>=0&&g+m<1}intersectTriangle(t,e,i){let r=i.v1,s=i.v2,a=i.v3;s.subtract(r,this._E1),a.subtract(r,this._E2),e.crossProduct(this._E2,this._P);let o=this._E1.dotProduct(this._P);if(o>0?t.subtract(r,this._T):(r.subtract(t,this._T),o=-o),o<1e-4||(i.u=this._T.dotProduct(this._P),i.u<0||i.u>o)||(this._T.crossProduct(this._E1,this._Q),i.v=e.dotProduct(this._Q),i.v<0||i.u+i.v>o))return null;let l=new p;i.t0=i.t=this._E2.dotProduct(this._Q);let h=1/o;return i.t*=h,i.u*=h,i.v*=h,l.x=t.x+i.t*e.x,l.y=t.y+i.t*e.y,l.z=t.z+i.t*e.z,l}intersectSphere(t,e,i,r){let s=t.subtract(i),a=p.dot(e,e),o=2*p.dot(s,e),l=p.dot(s,s)-r*r,h=o*o-4*a*l,u=p.HELP_3;if(h<0)return null;{let c=(-o-Math.sqrt(h))/(a*2);return c<0?null:(u.x=t.x+c*e.x,u.y=t.y+c*e.y,u.z=t.z+c*e.z,u)}}intersectionSegment(t,e,i){const r=this.origin,s=p.HELP_0,a=p.HELP_1,o=p.HELP_2,l=p.HELP_3;e.subtract(t,s),this._dir.scaleToRef(Ss._rayl,o),r.add(o,a),t.subtract(r,l);var h=p.dot(s,s),u=p.dot(s,o),c=p.dot(o,o),d=p.dot(s,l),f=p.dot(o,l),g=h*c-u*u,m,A,_=g,x,b,R=g;g<Ss._smallnum?(A=0,_=1,b=f,R=c):(A=u*f-c*d,b=h*f-u*d,A<0?(A=0,b=f,R=c):A>_&&(A=_,b=f+u,R=c)),b<0?(b=0,-d<0?A=0:-d>h?A=_:(A=-d,_=h)):b>R&&(b=R,-d+u<0?A=0:-d+u>h?A=_:(A=-d+u,_=h)),m=Math.abs(A)<Ss._smallnum?0:A/_,x=Math.abs(b)<Ss._smallnum?0:b/R;const E=p.HELP_4;o.scaleToRef(x,E);const M=p.HELP_5;s.scaleToRef(m,M),M.add(l,M);const G=p.HELP_6;M.subtract(E,G);var V=x>0&&x<=this._dir.length&&G.lengthSquared<i*i;if(V){let k=new p;return k.copyFrom(e.subtract(t)),k.scaleBy(m),k.add(t,k),{out:k,length:M.length}}return{out:null,length:-1}}get_vec(t,e){let i=p.HELP_1;return i.x=t.x-e.x,i.y=t.y-e.y,i.z=t.z-e.z,i}};let fs=Ss;n(fs,"_rayl",1e9),n(fs,"_smallnum",1e-8);class eo{constructor(e=0,i=0,r=0,s=0){n(this,"x"),n(this,"y"),n(this,"w"),n(this,"h"),this.x=e,this.y=i,this.w=r,this.h=s}get width(){return this.w}set width(e){this.w=e}get height(){return this.h}set height(e){this.h=e}static pointInRect(e,i,r,s,a,o){return!(e<r||e>a||i<s||i>o)}clone(){return new eo(this.x,this.y,this.w,this.h)}copyFrom(e){this.x=e.x,this.y=e.y,this.w=e.w,this.h=e.h}copyTo(e){e.copyFrom(this)}inner(e,i){return!(e<this.x||e>this.x+this.width||i<this.y||i>this.y+this.height)}equal(e){return!(this.x!=e.x||this.y!=e.y||this.width!=e.width||this.height!=e.height)}equalArea(e,i,r,s){return!(this.x!=e||this.y!=i||this.width!=r||this.height!=s)}equalInnerArea(e){var i=this.x,r=this.y,s=this.x+this.width,a=this.y+this.height,o=e.x,l=e.y,h=e.x+e.width,u=e.y+e.height;return Math.max(i,o)<=Math.min(s,h)&&Math.max(r,l)<=Math.min(a,u)}innerArea(e,i){i=i||new eo;var r=this.x,s=this.y,a=this.x+this.width,o=this.y+this.height,l=e.x,h=e.y,u=e.x+e.width,c=e.y+e.height,d=Math.max(s,h),f=Math.min(o,c),g=Math.max(r,l),m=Math.min(u,a);return d>=0&&f>=0&&f-d>=0&&m-g>0?(i.x=g,i.y=d,i.width=m-g,i.height=f-d):(i.x=0,i.y=0,i.width=0,i.height=0),i}setTo(e,i,r,s){this.x=e,this.y=i,this.width=r,this.height=s}}const _a=class{constructor(t,e){n(this,"center"),n(this,"extents"),n(this,"max"),n(this,"min"),n(this,"size"),t||(t=p.ZERO.clone()),e||(e=p.ZERO.clone()),this.setFromCenterAndSize(t,e)}makeEmpty(){return this.setFromMinMax(_a.maxVector3,_a.minVector3),this}setFromMinMax(t,e){return this.init(),e.subtract(t,this.size),t.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(t),this.max.copyFrom(e),this}init(){return this.min||(this.min=new p),this.max||(this.max=new p),this.size||(this.size=new p),this.center||(this.center=new p),this.extents||(this.extents=new p),this}setFromCenterAndSize(t,e){return this.size=e,this.center=t,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(t,e){return e.containsBox(t.bound)}merge(t){t.min.x<this.min.x&&(this.min.x=t.min.x),t.min.y<this.min.y&&(this.min.y=t.min.y),t.min.z<this.min.z&&(this.min.z=t.min.z),t.max.x>this.max.x&&(this.max.x=t.max.x),t.max.y>this.max.y&&(this.max.y=t.max.y),t.max.z>this.max.z&&(this.max.z=t.max.z),this.size.x=t.max.x-t.min.x,this.size.y=t.max.y-t.min.y,this.size.z=t.max.z-t.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+t.min.x,this.center.y=this.extents.y+t.min.y,this.center.z=this.extents.z+t.min.z}intersects(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsSphere(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsBox(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}equals(t){return this.center.equals(t.center)&&this.extents.equals(t.extents)}expandByPoint(t){t.x<this.min.x&&(this.min.x=t.x),t.x>this.max.x&&(this.max.x=t.x),t.y<this.min.y&&(this.min.y=t.y),t.y>this.max.y&&(this.max.y=t.y),t.z<this.min.z&&(this.min.z=t.z),t.z>this.max.z&&(this.max.z=t.z)}static fromPoints(t){for(var e=new _a(new p,new p),i=0;i<t.length;i++)e.expandByPoint(t[i]);return e}calculateTransform(t){}clone(){var t=new _a(this.center.clone(),this.size.clone());return t}intersectsRay(t,e){throw new Error("Method not implemented.")}containsPoint(t){return this.min.x<=t.x&&this.max.x>=t.x&&this.min.y<=t.y&&this.max.y>=t.y&&this.min.z<=t.z&&this.max.z>=t.z}containsBox(t){let e=this.min,i=this.max;return e.x<=t.min.x&&e.y<=t.min.y&&e.z<=t.min.z&&i.x>=t.max.x&&i.y>=t.max.y&&i.z>=t.max.z}updateBound(){}destroy(t){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};let _t=_a;n(_t,"maxVector3",new p(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),n(_t,"minVector3",new p(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));class Iv{constructor(){n(this,"planes"),n(this,"corners"),n(this,"boundingBox",new _t),this.planes=[],this.corners=[];for(var e=0;e<6;e++)this.planes[e]=new p;for(var e=0;e<2*2*2;e++)this.corners[e]=new p}updateBoundBox(e){this.boundingBox.makeEmpty();let i=this.boundingBox.min,r=this.boundingBox.max,s=0;for(let a=0;a<2;++a)for(let o=0;o<2;++o)for(let l=0;l<2;++l){let h=this.corners[s];s++,h.set(2*a-1,2*o-1,l,1),e.transformVector4(h,h),h.div(h.w,h),i.x=Math.min(h.x,i.x),i.y=Math.min(h.y,i.y),i.z=Math.min(h.z,i.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(i,r),this}setFrustumCorners(e){let i=0;for(let r=0;r<2;++r)for(let s=0;s<2;++s)for(let a=0;a<2;++a){let o=this.corners[i];o.set(2*r-1,2*s-1,a,1),e.transformVector4(o,o),o.div(o.w,o),i++}}update(e){var i=e.rawData;this.planes[0].x=i[3]-i[0],this.planes[0].y=i[7]-i[4],this.planes[0].z=i[11]-i[8],this.planes[0].w=i[15]-i[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=i[3]+i[0],this.planes[1].y=i[7]+i[4],this.planes[1].z=i[11]+i[8],this.planes[1].w=i[15]+i[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=i[3]+i[1],this.planes[2].y=i[7]+i[5],this.planes[2].z=i[11]+i[9],this.planes[2].w=i[15]+i[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=i[3]-i[1],this.planes[3].y=i[7]-i[5],this.planes[3].z=i[11]-i[9],this.planes[3].w=i[15]-i[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=i[3]-i[2],this.planes[4].y=i[7]-i[6],this.planes[4].z=i[11]-i[10],this.planes[4].w=i[15]-i[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=i[3]+i[2],this.planes[5].y=i[7]+i[6],this.planes[5].z=i[11]+i[10],this.planes[5].w=i[15]+i[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(e){for(var i=0;i<6;i++)if(this.planes[i].x*e.x+this.planes[i].y*e.y+this.planes[i].z*e.z+this.planes[i].w<=0)return!1;return!0}containsSphere(e){let i=e.bound,r=0,s,a=e.transform.worldPosition,o=i.radius,l=i.center.x+a.x,h=i.center.y+a.y,u=i.center.z+a.z;for(let c of this.planes){if(s=c.x*l+c.y*h+c.z*u+c.w,s<=-o)return 0;s>o&&r++}return r===6?2:1}containsBox(e){let i=0,r,s=Math.max(e.size.x,e.size.y,e.size.z)*2,a=e.center.x,o=e.center.y,l=e.center.z;for(let h of this.planes){if(r=h.x*a+h.y*o+h.z*l+h.w,r<=-s)return 0;r>s&&i++}return i===6?2:1}containsBox2(e){let i=0,r,s=1.74*Math.max(e.extents.x,e.extents.y,e.extents.z);for(let a of this.planes){if(r=a.x*e.center.x+a.y*e.center.y+a.z*e.center.z+a.w,r<=-s)return 0;r>s&&i++}return i===6?2:1}}var Je=(t=>(t[t.ortho=0]="ortho",t[t.perspective=1]="perspective",t[t.shadow=2]="shadow",t))(Je||{});class wv{constructor(e){n(this,"corners"),n(this,"index"),this.index=e,this.corners=[];for(let i=0;i<4;i++)this.corners.push(new p)}}class Sv{constructor(e,i,r){n(this,"bound"),n(this,"twoSections"),n(this,"name"),n(this,"color"),n(this,"shadowCamera"),n(this,"index"),this.bound=new _t,this.shadowCamera=mt.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[e,i],this.index=r,r==0?this.color=new Y(1,0,0,1):r==1?this.color=new Y(0,1,0,1):r==2?this.color=new Y(0,0,1,1):r==3&&(this.color=new Y(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let e=this.bound.min,i=this.bound.max;for(let r of this.twoSections)for(let s of r.corners)e.x=Math.min(s.x,e.x),e.y=Math.min(s.y,e.y),e.z=Math.min(s.z,e.z),i.x=Math.max(s.x,i.x),i.y=Math.max(s.y,i.y),i.z=Math.max(s.z,i.z);return this.bound.setFromMinMax(e,i),this}}class Ev{constructor(e){n(this,"sections"),n(this,"children"),n(this,"name"),this.sections=[];let i=e+1;for(let r=0;r<i;r++)this.sections.push(new wv(r));this.children=[];for(let r=0;r<e;r++)this.children.push(new Sv(this.sections[r],this.sections[r+1],r))}update(e,i,r,s,a){let o=this.sections.length-1;for(let l=0;l<=o;++l){let h=this.sections[l],u=0,c=this.logSplit(r,s,l,this.sections.length);{let f=(c-r)/s;f=f**a.csmScatteringExp,c=(s-r)*f+r}c*=a.csmAreaScale;let d=(e.rawData[10]*c+e.rawData[14])/c;for(let f=0;f<2;++f)for(let g=0;g<2;++g){let m=h.corners[u];u++,m.set(2*f-1,2*g-1,d,1),i.transformVector4(m,m),m.div(m.w,m)}}for(let l of this.children)l.updateBound();return this}squareSplit(e,i,r,s){return(r/(s-1))**4*(i-e)+e}uniformSplit(e,i,r,s){return r/(s-1)*(i-e)+e}logSplit(e,i,r,s){return e*(i/e)**(r/(s-1))}}class Lh extends Zt{constructor(){super(),n(this,"fov",1),n(this,"name"),n(this,"aspect",1),n(this,"near",1),n(this,"far",5e3),n(this,"viewPort",new eo),n(this,"frustum"),n(this,"isShadowCamera",!1),n(this,"_projectionMatrixInv",new te),n(this,"_projectionMatrix",new te),n(this,"_viewMatrix",new te),n(this,"_unprojection",new te),n(this,"_pvMatrixInv",new te),n(this,"_pvMatrix",new te),n(this,"_halfw"),n(this,"_halfh"),n(this,"_ray"),n(this,"_enableCSM",!1),n(this,"lookTarget"),n(this,"type",Je.perspective),n(this,"csm"),n(this,"cubeShadowCameras",[]),n(this,"_haltonSeq"),n(this,"_jitterOffsetList"),n(this,"_useJitterProjection",!1),n(this,"_jitterFrameIndex",0),n(this,"_sampleIndex",0),n(this,"_jitterX",0),n(this,"_jitterY",0)}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Ev(Jt.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new fs,this.frustum=new Iv,this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=D.presentationSize[0],this.viewPort.h=D.presentationSize[1],this.lookTarget=new p(0,0,0)}getShadowBias(e){let i=2*this.getShadowWorldExtents()/e,r=this.far-this.near;return i/r-I.setting.shadow.shadowBias*.01}getShadowWorldExtents(){let e=I.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBias(e,i){let r=2*this.getCSMShadowWorldExtents(e)/i,s=this.far-this.near;return r/s}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,i,r,s){this.fov=e,this.aspect=i,this.near=r,this.far=s,this._projectionMatrix.perspective(e,i,r,s),this.type=Je.perspective}resetPerspective(e){this.type==Je.perspective&&this._projectionMatrix.perspective(this.fov,e,this.near,this.far)}ortho(e,i,r,s){this.near=Math.max(r,.1),this.far=s,this._projectionMatrix.ortho(e,i,r,s),this.type=Je.ortho}orthoOffCenter(e,i,r,s,a,o){this.near=Math.max(a,.01),this.far=o,this._projectionMatrix.orthoOffCenter(e,i,r,s,a,o),this.type=Je.ortho}orthoZo(e,i,r,s,a,o){this.near=Math.max(a,.01),this.far=o,this._projectionMatrix.orthoZO(e,i,r,s,a,o),this.type=Je.ortho}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,i=null){return i||(i=new p(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,oi.transformVector(this.viewMatrix,e,i),this.project(i,i),i.x=this._halfw+i.x*this._halfw,i.y=this.viewPort.height-(this._halfh-i.y*this._halfh),i}screenRayToObject3D(e,i=null){i||(i=new p),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let r=e.x,s=e.y;return i.x=r/this.viewPort.width-.25,i.y=s/this.viewPort.height-.25,this.unProject(i.x,i.y,e.z,i),i}get pvMatrix(){return pc(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){pc(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,i,r,s){return s||(s=new p),s.x=e,s.y=-i,s.z=r,s.w=1,s.x*=r,s.y*=r,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),oi.transformVector(this._unprojection,s,s),s.z=r,s}project(e,i){return this._projectionMatrix.perspectiveMultiplyPoint3(e,i),i.x=i.x/i.w,i.y=-i.y/i.w,i.z=e.z,i}screenPointToRay(e,i){let r=this._ray,s=mt.UnProjection(e,i,.01,this),a=mt.UnProjection(e,i,1,this);return a=a.subtract(s).normalize(),r.origin.copyFrom(s),r.direction=a,r}screenPointToWorld(e,i,r){return mt.UnProjection(e,i,r,this)}worldToScreenPoint(e,i){return mt.Projection(e,this,i)}lookAt(e,i,r=p.Y_AXIS){this.transform.lookAt(e,i,r),i&&this.lookTarget.copyFrom(i)}resetProjectMatrix(){this.perspective(this.fov,this.aspect,this.near,this.far)}onUpdate(){var e;this.type==Je.perspective&&(this.aspect=D.aspect,this.resetProjectMatrix()),this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let i=I.setting.shadow;this.enableCSM&&((e=this.csm)==null||e.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,i))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new jo),this._jitterOffsetList=[];for(let i=0;i<8;i++){let r=this.generateRandomOffset();this._jitterOffsetList.push(r)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new Ne(jo.get((this._sampleIndex&1023)+1,2)-.5,jo.get((this._sampleIndex&1023)+1,3)-.5);const i=8;return++this._sampleIndex>=i&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=I.setting.render.postProcessing.taa,i=this._projectionMatrix,r=e.temporalJitterScale,s=this._jitterFrameIndex%e.jitterSeedCount,a=this._jitterOffsetList[s].x*r,o=this._jitterOffsetList[s].y*r,l=i.get(0,2),h=i.get(1,2);this._jitterX=a/this.viewPort.width,this._jitterY=o/this.viewPort.height,l+=this._jitterX,h+=this._jitterY,i.set(0,2,l),i.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new p);const i=this.transform._worldMatrix.rawData;return e.set(-i[8],-i[9],-i[10]).normalize()}}const va=class extends Zt{constructor(){super(),n(this,"eventPositionChange",new Tt(va.POSITION_ONCHANGE)),n(this,"eventRotationChange",new Tt(va.ROTATION_ONCHANGE)),n(this,"eventScaleChange",new Tt(va.SCALE_ONCHANGE)),n(this,"eventLocalChange",new Tt(va.LOCAL_ONCHANGE)),n(this,"onPositionChange"),n(this,"onRotationChange"),n(this,"onScaleChange"),n(this,"_scene3d"),n(this,"_parent"),n(this,"_localPos"),n(this,"_localRot"),n(this,"_localRotQuat"),n(this,"_localScale"),n(this,"_localDetailPos"),n(this,"_localDetailRot"),n(this,"_localDetailScale"),n(this,"index"),n(this,"index2"),n(this,"_forward",new p),n(this,"_back",new p),n(this,"_right",new p),n(this,"_left",new p),n(this,"_up",new p),n(this,"_down",new p),n(this,"_worldMatrix"),n(this,"_targetPos"),n(this,"static",!1),n(this,"depthOrder",0),this._worldMatrix=new te(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*ve.stateStruct,this._localPos=new p,this._localRot=new p,this._localRotQuat=new ye,this._localScale=new p(1,1,1),ve.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),ve.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),ve.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return ve.matrixStateBuffer[this.index2]!=0}set localChange(t){ve.matrixStateBuffer[this.index2]=t?1:0}get targetPos(){return this._targetPos}set targetPos(t){this._targetPos=t}get parent(){return this._parent}set parent(t){var e;let i=(e=this._parent)==null?void 0:e.object3D;if(this._parent=t,this.depthOrder=t?t.depthOrder+1:0,ve.setParent(this.index,t?t.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let r=t?t.scene3D:null;r?(this._scene3d=r,this.object3D.components.forEach(s=>{Oe.appendWaitStart(s)})):this.object3D.components.forEach(s=>{s.__stop()});for(let s of this.object3D.entityChildren)s.transform.parent=t?this:null;this.object3D.components.forEach(s=>{var a,o;(o=s.onParentChange)==null||o.call(s,i,(a=this._parent)==null?void 0:a.object3D)})}this.notifyLocalChange()}set enable(t){this.transform._scene3d&&t?super.enable=!0:super.enable=!1;for(let e of this.object3D.entityChildren)e.transform.enable=t}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(t){this._scene3d=t}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let t=this.object3D.entityChildren,e=0,i=t.length;for(e=0;e<i;e++)t[e].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(p.UP,this._up),this._up}set up(t){this._up.copyFrom(t),oi.fromToRotation(p.UP,this._up,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0}get down(){return this.worldMatrix.transformVector(p.DOWN,this._down),this._down}set down(t){var e;this._down.copyFrom(t),oi.fromToRotation(p.DOWN,this._down,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(p.FORWARD,this._forward),this._forward}set forward(t){var e;this._forward.copyFrom(t),oi.fromToRotation(p.FORWARD,this._forward,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(p.BACK,this._back),this._back}set back(t){this._back.copyFrom(t),oi.fromToRotation(p.BACK,this._back,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0}get left(){return this.worldMatrix.transformVector(p.neg_X_AXIS,this._left),this._left}set left(t){this._left.copyFrom(t),oi.fromToRotation(p.LEFT,this._left,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0}get right(){return this.worldMatrix.transformVector(p.X_AXIS,this._right),this._right}set right(t){var e;this._right.copyFrom(t),oi.fromToRotation(p.RIGHT,this._right,ye.HELP_0),this.transform.localRotQuat=ye.HELP_0,this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this._localRotQuat}set localRotQuat(t){var e;(t.x!=this._localRotQuat.x||t.y!=this._localRotQuat.y||t.z!=this._localRotQuat.z||t.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(t),this._localRotQuat.getEulerAngles(this._localRot),ve.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var t,e,i;this.notifyLocalChange(),(t=this.onRotationChange)==null||t.call(this),(e=this.onScaleChange)==null||e.call(this),(i=this.onPositionChange)==null||i.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(t=!1){(this.localChange||t)&&(this.parent?(Dl(this._localRot,this._localPos,this._localScale,this._worldMatrix),bv(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Dl(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let t=this;if(t.localChange&&t.updateWorldMatrix(),t.object3D.numChildren>0)for(const e of t.object3D.entityChildren)e.transform.updateChildTransform()}lookTarget(t,e=p.UP){this.lookAt(this.transform.worldPosition,t,e)}lookAt(t,e,i=p.UP){this._targetPos||(this._targetPos=new p),this._targetPos.copyFrom(e),this.localPosition=t,te.helpMatrix.lookAt(t,e,i),te.helpMatrix.invert();var r=te.helpMatrix.decompose(ki.QUATERNION);this.localRotQuat=ye.CALCULATION_QUATERNION.copyFrom(r[1])}decomposeFromMatrix(t,e="eulerAngles"){let i=t.decompose(e),r=this.transform;return r.localRotQuat.copyFrom(i[1]),r.localRotQuat=r.localRotQuat,r.localPosition.copyFrom(i[0]),r.localPosition=r.localPosition,r.localScale.copyFrom(i[2]),r.localScale=r.localScale,this}cloneTo(t){t.transform.localPosition=this.localPosition,t.transform.localRotation=this.localRotation,t.transform.localScale=this.localScale}set x(t){var e;this._localPos.x!=t&&(this._localPos.x=t,ve.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(t){var e;this._localPos.y!=t&&(this._localPos.y=t,ve.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(t){var e;this._localPos.z!=t&&(this._localPos.z=t,ve.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(t){var e;this._localScale.x!=t&&(this._localScale.x=t,ve.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(t){var e;this._localScale.y!=t&&(this._localScale.y=t,ve.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(t){var e;this._localScale.z!=t&&(this._localScale.z=t,ve.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(t){var e;this._localRot.x!=t&&(this._localRot.x=t,ve.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(t){var e;this._localRot.y!=t&&(this._localRot.y=t,ve.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(t){var e;this._localRot.z!=t&&(this._localRot.z=t,ve.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(t){var e;this._localPos.copyFrom(t),ve.setTranslate(this.index,t.x,t.y,t.z),this.notifyLocalChange(),(e=this.onPositionChange)==null||e.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(t){var e;ve.setRotation(this.index,t.x,t.y,t.z),this._localRot.copyFrom(t),this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(t){var e;ve.setScale(this.index,t.x,t.y,t.z),this._localScale.copyFrom(t),this.notifyLocalChange(),(e=this.onScaleChange)==null||e.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(t){this._localDetailScale=t,ve.setContinueScale(this.index,t.x,t.y,t.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(t){this._localDetailRot=t,ve.setContinueRotation(this.index,t.x,t.y,t.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(t){this._localDetailPos=t,ve.setContinueTranslate(this.index,t.x,t.y,t.z)}beforeDestroy(t){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(t)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};let pt=va;n(pt,"LIMIT",1),n(pt,"COMPONENT_NAME","UUTransform"),n(pt,"COMPONENT_TYPE","Transform"),n(pt,"POSITION_ONCHANGE","POSITION_ONCHANGE"),n(pt,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),n(pt,"SCALE_ONCHANGE","SCALE_ONCHANGE"),n(pt,"PARENT_ONCHANGE","PARENT_ONCHANGE"),n(pt,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),n(pt,"ADD_ONCHANGE","ADD_ONCHANGE"),n(pt,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");const Rf=class{static genMeshBounds(t,e){let i=this.genMeshMinVector,r=this.genMeshMaxVector,s=this.genMeshVectorList8;e||(e=new _t(p.ZERO,p.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let a=t.getComponents(Pe);for(const o of a)if(o&&o.geometry){let l=o.object3D.transform.worldMatrix;i.copy(o.geometry.bounds.min),r.copy(o.geometry.bounds.max),s[0].set(i.x,i.y,i.z),s[1].set(i.x,i.y,r.z),s[2].set(i.x,r.y,i.z),s[3].set(i.x,r.y,r.z),s[4].set(r.x,i.y,i.z),s[5].set(r.x,i.y,r.z),s[6].set(r.x,r.y,i.z),s[7].set(r.x,r.y,r.z);for(const h of s)l.transformPoint(h,h),e.expandByPoint(h)}return r.copyFrom(e.max),i.copyFrom(e.min),e.setFromMinMax(i,r),e}static transformBound(t,e,i){let r=this.genMeshMinVector.copyFrom(e.min),s=this.genMeshMaxVector.copyFrom(e.max),a=this.genMeshVectorList8;i||(i=new _t(p.ZERO,p.ZERO)),i.setFromMinMax(this.maxVector,this.minVector),a[0].set(r.x,r.y,r.z),a[1].set(r.x,r.y,s.z),a[2].set(r.x,s.y,r.z),a[3].set(r.x,s.y,s.z),a[4].set(s.x,r.y,r.z),a[5].set(s.x,r.y,s.z),a[6].set(s.x,s.y,r.z),a[7].set(s.x,s.y,s.z);for(const o of a)t.transformPoint(o,o),i.expandByPoint(o);return s.copyFrom(i.max),r.copyFrom(i.min),i.setFromMinMax(r,s),i}};let xr=Rf;n(xr,"maxVector",new p(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),n(xr,"minVector",Rf.maxVector.clone().multiplyScalar(-1)),n(xr,"genMeshMaxVector",p.ZERO.clone()),n(xr,"genMeshMinVector",p.ZERO.clone()),n(xr,"genMeshVectorList8",[new p,new p,new p,new p,new p,new p,new p,new p]);class Tv extends Ur{constructor(){super(),n(this,"name",""),n(this,"_instanceID",""),n(this,"_numChildren"),n(this,"transform"),n(this,"renderNode"),n(this,"entityChildren"),n(this,"components"),n(this,"waitDisposeComponents"),n(this,"_bound"),n(this,"_boundWorld"),n(this,"_isBoundChange",!0),n(this,"_dispose",!1),this.entityChildren=[],this.components=new Map,this._instanceID=If().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}getObjectByName(e){if(e.indexOf("/")>=0){let i=e.split("/"),r=this;for(;i.length>0&&r;){let s=i.shift();if(r=r.getChildByName(s,!1),!r)return null}return r}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){if(e==null)throw new Error("child is null!");if(e===this)throw new Error("child is self!");return this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,e):null}removeChild(e){if(e===null)return;if(e===this)throw new Error("add child is self!");let i=this.entityChildren.indexOf(e);i!=-1&&(this.entityChildren.splice(i,1),e.transform.parent=null,this._numChildren=this.entityChildren.length)}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let i=null;return e<this.entityChildren.length&&(i=this.entityChildren[e]),i}getChildByName(e,i=!0){let r=null;for(const s of this.entityChildren){if(s.name==e)return r=s,r;if(i&&(r=s.getChildByName(e,i),r))return r}return r}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new _t,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(xr.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,i)=>{e.enable=!1,e.beforeDestroy(),e.destroy()}),this.components.clear()):Oe.waitStartComponent.forEach((e,i)=>{for(;e.length>0;){const r=e.shift();r.__start(),Oe.waitStartComponent.delete(r.object3D)}})}destroy(e){this._dispose||(this.components.forEach(i=>{i.beforeDestroy(e)}),this.components.forEach(i=>{i.destroy(e)}),this.components.clear(),this.entityChildren.forEach(i=>{i.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Bv=Object.defineProperty,Dv=Object.getOwnPropertyDescriptor,Rv=(t,e,i,r)=>{for(var s=r>1?void 0:r?Dv(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Bv(e,i,s),s};let me=class extends Tv{constructor(){super(),n(this,"_isScene3D"),n(this,"prefabRef"),n(this,"serializeTag"),this.transform=this.addComponent(pt),this.transform.eventDispatcher.addEventListener(pt.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(t){this.entityChildren.forEach(e=>{t(e),e.forChild(t)})}addComponent(t,e){let i=t.name;if(!this.components.has(i)){let r=new t;return r.object3D=this,this.components.set(i,r),r.__init(e),Oe.appendWaitStart(r),r}return null}getOrAddComponent(t){let e=t.name,i=this.components.get(e);return i||(i=this.addComponent(t)),i}removeComponent(t){let e=t.name;if(this.components.has(e)){let i=this.components.get(e);Oe.removeWaitStart(this,i),this.components.delete(e),i.__stop(),i.beforeDestroy(),i.destroy()}}hasComponent(t){let e=t.name;return this.components.has(e)}getComponent(t){let e=t.name;return this.components.get(e)}getComponentFromParent(t){return this.parent?this.parent.object3D.getComponent(t)||this.parent.object3D.getComponentFromParent(t):null}getComponentsInChild(t){let e=[],i=t.name,r=this.components.get(i);r&&e.push(r);for(let s=0;s<this.entityChildren.length;s++){let a=this.entityChildren[s].getComponentsInChild(t);e.push(...a)}return e}getComponents(t,e,i){e||(e=[]);let r=this.getComponent(t);r&&(r.enable||i)&&e.push(r);for(let s=0,a=this.entityChildren.length;s<a;s++){let o=this.entityChildren[s];o&&o instanceof me&&o.getComponents(t,e,i)}return e}getComponentsExt(t,e,i){e||(e=[]);let r=this.components.get(t.name);if(r&&(r.enable||i))e.push(r);else for(const s of this.entityChildren)s instanceof me&&s.getComponentsExt(t,e,i);return e}getComponentsByProperty(t,e,i=!0,r,s){r||(r=[]);let a;for(const o of this.components.values())o&&(o.enable||s)&&o[t]==e&&(r.push(o),a=!0);if(!(a&&i))for(const o of this.entityChildren)o instanceof me&&o.getComponentsByProperty(t,e,i,r,s);return r}clone(){return this.instantiate()}instantiate(){let t=new me;return t.name=this.name,t.serializeTag=this.serializeTag,t.prefabRef=this.prefabRef,this.entityChildren.forEach((e,i)=>{let r=e.instantiate();t.addChild(r)}),this.components.forEach((e,i)=>{e.cloneTo(t)}),t}get localPosition(){return this.transform.localPosition}set localPosition(t){this.transform.localPosition=t}get localRotation(){return this.transform.localRotation}set localRotation(t){this.transform.localRotation=t}get localScale(){return this.transform.localScale}set localScale(t){this.transform.localScale=t}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(t){this.transform.localRotQuat=t}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(t){this.transform.x=t}get x(){return this.transform.x}set y(t){this.transform.y=t}get y(){return this.transform.y}set z(t){this.transform.z=t}get z(){return this.transform.z}set scaleX(t){this.transform.scaleX=t}get scaleX(){return this.transform.scaleX}set scaleY(t){this.transform.scaleY=t}get scaleY(){return this.transform.scaleY}set scaleZ(t){this.transform.scaleZ=t}get scaleZ(){return this.transform.scaleZ}set rotationX(t){this.transform.rotationX=t}get rotationX(){return this.transform.rotationX}set rotationY(t){this.transform.rotationY=t}get rotationY(){return this.transform.rotationY}set rotationZ(t){this.transform.rotationZ=t}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(t){t(this);for(let e=0,i=this.entityChildren.length;e<i;e++){let r=this.entityChildren[e];r instanceof me&&r.traverse(t)}}destroy(t){this.transform.eventDispatcher.removeEventListener(pt.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(t)}};me=Rv([Mv],me);function Mv(t,e){return class extends me{set active(i){this.transform.enable=i>0}get active(){return this.transform.enable?1:0}get materialColor(){var i;let r=this.getComponent(Pe);return(i=r==null?void 0:r.material)==null?void 0:i.shader.getDefaultColorShader().baseColor}set materialColor(i){var r;let s=(r=this.getComponent(Pe))==null?void 0:r.material;s&&(s.shader.getDefaultColorShader().baseColor=i)}notifyMaterialColorChange(i,r){var s;let a=this.getComponent(Pe).materials;(s=a==null?void 0:a[i])==null||s.shader.getDefaultColorShader().uniforms[r].onChange()}}}class mt{static createCamera3DObject(e,i){return this.createCamera3D(null,e,i)}static createCamera3D(e,i,r){return e||(e=new me),i&&i.addChild(e),r&&(e.name=r),e.getOrAddComponent(Lh)}static UnProjection(e,i,r=1,s){let a=new p(e,i,0),o=1,l=p.HELP_0,h=D.canvas.offsetLeft,u=D.canvas.offsetTop,c=D.canvas.clientWidth,d=D.canvas.clientHeight;l.x=((a.x-h)*o/c-.5)*2,l.y=-((a.y-u)*o/d-.5)*2,l.z=r;let f=new p(0,0,0),g=te.helpMatrix2;g.copyFrom(s.projectionMatrix),g.invert();let m=te.helpMatrix;return m.identity(),m.multiply(g),m.multiply(s.transform.worldMatrix),m.perspectiveMultiplyPoint3(l,f),f}static Projection(e,i,r){let s=r||new p(0,0,0),a=te.helpMatrix;a.copyFrom(i.viewMatrix),a.multiply(i.projectionMatrix),a.perspectiveMultiplyPoint3(e,s);let o=D.canvas.clientWidth/2,l=D.canvas.clientHeight/2;return s.x=s.x*o+o,s.y=l-s.y*l,s}static UnProjection2(e,i,r,s,a){let o=a||new p(0,0,0),l=te.helpMatrix;l.copyFrom(s.pvMatrixInv);let h=D.canvas.clientWidth/2,u=D.canvas.clientHeight/2;return o.x=(e-h)/h,o.y=(u-i)/u,o.z=r,l.perspectiveMultiplyPoint3(o,o),o}}const Rl=class{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowLights=new Map}static createBuffer(t){if(!this.shadowLights.has(t.scene)){let e=new Float32Array(16);this.shadowLights.set(t.scene,e)}}static getShadowLightList(t){if(!t.transform.view3D)return null;if(t.lightData.lightType==dt.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);return e||(e=[],this.directionLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==dt.PointLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==dt.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(t,e){if(e==dt.DirectionLight){let i=this.directionLightList.get(t);return i||(i=[],this.directionLightList.set(t,i)),i}else if(e==dt.PointLight){let i=this.pointLightList.get(t);return i||(i=[],this.pointLightList.set(t,i)),i}}static getDirectShadowLightWhichScene(t){let e=this.directionLightList.get(t);return e||(e=[],this.directionLightList.set(t,e)),e}static getPointShadowLightWhichScene(t){let e=this.pointLightList.get(t);return e||(e=[],this.pointLightList.set(t,e)),e}static addShadowLight(t){if(!t.transform.view3D)return null;let e=t.transform.view3D.scene;if(t.lightData.lightType==dt.DirectionLight){let i=this.directionLightList.get(e);if(i||(i=[],this.directionLightList.set(e,i)),!t.shadowCamera){t.shadowCamera=mt.createCamera3DObject(null,"shadowCamera"),t.shadowCamera.isShadowCamera=!0;let r=-1e3;t.shadowCamera.orthoOffCenter(r,-r,r,-r,1,1e4)}return i.indexOf(t)==-1&&i.push(t),i}else if(t.lightData.lightType==dt.PointLight||t.lightData.lightType==dt.SpotLight){let i=this.pointLightList.get(e);return i&&i.length>=8||(i||(i=[],this.pointLightList.set(e,i)),i.indexOf(t)==-1&&i.push(t)),i}}static removeShadowLight(t){if(t.lightData.castShadowIndex=-1,!t.transform.view3D)return null;if(t.lightData.lightType==dt.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);if(e){let i=e.indexOf(t);i!=-1&&e.splice(i,1)}return t.lightData.castShadowIndex=-1,e}else if(t.lightData.lightType==dt.PointLight||t.lightData.lightType==dt.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);if(e){let i=e.indexOf(t);i!=-1&&e.splice(i,1)}return t.lightData.castShadowIndex=-1,e}}static update(t){let e=Ze.getCameraGroup(t.camera),i=this.shadowLights.get(t.scene),r=Rl.directionLightList.get(t.scene),s=Rl.pointLightList.get(t.scene),a=0,o=0,l=0,h=0;if(i.fill(0),r){let u=0;for(let c=0;c<r.length;c++){const d=r[c];i[c]=d.lightData.index,d.lightData.castShadowIndex=u++}o=r.length}if(e.dirShadowStart=a,e.dirShadowEnd=o,s){l=o;let u=0;for(let c=l;c<s.length;c++){const d=s[c];i[c]=d.lightData.index,d.lightData.castShadowIndex=u++}h=l+s.length}e.pointShadowStart=l,e.pointShadowEnd=h,e.shadowLights=i}};let Mt=Rl;n(Mt,"maxNumDirectionShadow",8),n(Mt,"maxNumPointShadow",8),n(Mt,"directionLightList"),n(Mt,"pointLightList"),n(Mt,"shadowLights");class Bo{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let e=[];return e.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),e.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=D.device.createBindGroupLayout({entries:e}),this._globalDataBindGroupLayout}}n(Bo,"_globalDataBindGroupLayout");class Pv{constructor(e){n(this,"uuid"),n(this,"usage"),n(this,"globalBindGroup"),n(this,"uniformGPUBuffer"),n(this,"matrixBindGroup"),n(this,"uniformByteLength"),n(this,"matrixesByteLength"),n(this,"shadowMatrixRaw",new Float32Array(8*16)),n(this,"csmMatrixRaw",new Float32Array(Jt.Cascades*16)),n(this,"csmShadowBias",new Float32Array(4)),n(this,"shadowLights",new Float32Array(16)),n(this,"dirShadowStart",0),n(this,"dirShadowEnd",0),n(this,"pointShadowStart",0),n(this,"pointShadowEnd",0),this.uuid=bi(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new an(32*4*4+3*4*4+8*16+Jt.Cascades*16+4+4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=e,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=te.blockBytes*te.maxCount,this.globalBindGroup=D.device.createBindGroup({label:"global_bindGroupLayout",layout:Bo.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",e.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv);let i=Mt.getDirectShadowLightWhichScene(e.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let o=0;o<8;o++)if(o<i.length){let l=i[o].shadowCamera;this.shadowMatrixRaw.set(l.pvMatrix.rawData,o*16)}else this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData,o*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=I.setting.shadow.shadowSize;if(Jt.Cascades>1&&e.enableCSM&&i[0])for(let o=0;o<Jt.Cascades;o++){let l=e.csm.children[o].shadowCamera;this.csmMatrixRaw.set(l.pvMatrix.rawData,o*16),this.csmShadowBias[o]=e.getCSMShadowBias(o,r)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",He.frame),this.uniformGPUBuffer.setFloat("time",He.frame),this.uniformGPUBuffer.setFloat("delta",He.delta),this.uniformGPUBuffer.setFloat("shadowBias",e.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",I.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",I.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",I.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",I.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",I.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",I.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",I.setting.render.renderState_split);let s=I.inputSystem.mouseX*D.pixelRatio,a=I.inputSystem.mouseY*D.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",s),this.uniformGPUBuffer.setFloat("mouseY",a),this.uniformGPUBuffer.setFloat("windowWidth",D.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",D.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",I.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",I.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",e.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",I.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.apply()}setShadowCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",e.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",He.frame),this.uniformGPUBuffer.setFloat("time",He.frame),this.uniformGPUBuffer.setFloat("delta",He.delta),this.uniformGPUBuffer.setFloat("shadowBias",I.setting.shadow.shadowBias),this.uniformGPUBuffer.setFloat("skyExposure",I.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",I.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",I.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",I.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",I.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",I.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",I.setting.render.renderState_split);let i=I.inputSystem.mouseX*D.pixelRatio,r=I.inputSystem.mouseY*D.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",i),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",D.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",D.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",I.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",I.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",I.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",I.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.apply()}setShadowLight(){}}const Es=class{constructor(t,e=0,i=null,r=0){n(this,"entities"),n(this,"box"),n(this,"subTrees",[]),n(this,"parent"),n(this,"level"),n(this,"index"),n(this,"uuid"),n(this,"__rayCastTempVector",new p),this.parent=i,this.box=t.clone(),this.level=r,this.index=e,this.uuid=r+"_"+e,this.entities=new Map}tryInsertEntity(t){let e=t.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<Es.maxSplitLevel&&this.splitTree();let i;if(this.subTrees.length>0){for(let r of this.subTrees)if(r.tryInsertEntity(t)){i=!0;break}}return i||t.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const t=Es._v1,e=this.box.extents.clone();let i=this.level+1,r=0;for(let s=0;s<2;s++)for(let a=0;a<2;a++)for(let o=0;o<2;o++){const l=new _t;this.box.min.add(t.set(s,a,o).multiply(e),l.min),l.min.add(e,l.max),l.setFromMinMax(l.min,l.max);let h=new Es(l,r++,this,i);this.subTrees.push(h)}}}rayCasts(t,e){if(this.level==0||t.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let i of this.subTrees)i.rayCasts(t,e);return!0}return!1}frustumCasts(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const i of this.entities.values())(this.level>Es.autoSplitLevel||t.containsBox2(i.renderer.object3D.bound)>0)&&e.push(i);for(let i of this.subTrees)i.frustumCasts(t,e);return!0}return!1}getRenderNode(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const i of this.entities.values())(this.level>Es.autoSplitLevel||t.containsBox2(i.renderer.object3D.bound)>0)&&(i.renderer.renderOrder<3e3?e.opaqueList.push(i.renderer):i.renderer.renderOrder>=3e3&&e.transparentList.push(i.renderer));for(let i of this.subTrees)i.getRenderNode(t,e);return!0}return!1}boxCasts(t,e){if(t.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let i of this.subTrees)i.boxCasts(t,e);return!0}return!1}clean(){for(let t of this.entities.values())t.leaveNode();return this.entities.clear(),this}};let xa=Es;n(xa,"_v1",new p),n(xa,"_v2",new p),n(xa,"maxSplitLevel",6),n(xa,"autoSplitLevel",3);class Uv{constructor(){n(this,"_pool",[]),n(this,"_worldPosition",new p),n(this,"_viewPosition",new p),n(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let e of this._zSortList)e.z=0,e.userData=null,e.obj3d=null,this._pool.push(e);this._zSortList.length=0}sort(e,i,r,s){this._zSortList=[];for(let a of i){let o=this.pop();o.userData=a,o.obj3d=r(a),o.z=this.worldToCameraDepth(o.obj3d,e),this._zSortList.push(o)}this._zSortList.sort((a,o)=>a.z-o.z>0?1:-1),s||(s=[]);for(let a of this._zSortList)s.push(a.userData);return this.recycle(),s}worldToCameraDepth(e,i){i||(i=e.transform.view3D.camera);let r=0;return i&&(this._worldPosition.copyFrom(e.transform.worldPosition),i.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let Lv=new Uv;var to=(t=>(t[t.None=2]="None",t[t.StaticBatch=4]="StaticBatch",t[t.DynamicBatch=8]="DynamicBatch",t))(to||{});class mc{static addMask(e,i){return e|i}static removeMask(e,i){return e&~i}static hasMask(e,i){return(e&i)!=0}}var xe=(t=>(t[t.COLOR=1]="COLOR",t[t.NORMAL=2]="NORMAL",t[t.POSITION=4]="POSITION",t[t.GRAPHIC=8]="GRAPHIC",t[t.GI=16]="GI",t[t.Cluster=32]="Cluster",t[t.SHADOW=64]="SHADOW",t[t.POINT_SHADOW=128]="POINT_SHADOW",t[t.POST=256]="POST",t[t.DEPTH=512]="DEPTH",t[t.REFLECTION=1024]="REFLECTION",t))(xe||{});class Fe{}n(Fe,"GLTF_NODE_INDEX_PROPERTY"),n(Fe,"BASE_COLOR_UNIFORM","u_baseColorFactor"),n(Fe,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),n(Fe,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),n(Fe,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),n(Fe,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),n(Fe,"NORMAL_SCALE_UNIFORM","u_normalScale"),n(Fe,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),n(Fe,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),n(Fe,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),n(Fe,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),n(Fe,"MAX_MORPH_TARGETS",8),n(Fe,"MORPH_POSITION_PREFIX","a_morphPositions_"),n(Fe,"MORPH_NORMAL_PREFIX","a_morphNormals_"),n(Fe,"MORPH_TANGENT_PREFIX","a_morphTangents_"),n(Fe,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),n(Fe,"SCENE_ROOT_SKELETON","SCENE_ROOT"),n(Fe,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),n(Fe,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),n(Fe,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");var z=(t=>(t.position="position",t.normal="normal",t.uv="uv",t.TANGENT="TANGENT",t.TEXCOORD_1="TEXCOORD_1",t.TEXCOORD_2="TEXCOORD_2",t.TEXCOORD_3="TEXCOORD_3",t.TEXCOORD_4="TEXCOORD_4",t.TEXCOORD_5="TEXCOORD_5",t.TEXCOORD_6="TEXCOORD_6",t.TEXCOORD_7="TEXCOORD_7",t.color="color",t.joints0="joints0",t.joints1="joints1",t.weights0="weights0",t.weights1="weights1",t.weight="weight",t.indices="indices",t.vIndex="vIndex",t.a_morphPositions_0="a_morphPositions_0",t.all="all",t))(z||{}),Te=(t=>(t[t.NONE=0]="NONE",t[t.ABOVE=1]="ABOVE",t[t.ALPHA=2]="ALPHA",t[t.NORMAL=3]="NORMAL",t[t.ADD=4]="ADD",t[t.BELOW=5]="BELOW",t[t.ERASE=6]="ERASE",t[t.MUL=7]="MUL",t[t.SCREEN=8]="SCREEN",t[t.DIVD=9]="DIVD",t[t.SOFT_ADD=10]="SOFT_ADD",t))(Te||{}),Ov=(t=>(t[t.src_a=0]="src_a",t[t.dest_a=1]="dest_a",t))(Ov||{});class Mf{static getBlend(e){let i={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(e){case 0:i.color.srcFactor="one",i.color.dstFactor="zero",i.color.operation="add";break;case 1:i.color.srcFactor="one-minus-src-alpha",i.color.dstFactor="dst-alpha",i.color.operation="add";break;case 4:i.color.srcFactor="one",i.color.dstFactor="one",i.color.operation="add",i.alpha.srcFactor="one",i.alpha.dstFactor="one",i.alpha.operation="add";break;case 2:i.color.srcFactor="src-alpha",i.color.dstFactor="one-minus-src-alpha";break;case 5:i.color.srcFactor="one-minus-src-alpha",i.color.dstFactor="one",i.color.operation="add";break;case 6:i.color.srcFactor="zero",i.color.dstFactor="one-minus-src-alpha",i.color.operation="add";break;case 7:i.color.srcFactor="dst",i.color.dstFactor="one-minus-src-alpha",i.color.operation="add";break;case 3:i.color.srcFactor="src-alpha",i.color.dstFactor="one-minus-src-alpha",i.color.operation="add";break;case 10:i.color.srcFactor="one",i.color.dstFactor="one",i.color.operation="max",i.alpha.srcFactor="one",i.alpha.dstFactor="one",i.alpha.operation="add";break;case 8:i.color.srcFactor="one",i.color.dstFactor="one-minus-src",i.color.operation="add";break}return i}}const fr=class{static getMipmapPipeline(t){let e=t.format,i=D.device,r=fr.pipelineCache[t.format],s;if(!r){s=i.createShaderModule({code:fr.mipmapShader});let a=i.createBindGroupLayout({entries:[{binding:0,visibility:t.visibility,sampler:t.samplerBindingLayout},{binding:1,visibility:t.visibility,texture:t.textureBindingLayout}]}),o=D.device.createPipelineLayout({bindGroupLayouts:[a]});r=T.createPipeline({layout:o,vertex:{module:s,entryPoint:"vertexMain"},fragment:{module:s,entryPoint:"fragmentMain",targets:[{format:e}]}}),fr.pipelineCache[e]=r}return r}static getMipmapCount(t){let e=t.width,i=t.height,r=Math.max(e,i);return 1+Math.log2(r)|0}static webGPUGenerateMipmap(t){let e=D.device,i=t.textureDescriptor;if(!fr.pipeline){const o=e.createShaderModule({code:`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
          return outColor;
        }
      `});fr.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:o,entryPoint:"vertexMain"},fragment:{module:o,entryPoint:"fragmentMain",targets:[{format:i.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}})}let r;t.format=="rgba16float"?r=e.createSampler({minFilter:"nearest",magFilter:"linear"}):r=e.createSampler({minFilter:ar.linear,magFilter:ar.linear});let s=t.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const a=T.beginCommandEncoder();for(let o=1;o<i.mipLevelCount;++o){const l=t.getGPUTexture().createView({baseMipLevel:o,mipLevelCount:1}),h=a.beginRenderPass({colorAttachments:[{view:l,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),u=e.createBindGroup({layout:fr.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:r},{binding:1,resource:s}]});h.setPipeline(fr.pipeline),h.setBindGroup(0,u),h.draw(4),h.end(),s=l}T.endCommandEncoder(a)}};let ls=fr;n(ls,"mipmapShader",`
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`),n(ls,"pipelineCache",{}),n(ls,"pipeline");class Lt{constructor(e=32,i=32,r=1){n(this,"name"),n(this,"url"),n(this,"gpuTexture"),n(this,"pid"),n(this,"view"),n(this,"gpuSampler"),n(this,"gpuSampler_comparison"),n(this,"format"),n(this,"usage"),n(this,"width",4),n(this,"height",4),n(this,"depthOrArrayLayers",1),n(this,"numberLayer",1),n(this,"viewDescriptor"),n(this,"textureDescriptor"),n(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT),n(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1}),n(this,"samplerBindingLayout",{type:"filtering"}),n(this,"sampler_comparisonBindingLayout",{type:"comparison"}),n(this,"flipY"),n(this,"isVideoTexture"),n(this,"isHDRTexture"),n(this,"_useMipmap",!1),n(this,"_sourceImageData"),n(this,"_addressModeU"),n(this,"_addressModeV"),n(this,"_addressModeW"),n(this,"_magFilter"),n(this,"_minFilter"),n(this,"_mipmapFilter"),n(this,"_lodMinClamp"),n(this,"_lodMaxClamp"),n(this,"_compare"),n(this,"_maxAnisotropy"),n(this,"mipmapCount",1),n(this,"_textureChange",!1),n(this,"_stateChangeRef",new Map),this.width=e,this.height=i,this.numberLayer=r,this.minFilter=ar.linear,this.magFilter=ar.linear,this.mipmapFilter=ar.linear,this.addressModeU=ci.repeat,this.addressModeV=ci.repeat}init(){let e=this;return e.internalCreateBindingLayoutDesc&&e.internalCreateBindingLayoutDesc(),e.internalCreateTexture&&e.internalCreateTexture(),e.internalCreateView&&e.internalCreateView(),e.internalCreateSampler&&e.internalCreateSampler(),this}createTextureDescriptor(e,i,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,o=1,l=0){this.width=e,this.height=i,this.format=s,this.usage=a,this.textureDescriptor={size:[e,i,o],mipLevelCount:r,format:s,usage:a,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),o>1?this.viewDescriptor={dimension:"2d-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension,mipLevelCount:r,baseMipLevel:0}}generate(e){let i=32,r=32;"width"in e&&(i=e.width,r=e.height),(i<32||r<32)&&console.log(e.name+"Size must be greater than 32!"),this.width=i,this.height=r,this.createTexture(e)}createTexture(e){this._sourceImageData=e,this.updateTextureDescription(),this.updateGPUTexture();let i=D.device;this.gpuTexture instanceof GPUTexture&&i.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&ls.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(e){if(e){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let i=D.device;this.gpuTexture instanceof GPUTexture&&i.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),ls.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let i=D.device;this.gpuTexture instanceof GPUTexture&&i.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=e,this.noticeChange()}get sourceImageData(){return this._sourceImageData}getMipmapCount(){let e=this.width,i=this.height,r=Math.max(e,i);return 1+Math.log2(r)|0}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?this.getMipmapCount():1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=D.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(e=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(e,i){this._stateChangeRef.set(i,e)}unBindStateChange(e){this._stateChangeRef.delete(e)}noticeChange(){this.gpuSampler=D.device.createSampler(this),this._stateChangeRef.forEach((e,i)=>{e()})}destroy(e){e&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(e){this._addressModeU!=e&&(this._addressModeU=e,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(e){this._addressModeV!=e&&(this._addressModeV=e,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(e){this._addressModeW!=e&&(this._addressModeW=e,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(e){this._magFilter!=e&&(this._magFilter=e,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(e){this._minFilter!=e&&(this._minFilter=e,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(e){this._mipmapFilter!=e&&(this._mipmapFilter=e,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(e){this._lodMinClamp!=e&&(this._lodMinClamp=e,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(e){this._lodMaxClamp!=e&&(this._lodMaxClamp=e,this.noticeChange())}get compare(){return this._compare}set compare(e){this._compare!=e&&(this._compare=e,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(e){this._maxAnisotropy!=e&&(this._maxAnisotropy=e,this.noticeChange())}static delayDestroyTexture(e){this._texs.includes(e)||this._texs.push(e)}static destroyTexture(){if(this._texs.length>0)for(;this._texs.length>0;)this._texs.shift().destroy()}}n(Lt,"_texs",[]);class Nv extends Lt{constructor(e,i,r){super(e,i,r),n(this,"_bitmapTextures"),this.format=le.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let i=0;i<e.length;i++){const r=e[i];this.addTexture(r)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture must match bitmapTextureArray size!"),e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture()}removeTexture(e){let i=this._bitmapTextures.indexOf(e);if(i!=-1){this._bitmapTextures.splice(i,1);for(let r=0;r<this._bitmapTextures.length;r++){const s=this._bitmapTextures[r];s.pid=r}}}updateTexture(){let e=T.beginCommandEncoder();for(let i=0;i<this._bitmapTextures.length;i++){let r=this._bitmapTextures[i];e.copyTextureToTexture({texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:i}},{width:this.width,height:this.height,depthOrArrayLayers:1})}T.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=ar.linear,this.magFilter=ar.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=D.device.createSampler(this)}}const Xr=class{constructor(){n(this,"_iesTexture"),n(this,"index",0)}generateIES(t){}set IESTexture(t){this._iesTexture=t,t.addressModeU=ci.repeat,t.addressModeV=ci.repeat,t.addressModeW=ci.repeat,Xr.ies_list.indexOf(this)==-1&&(this.index=Xr.ies_list.length,Xr.ies_list.push(this),Xr.iesTexture||Xr.create(t.width,t.height),Xr.iesTexture.addTexture(t))}get IESTexture(){return this._iesTexture}static create(t,e){let i=48;this.iesTexture=new Nv(t,e,i)}};let Fs=Xr;n(Fs,"use",!1),n(Fs,"iesTexture"),n(Fs,"ies_list",[]);class mn{constructor(e=0,i="\0"){n(this,"Type",0),n(this,"Line",0),n(this,"Colume",0),n(this,"Literal",""),this.Type=e,this.Literal=i}isTypeEqual(e){return this.Type==e}isLiteralEqual(e){return this.Literal==e}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var v=(t=>(t[t.EOF=0]="EOF",t[t.IDENT=1]="IDENT",t[t.VOID=2]="VOID",t[t.CONST=3]="CONST",t[t.LAYOUT=4]="LAYOUT",t[t.PRECISION=5]="PRECISION",t[t.ATTRIBUTE=6]="ATTRIBUTE",t[t.UNIFORM=7]="UNIFORM",t[t.VARYING=8]="VARYING",t[t.INVARIANT=9]="INVARIANT",t[t.IN=10]="IN",t[t.OUT=11]="OUT",t[t.INOUT=12]="INOUT",t[t.IF=13]="IF",t[t.ELSE=14]="ELSE",t[t.FOR=15]="FOR",t[t.WHILE=16]="WHILE",t[t.DO=17]="DO",t[t.BREAK=18]="BREAK",t[t.RETURN=19]="RETURN",t[t.CONTINUE=20]="CONTINUE",t[t.STRUCT=21]="STRUCT",t[t.COMMA=22]="COMMA",t[t.COLON=23]="COLON",t[t.QUEMARK=24]="QUEMARK",t[t.SEMICOLON=25]="SEMICOLON",t[t.LEFTSAMLL=26]="LEFTSAMLL",t[t.RIGHTSAMLL=27]="RIGHTSAMLL",t[t.LEFTMEDI=28]="LEFTMEDI",t[t.RIGHTMEDI=29]="RIGHTMEDI",t[t.LEFTBIG=30]="LEFTBIG",t[t.RIGHTBIG=31]="RIGHTBIG",t[t.LITERAL=32]="LITERAL",t[t.BeginBuiltinType=33]="BeginBuiltinType",t[t.INT=34]="INT",t[t.INT_ARRAY=35]="INT_ARRAY",t[t.UINT=36]="UINT",t[t.UINT_ARRAY=37]="UINT_ARRAY",t[t.BOOL=38]="BOOL",t[t.BOOL_ARRAY=39]="BOOL_ARRAY",t[t.FLOAT=40]="FLOAT",t[t.FLOAT_ARRAY=41]="FLOAT_ARRAY",t[t.DOUBLE=42]="DOUBLE",t[t.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",t[t.VEC2=44]="VEC2",t[t.VEC2_ARRAY=45]="VEC2_ARRAY",t[t.VEC3=46]="VEC3",t[t.VEC3_ARRAY=47]="VEC3_ARRAY",t[t.VEC4=48]="VEC4",t[t.VEC4_ARRAY=49]="VEC4_ARRAY",t[t.BVEC2=50]="BVEC2",t[t.BVEC2_ARRAY=51]="BVEC2_ARRAY",t[t.BVEC3=52]="BVEC3",t[t.BVEC3_ARRAY=53]="BVEC3_ARRAY",t[t.BVEC4=54]="BVEC4",t[t.BVEC4_ARRAY=55]="BVEC4_ARRAY",t[t.IVEC2=56]="IVEC2",t[t.IVEC2_ARRAY=57]="IVEC2_ARRAY",t[t.IVEC3=58]="IVEC3",t[t.IVEC3_ARRAY=59]="IVEC3_ARRAY",t[t.IVEC4=60]="IVEC4",t[t.IVEC4_ARRAY=61]="IVEC4_ARRAY",t[t.UVEC2=62]="UVEC2",t[t.UVEC2_ARRAY=63]="UVEC2_ARRAY",t[t.UVEC3=64]="UVEC3",t[t.UVEC3_ARRAY=65]="UVEC3_ARRAY",t[t.UVEC4=66]="UVEC4",t[t.UVEC4_ARRAY=67]="UVEC4_ARRAY",t[t.MAT2x2=68]="MAT2x2",t[t.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",t[t.MAT2x3=70]="MAT2x3",t[t.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",t[t.MAT2x4=72]="MAT2x4",t[t.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",t[t.MAT3x2=74]="MAT3x2",t[t.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",t[t.MAT3x3=76]="MAT3x3",t[t.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",t[t.MAT3x4=78]="MAT3x4",t[t.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",t[t.MAT4x2=80]="MAT4x2",t[t.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",t[t.MAT4x3=82]="MAT4x3",t[t.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",t[t.MAT4x4=84]="MAT4x4",t[t.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",t[t.SAMPLER=86]="SAMPLER",t[t.SAMPLER_1D=87]="SAMPLER_1D",t[t.SAMPLER_2D=88]="SAMPLER_2D",t[t.SAMPLER_3D=89]="SAMPLER_3D",t[t.SAMPLER_CUBE=90]="SAMPLER_CUBE",t[t.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",t[t.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",t[t.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",t[t.TEXTURE_1D=94]="TEXTURE_1D",t[t.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",t[t.TEXTURE_2D=96]="TEXTURE_2D",t[t.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",t[t.TEXTURE_3D=98]="TEXTURE_3D",t[t.TEXTURE_CUBE=99]="TEXTURE_CUBE",t[t.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",t[t.EndBuiltinType=101]="EndBuiltinType",t[t.BeginOperation=102]="BeginOperation",t[t.ADD=103]="ADD",t[t.SUB=104]="SUB",t[t.MUL=105]="MUL",t[t.DIV=106]="DIV",t[t.AND=107]="AND",t[t.OR=108]="OR",t[t.XOR=109]="XOR",t[t.NOT=110]="NOT",t[t.BITAND=111]="BITAND",t[t.BITOR=112]="BITOR",t[t.BITXOR=113]="BITXOR",t[t.BITNOT=114]="BITNOT",t[t.BITSHIFT_L=115]="BITSHIFT_L",t[t.BITSHIFT_R=116]="BITSHIFT_R",t[t.INC=117]="INC",t[t.DEC=118]="DEC",t[t.GREATER=119]="GREATER",t[t.GREATEREQUAL=120]="GREATEREQUAL",t[t.EQUAL=121]="EQUAL",t[t.LESS=122]="LESS",t[t.LESSEQUAL=123]="LESSEQUAL",t[t.NOTEQUAL=124]="NOTEQUAL",t[t.DOT=125]="DOT",t[t.ASSIGN=126]="ASSIGN",t[t.EndOperation=127]="EndOperation",t[t.BeginAssignOperation=128]="BeginAssignOperation",t[t.ADDASSIGN=129]="ADDASSIGN",t[t.SUBASSIGN=130]="SUBASSIGN",t[t.MULASSIGN=131]="MULASSIGN",t[t.DIVASSIGN=132]="DIVASSIGN",t[t.EndAssignOperation=133]="EndAssignOperation",t))(v||{});class ka{constructor(e){n(this,"_char"),n(this,"_line"),n(this,"_column"),n(this,"_source"),n(this,"_currPosition"),n(this,"_nextPosition"),this.reset(e)}reset(e){this._char="",this._line=0,this._column=0,this._source=e,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var e=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}isIdentifier(e){var i=e.charCodeAt(0);return 97<=i&&i<=122||65<=i&&i<=90||48<=i&&i<=57||i==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(e){return e===" "||e==="	"||e==="\r"||e===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let e=1;e>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){e++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){e--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(e){var i=e.charCodeAt(0);return 48<=i&&i<=57}readNumber(){for(var e=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var e=this._currPosition,i=this._source.indexOf(`
`,this._currPosition);return i==-1&&(i=this._source.length),this._line++,this._column=0,this._currPosition=i,this._nextPosition=i+1,this._source.substring(e,i+1)}}class Fv extends ka{constructor(e){super(e.source),n(this,"_tokenPosition",0),n(this,"_tokens",[]),this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new mn(v.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new mn(v.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=v.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new mn;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=v.EOF,e.Literal="EOF";break;case".":e.Type=v.DOT,e.Literal=".";break;case",":e.Type=v.COMMA,e.Literal=",";break;case":":e.Type=v.COLON,e.Literal=":";break;case"?":e.Type=v.QUEMARK,e.Literal="?";break;case";":e.Type=v.SEMICOLON,e.Literal=";";break;case"(":e.Type=v.LEFTSAMLL,e.Literal="(";break;case")":e.Type=v.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=v.LEFTMEDI,e.Literal="[";break;case"]":e.Type=v.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=v.LEFTBIG,e.Literal="{";break;case"}":e.Type=v.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=v.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=v.ADDASSIGN,e.Literal="+=";break}e.Type=v.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=v.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=v.SUBASSIGN,e.Literal="-=";break}e.Type=v.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=v.MULASSIGN,e.Literal="*=";break}e.Type=v.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=v.DIVASSIGN,e.Literal="/=";break}e.Type=v.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=v.AND,e.Literal="&&";break}e.Type=v.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=v.OR,e.Literal="||";break}e.Type=v.BITOR,e.Literal="&";break;case"^":e.Type=v.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=v.NOTEQUAL,e.Literal="!=";break}e.Type=v.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=v.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=v.BITSHIFT_R,e.Literal=">>";break}e.Type=v.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=v.EQUAL,e.Literal="==";break}e.Type=v.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=v.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=v.BITSHIFT_L,e.Literal="<<";break}e.Type=v.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new mn;e.Line=this._line,e.Colume=this._column,e.Type=v.LITERAL;var i=this.readNumber();return this._char==="e"?(e.Literal=i+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=v.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=v.LITERAL,e.Literal=i+"u",e):this._char==="f"?(this.readChar(),e.Type=v.LITERAL,e.Literal=i+"f",e):(e.Type=v.LITERAL,e.Literal=i,e)}lookupIdentifier(e){switch(e){case"void":return v.VOID;case"int":return v.INT;case"uint":return v.UINT;case"bool":return v.BOOL;case"true":return v.BOOL;case"false":return v.BOOL;case"float":return v.FLOAT;case"vec2":return v.VEC2;case"vec3":return v.VEC3;case"vec4":return v.VEC4;case"bvec2":return v.BVEC2;case"bvec3":return v.BVEC3;case"bvec4":return v.BVEC4;case"ivec2":return v.IVEC2;case"ivec3":return v.IVEC3;case"ivec4":return v.IVEC4;case"uvec2":return v.UVEC2;case"uvec3":return v.UVEC3;case"uvec4":return v.UVEC4;case"mat2":return v.MAT2x2;case"mat2x2":return v.MAT2x2;case"mat2x3":return v.MAT2x3;case"mat2x4":return v.MAT2x4;case"mat3":return v.MAT3x3;case"mat3x2":return v.MAT3x2;case"mat3x3":return v.MAT3x3;case"mat3x4":return v.MAT3x4;case"mat4":return v.MAT4x4;case"mat4x2":return v.MAT4x2;case"mat4x3":return v.MAT4x3;case"mat4x4":return v.MAT4x4;case"sampler":return v.SAMPLER;case"sampler1D":return v.SAMPLER_1D;case"sampler2D":return v.SAMPLER_2D;case"sampler3D":return v.SAMPLER_3D;case"samplerCube":return v.SAMPLER_CUBE;case"samplerShadow":return v.SAMPLER_SHADOW;case"sampler1DShadow":return v.SAMPLER_1D_SHADOW;case"sampler2DShadow":return v.SAMPLER_2D_SHADOW;case"texture1D":return v.TEXTURE_1D;case"texture2D":return v.TEXTURE_2D;case"texture3D":return v.TEXTURE_3D;case"textureCube":return v.TEXTURE_CUBE;case"texture1DArray":return v.TEXTURE_1D_ARRAY;case"texture2DArray":return v.TEXTURE_2D_ARRAY;case"textureCubeArray":return v.TEXTURE_CUBE_ARRAY;case"const":return v.CONST;case"layout":return v.LAYOUT;case"precision":return v.PRECISION;case"attribute":return v.ATTRIBUTE;case"uniform":return v.UNIFORM;case"varying":return v.VARYING;case"invariant":return v.INVARIANT;case"in":return v.IN;case"out":return v.OUT;case"inout":return v.INOUT;case"if":return v.IF;case"else":return v.ELSE;case"for":return v.FOR;case"while":return v.WHILE;case"do":return v.DO;case"break":return v.BREAK;case"return":return v.RETURN;case"continue":return v.CONTINUE;case"struct":return v.STRUCT}return v.IDENT}}class kv{constructor(){n(this,"name",""),n(this,"value",""),n(this,"args",[])}}class Qv extends ka{constructor(e){super(e),n(this,"_result"),n(this,"_skipLine"),n(this,"_definitionTables"),this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var i=this.readIdentifier();if(this.getChar()==="("){let l=new kv;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var r=this.readIdentifier();if(l.args.push(r),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),l.name=i,l.value=this.readLine().trim(),this._definitionTables.set(i,l),this.readCharAndSkipWhitespace()}else{let l=this.readLine().trim();l[0]=="="&&(l=l.substring(1)),this._definitionTables.set(i,l)}break;case"if":let o=this.readLine().trim();if(o=="0"||o=="false"){this._skipLine=!0;break}if(this._definitionTables.has(o)&&(o=this._definitionTables.get(o),o=="0"||o=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var s=this.readIdentifier();this._skipLine=!this._definitionTables.has(s);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var a=this.readLine();if(!this._skipLine){for(let o of this._definitionTables.keys()){let l=a.indexOf(o);if(l!=-1){let h=this._definitionTables.get(o);if(typeof h=="string")a=a.replace(o,h);else{let u=h,c=new ka(a.substring(l+o.length));if(c.readCharAndSkipWhitespace(),c.getChar()==="("){c.readCharAndSkipWhitespace();for(let m=1;c.getChar()!=="\0"&&m>0;){switch(c.getChar()){case"(":m++;break;case")":m--;break}c.readCharAndSkipWhitespace()}}let d=l,f=d+o.length+c.currPosition,g=a.substring(d,f).trim();if(u.args.length>0){let m=[],A=g.substring(g.indexOf("(")+1,g.lastIndexOf(")")).trim();A.length>0&&(m=this.parseArgs(A));let _=u.value.substring(u.value.indexOf("("));for(let x=0;x<u.args.length;x++)_=_.replace(u.args[x],m[x]);_=u.value.substring(0,u.value.indexOf("("))+_,a=a.replace(g,_)}else a=a.replace(g,u.value)}}}this._result+=a}this.readChar()}}}get source(){return this._result}parseArgs(e){let i=[],r=0,s=new ka(e),a=s.currPosition;if(s.readCharAndSkipWhitespace(),s.getChar()!=="\0")for(s.readCharAndSkipWhitespace();s.getChar()!=="\0";){switch(s.getChar()){case"(":r++;break;case")":r--;break;case",":if(r==0){let o=e.substring(a,s.currPosition);i.push(o),a=s.currPosition+1}break}s.readCharAndSkipWhitespace()}if(a<s.currPosition){let o=e.substring(a,s.currPosition);i.push(o)}return i}}class zv{constructor(e){n(this,"result"),n(this,"ASTRoot"),n(this,"_syntax"),this.result="",this._syntax=e,this.ASTRoot=e.ASTRoot}generateWGSL(){let e=new Pf;var i=new Yv;let r=[],s=[],a=[];for(let c of this.ASTRoot.nodes)if(c instanceof Ro)if(c.scope=="in")if(c.nodes[0]instanceof st){e.layoutsIn.push(c);let d=new _c;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.locationID=Number.parseInt(c.qualifier.get("location")),i.inputAttribute.push(d)}else if(c.qualifier.has("local_size_x"))e.workGroupSize=c;else throw"not impl";else if(c.scope=="out")if(e.layoutsOut.push(c),c.nodes[0]instanceof st){let d=new _c;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.locationID=Number.parseInt(c.qualifier.get("location")),i.outputAttribute.push(d)}else throw"not impl";else if(c.scope=="uniform")if(s.push(c),c.nodes[0]instanceof st){let d=new Ac;d.name=c.nodes[0].name,d.type=c.nodes[0].type,d.setID=Number.parseInt(c.qualifier.get("set")),d.bindingID=Number.parseInt(c.qualifier.get("binding")),i.uniformInfo.push(d)}else if(c.nodes[0]instanceof Sr){let d=new Ac;d.name="unif"+i.uniformInfo.length.toString(),d.type=c.nodes[0].name,d.setID=Number.parseInt(c.qualifier.get("set")),d.bindingID=Number.parseInt(c.qualifier.get("binding")),i.uniformInfo.push(d)}else throw"not impl";else c.scope=="buffer"&&r.push(c);else a.push(c);e.stage="fragment";let o=0,l=new ka(""),h=this._syntax.lexer.source,u=new Map;for(;(o=h.indexOf("gl_",o))!=-1;){l.reset(h.substring(o,o+32)),l.readChar();let c=l.readIdentifier();if(o+=c.length,!u.has(c))switch(u.set(c,c),c){case"gl_InstanceID":e.stage="vertex",e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":e.stage="vertex",e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),e.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":e.stage="vertex",e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":e.stage="fragment",e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":e.stage="fragment",e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),e.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":e.stage="compute",e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":e.stage="compute",e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+c}}for(let c of s)c.nodes[0]instanceof Sr&&(i.sourceCode+=c.nodes[0].formatToWGSL(e,0),i.sourceCode+=`\r
`);for(let c of s)i.sourceCode+=c.formatToWGSL(e,0);i.sourceCode+=`\r
`;for(let c of r)c.nodes[0]instanceof Sr&&(i.sourceCode+=c.nodes[0].formatToWGSL(e,0),i.sourceCode+=`\r
`);for(let c of r)i.sourceCode+=c.formatToWGSL(e,0);i.sourceCode+=`\r
`;for(let c of a)i.sourceCode+=c.formatToWGSL(e,0),c instanceof st&&(i.sourceCode+=`;\r
`);return i}}class Pf{constructor(e){n(this,"_stage","fragment"),n(this,"_builtinIn",[]),n(this,"_builtinOut",[]),n(this,"_layoutsIn",[]),n(this,"_layoutsOut",[]),n(this,"_layoutUniformCount",0),n(this,"_workGroupSize"),n(this,"_parentContext"),n(this,"_identifierEnv",new Map),this._parentContext=e}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(e){this.parentContext!=null&&(this.parentContext.stage=e),this._stage=e}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(e){if(this.parentContext!=null){this.parentContext.layoutUniformCount=e;return}this._layoutUniformCount=e}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(e){this.parentContext!=null&&(this.parentContext.workGroupSize=e),this._workGroupSize=e}get parentContext(){return this._parentContext}findIdentifier(e){return this._identifierEnv.has(e)?this._identifierEnv.get(e):this._parentContext!=null?this._parentContext.findIdentifier(e):e}addIdentifier(e,i){this._identifierEnv.set(e,i)}hasIdentifier(e){return this._identifierEnv.has(e)}}class qe{constructor(){n(this,"nodes",[])}addNode(e){this.nodes.push(e)}formatToWGSL(e,i){return""}}class Sr extends qe{constructor(e){super(),n(this,"name",""),n(this,"fields",[]),this.name=e}static parse(e){if(e.peekToken(0).Type==v.IDENT&&e.peekToken(1).Type==v.LEFTBIG){let i=new Sr(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=v.RIGHTBIG;){let r=st.parse(e);i.fields.push(r)}return e.peekToken(0).Type==v.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1),i}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);r+=s+"struct "+this.name+` {\r
`;for(let a of this.fields)a.arraySize.nodes.length<=0?r+=s+"  "+a.name+": "+hi(a.type)+`,\r
`:a.arraySize.nodes[0]instanceof Rr?r+=s+"  "+a.name+": array<"+hi(a.type)+", "+a.arraySize.nodes[0].value+`>,\r
`:r+=s+"  "+a.name+": array<"+hi(a.type)+", "+a.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return r+=s+`};\r
`,r}}class Oh extends qe{constructor(e,i,r,s){super(),n(this,"name"),n(this,"args"),n(this,"body"),n(this,"returnType"),this.name=e,this.args=i,this.body=r,this.returnType=s}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==v.VOID)&&e.peekToken(1).Type==v.IDENT&&e.peekToken(2).Type==v.LEFTSAMLL){let i=e.peekToken(0).Literal,r=e.peekToken(1).Literal;e.skipToken(2);let s=new Array;if(e.peekToken(0).Type!=v.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=v.EOF;){if(e.peekToken(0).Type==v.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==v.INOUT||e.peekToken(0).Type==v.IN||e.peekToken(0).Type==v.OUT)&&e.skipToken(1);let o=st.parse(e);s.push(o),e.peekToken(0).Type==v.COMMA&&e.skipToken(1)}let a=Oi.parse(e);return new Oh(r,s,a,i)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i),a,o=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":a="ComputeOutput";break;case"vertex":a="VertexOutput";break;case"fragment":a="FragmentOutput";break;default:a="StructOutput";break}if(this.name=="main"&&o){r+="struct "+a+` {\r
`;for(let c of e.layoutsOut)if(c.nodes[0]instanceof st){let d=c.nodes[0];c.qualifier.size==1&&c.qualifier.has("location")&&(r+="  @location("+c.qualifier.get("location")+") "),r+=d.name+": "+hi(d.type)+`,\r
`,e.addIdentifier(d.name,"stout."+d.name)}let u=e.builtinOut;for(let c of u)r+="  "+c+`,\r
`;r+=`};\r
\r
`}let l="";if(this.name=="main"&&(e.workGroupSize!=null?l+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:l+="@"+e.stage+`\r
`),e=new Pf(e),l+=s+"fn "+this.name+"(",this.name!="main"){for(let u=0;u<this.args.length;u++){let c=this.args[u];u>0&&(l+=", "),l+=c.name+": "+hi(c.type),e.addIdentifier(c.name,c.name)}l+=") -> "+hi(this.returnType)}else{let u=e.layoutsIn;for(let d=0;d<u.length;d++){let f=u[d];if(d>0?l+=`,\r
    `:l+=`\r
    `,f.nodes[0]instanceof st){let g=f.nodes[0];f.qualifier.size==1&&f.qualifier.has("location")&&(l+="@location("+f.qualifier.get("location")+") "),l+=g.name+": "+hi(g.type),e.addIdentifier(g.name,g.name)}}u.length>0&&(l+=`,\r
    `);let c=e.builtinIn;for(let d of c)l+=d+`,\r
    `;o?l+=") -> "+a:l+=") "}let h="";this.name=="main"&&o&&(h+="    var stout: "+a+` ;\r
`);for(let u of this.body.nodes)h+=u.formatToWGSL(e,i+1),!(u instanceof aa)&&!(u instanceof Js)&&!(u instanceof qs)&&(h+=`;\r
`);return this.name=="main"&&o&&(h+=`    return stout;\r
`),r+=l+` {\r
`,r+=h,r+=s+`}\r
`,r+=`\r
`,r}}class Nh extends qe{constructor(){super(),n(this,"args",[])}static parse(e){if(e.peekToken(0).Type==v.LEFTSAMLL){e.skipToken(1);let i=new Nh;for(;e.peekToken(0).Type!=v.EOF;){if(e.peekToken(0).Type==v.RIGHTSAMLL){e.skipToken(1);break}let r=Se.parse(e);i.args.push(r),e.peekToken(0).Type==v.COMMA&&e.skipToken(1)}return i}throw"Error parsing function argument table: Unexpected character"}}class js extends qe{constructor(e,i){super(),n(this,"name"),n(this,"args"),this.name=e,this.args=i}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==v.LEFTSAMLL){let i=e.peekToken(0).Literal;e.skipToken(1);let r=Nh.parse(e);return new js(i,r)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof js){let a=this.args.args[0].nodes[0];if(a.name=="sampler2D"){r+=s+"textureSample(";for(let o=0;o<a.args.args.length;o++){let l=a.args.args[o];o>0&&(r+=", "),r+=l.formatToWGSL(e,0)}for(let o=1;o<this.args.args.length;o++){let l=this.args.args[o];o>0&&(r+=", "),r+=l.formatToWGSL(e,0)}return r+=")",r}}r+=s+hi(this.name)+"(";for(let a=0;a<this.args.args.length;a++){let o=this.args.args[a];a>0&&(r+=", "),r+=o.formatToWGSL(e,0)}return r+=")",r}}class st extends qe{constructor(e,i,r=new Se){super(),n(this,"type"),n(this,"name"),n(this,"arraySize"),n(this,"hasIn"),n(this,"hasOut"),n(this,"hasConst"),this.type=e,this.name=i,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=r}static parse(e){let i=new st("",""),r=e.peekToken(0);if(r.Type==v.CONST)e.skipToken(1),i.hasConst=!0;else if(r.Type==v.IN)e.skipToken(1),i.hasIn=!0;else if(r.Type==v.OUT)e.skipToken(1),i.hasOut=!0;else if(r.Type==v.INOUT)e.skipToken(1),i.hasIn=!0,i.hasOut=!0;else if(!r.isDataType())throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.isDataType()&&e.peekToken(1).Type==v.LEFTMEDI){if(i.type=r.Literal,e.skipToken(2),i.arraySize=Se.parse(e),e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=v.IDENT)throw"Unexpected";i.name=e.peekToken(0).Literal,e.skipToken(1)}else if(r.isDataType()&&e.peekToken(1).Type==v.IDENT&&e.peekToken(2).Type==v.LEFTMEDI)i.type=e.peekToken(0).Literal,i.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==v.RIGHTMEDI?e.skipToken(1):(i.arraySize=Se.parse(e),e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1));else if(r.isDataType()&&e.peekToken(1).Type==v.IDENT)i.type=e.peekToken(0).Literal,i.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.Type==v.SEMICOLON)return e.skipToken(1),i;if(r.Type==v.RIGHTSAMLL)return i;if(r.Type==v.ASSIGN){let s=e.peekToken(0);e.skipToken(1);let a=new Dr(i.name),o=Se.parse(e);return e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1),i.addNode(new hs(s,a,o)),i}else if(r.Type==v.COMMA){for(;e.peekToken(0).Type==v.COMMA&&e.peekToken(1).Type==v.IDENT;){let s=new st(i.type,e.peekToken(1).Literal);i.addNode(s),e.skipToken(2),e.peekToken(0).Type==v.ASSIGN&&(e.skipToken(-1),s.addNode(Se.parse(e)))}return i}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);if(this.hasConst?r+=s+"let ":r+=s+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?r+=this.name+": "+hi(this.type):this.arraySize.nodes[0]instanceof Rr?r+=this.name+": array<"+hi(this.type)+", "+this.arraySize.nodes[0].value+">":r+=this.name+": array<"+hi(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof hs)r+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof Se&&this.nodes[0].nodes[0]instanceof hs)r+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof st){r+=`;\r
`;for(let a of this.nodes)r+=a.formatToWGSL(e,i)+`;\r
`}else r+=`;\r
`;return r}}class qs extends qe{constructor(e,i,r,s){super(),n(this,"expression1"),n(this,"condition"),n(this,"expression2"),n(this,"loopBody"),this.expression1=e,this.condition=i,this.expression2=r,this.loopBody=s}static parse(e){if(e.peekToken(0).Type==v.FOR&&e.peekToken(1).Type==v.LEFTSAMLL){e.skipToken(2);let i;e.peekToken(0).Type==v.SEMICOLON?(e.skipToken(1),i=new Se):e.peekToken(0).isDataType()&&e.peekToken(1).Type==v.IDENT&&e.peekToken(2).Type==v.ASSIGN?(i=new st(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),i.addNode(Se.parse(e)),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1)):(i=Se.parse(e),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1));let r;e.peekToken(0).Type==v.SEMICOLON?(e.skipToken(1),r=new Se):(r=Se.parse(e),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1));let s;e.peekToken(0).Type==v.SEMICOLON?(e.skipToken(1),s=new Se):(s=Se.parse(e),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==v.RIGHTSAMLL&&e.skipToken(1);let a;return e.peekToken(0).Type==v.LEFTBIG?a=Oi.parse(e):a=new Oi,new qs(i,r,s,a)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);r+=s+"for (",r+=this.expression1.formatToWGSL(e,0)+"; ",r+=this.condition.formatToWGSL(e,0)+"; ",r+=this.expression2.formatToWGSL(e,0)+")",r+=` { \r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,i+1),!(a instanceof aa)&&!(a instanceof Js)&&!(a instanceof qs)&&(r+=`;\r
`);return r+=s+`} \r
`,r}}class Js extends qe{constructor(e,i){super(),n(this,"conditionExpr"),n(this,"loopBody"),this.conditionExpr=e,this.loopBody=i}static parse(e){if(e.peekToken(0).Type==v.WHILE){e.skipToken(1),e.peekToken(0).Type==v.LEFTSAMLL&&e.skipToken(1);let i=Se.parse(e);e.peekToken(0).Type==v.RIGHTSAMLL&&e.skipToken(1);let r=Oi.parse(e);return new Js(i,r)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);r+=s+`loop {\r
`,r+=s+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,i+1),!(a instanceof aa)&&!(a instanceof Js)&&!(a instanceof qs)&&(r+=`;\r
`);return r+=s+`}\r
`,r}}class aa extends qe{constructor(e,i,r){super(),n(this,"conditionExpr"),n(this,"trueBranch"),n(this,"falseBranch"),this.conditionExpr=e,this.trueBranch=i,this.falseBranch=r}static parse(e){if(e.peekToken(0).Type==v.IF){e.skipToken(1),e.peekToken(0).Type==v.LEFTSAMLL&&e.skipToken(1);let i=Se.parse(e),r,s=new Oi;if(e.peekToken(0).Type==v.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==v.LEFTBIG?r=Oi.parse(e):(r=new Oi,e.peekToken(0).Type==v.RETURN?r.addNode(Do.parse(e)):r.addNode(Se.parse(e))),e.peekToken(0).Type==v.ELSE)if(e.skipToken(1),e.peekToken(0).Type==v.LEFTBIG)s=Oi.parse(e);else throw"not impl";return new aa(i,r,s)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);r+=s+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let a of this.trueBranch.nodes)r+=a.formatToWGSL(e,i+1)+`;\r
`;if(this.falseBranch.nodes.length>0){r+=s+`} else {\r
`;for(let a of this.falseBranch.nodes)r+=a.formatToWGSL(e,i+1)+`;\r
`}return r+=s+`}\r
`,r}}class Se extends qe{constructor(){super()}static parse(e){let i=new Array,r=new Array,s=0;for(;e.peekToken(0).Type!=v.EOF;){let a=e.peekToken(0);if(a.Type==v.SEMICOLON||a.Type==v.RIGHTMEDI||a.Type==v.COMMA||a.Type==v.COLON||a.Type==v.RIGHTBIG)break;if(a.isOperation()){if(a.isOperation()){if(a.Type==v.INC||a.Type==v.DEC){let o=a;e.skipToken(1);let l=Se.parse(e);r.push(new ya(o,void 0,l));continue}else if(i.length>0){if(i[i.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel)Se.unionOperation(i,r);else if(i.length>0&&i[i.length-1].Literal=="-"){let o=i.pop(),l=r.pop();r.push(new ya(o,void 0,l))}}i.push(a),e.skipToken(1)}}else if(a.Type==v.LITERAL){r.push(new Rr(a.Literal)),e.skipToken(1);continue}else if(a.Type==v.LEFTSAMLL){s++,i.push(a),e.skipToken(1);continue}else if(a.Type==v.RIGHTSAMLL){if(s<=0)break;for(s--;Se.unionOperation(i,r););if(i[i.length-1].Type==v.LEFTSAMLL){i.pop();let o=new Gv;o.addNode(r.pop()),r.push(o)}e.skipToken(1);continue}else if(a.Type==v.IDENT){if(e.peekToken(1).Type==v.INC||e.peekToken(1).Type==v.DEC){let o=e.peekToken(1),l=new Dr(a.Literal);r.push(new ya(o,l,void 0)),e.skipToken(2);continue}else if(e.peekToken(1).Type==v.LEFTSAMLL){r.push(js.parse(e));continue}else if(e.peekToken(1).Type==v.DOT){r.push(ro.parse(e));continue}else if(e.peekToken(1).Type==v.LEFTMEDI){r.push(Zs.parse(e));continue}r.push(new Dr(a.Literal)),e.skipToken(1);continue}else{if(a.isBuiltinType()&&e.peekToken(1).Type==v.LEFTSAMLL){r.push(js.parse(e));continue}if(a.isAssignOperation()){let o=a;e.skipToken(1);let l=r.pop(),h=Se.parse(e);r.push(new hs(o,l,h));continue}if(a.Type==v.LEFTBIG&&(e.peekToken(1).Type==v.LITERAL||e.peekToken(1).Type==v.SUB&&e.peekToken(2).Type==v.LITERAL)){r.push(io.parse(e));continue}if(a.Type==v.QUEMARK){i.length>0&&i[i.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel&&Se.unionOperation(i,r),e.skipToken(1);let o=r.pop(),l=Se.parse(e);e.peekToken(0).Type==v.COLON&&e.skipToken(1);let h=Se.parse(e);if(r.push(new Vv(o,l,h)),e.peekToken(-1).Type==v.SEMICOLON)break;continue}if(a.Type==v.LEFTMEDI){e.skipToken(1);let o=Se.parse(e);e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1);let l=r.pop();r.push(new Zs(l,o));continue}throw"An unexpected character"}}for(;i.length>0&&Se.unionOperation(i,r););if(i.length<=0&&r.length==1){let a=new Se;return a.addNode(r.pop()),a}throw"Error parsing expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,i){return this.nodes[0].formatToWGSL(e,i)}static unionOperation(e,i){if(e.length<0||i.length<2){if(e.length>0&&e[e.length-1].Literal=="-"){let r=e.pop(),s=i.pop();return i.push(new ya(r,void 0,s)),!0}return!1}if(e[e.length-1].isOperation()){let r=i.pop(),s=e.pop(),a=i.pop();return s.Type==v.DOT?i.push(new ro(a,r)):i.push(new hs(s,a,r)),!0}return!1}}class Gv extends qe{constructor(){super()}formatToWGSL(e,i){return(i<=0?"":"    ".repeat(i))+"("+this.nodes[0].formatToWGSL(e,0)+")"}}class Dr extends qe{constructor(e){super(),n(this,"name"),this.name=e}formatToWGSL(e,i){return(i<=0?"":"    ".repeat(i))+e.findIdentifier(this.name)}}class Rr extends qe{constructor(e){super(),n(this,"value"),this.value=e}static parse(e){let i=e.peekToken(0);if(i.Type==v.SUB&&e.peekToken(1).Type==v.LITERAL){let r=new Rr("-"+e.peekToken(1).Literal);return e.skipToken(2),r}else if(i.Type==v.LITERAL){let r=new Rr(i.Literal);return e.skipToken(1),r}throw"Error parsing literal constants: Unexpected characters("+i.Literal+")"}formatToWGSL(e,i){return(i<=0?"":"    ".repeat(i))+this.value}}class io extends Rr{constructor(e){super(""),n(this,"arrayValue"),this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==v.LEFTBIG&&e.peekToken(1).Type==v.LITERAL||e.peekToken(0).Type==v.LEFTBIG&&e.peekToken(1).Type==v.SUB&&e.peekToken(2).Type==v.LITERAL){e.skipToken(1);let i=[];for(;e.peekToken(0).Type!=v.RIGHTBIG;){if(e.peekToken(0).Type==v.LEFTSAMLL){i.push(io.parse(e));continue}if(i.push(Rr.parse(e)),e.peekToken(0).Type==v.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==v.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new io(i)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);this.arrayValue[0].value.includes(".")?r+=s+"array<f32, "+this.arrayValue.length.toString()+">(":r+=s+"array<i32, "+this.arrayValue.length.toString()+">(";for(let a=0;a<this.arrayValue.length;a++)a>0&&(r+=", "),r+=this.arrayValue[a].formatToWGSL(e,0);return r+=")",r}}class Fh extends qe{constructor(){super()}static parse(e){if(e.peekToken(0).Type==v.CONTINUE&&e.peekToken(1).Type==v.SEMICOLON)return e.skipToken(2),new Fh;throw"Error parsing continue: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);return r+=s+"continue",r}}class Do extends qe{constructor(e){super(),n(this,"value"),this.value=e}static parse(e){if(e.peekToken(0).Type==v.RETURN){e.skipToken(1);let i=Se.parse(e);return e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1),new Do(i)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);return r+=s+"return "+this.value.formatToWGSL(e,0),r}}class ya extends qe{constructor(e,i,r){super(),n(this,"op"),n(this,"leftValue"),n(this,"rightValue"),this.op=e,this.leftValue=i,this.rightValue=r}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let a=this.leftValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else{let a=this.rightValue.formatToWGSL(e,0);r+=s+a+" = "+a+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?r+=s+this.leftValue.formatToWGSL(e,0)+this.op.Literal:r+=s+this.op.Literal+this.rightValue.formatToWGSL(e,0);return r}}class hs extends qe{constructor(e,i,r){super(),n(this,"op"),n(this,"leftValue"),n(this,"rightValue"),this.op=e,this.leftValue=i,this.rightValue=r}formatToWGSL(e,i){let r="",s=i<=0?"":"    ".repeat(i);return r+=s+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),r}}class Vv extends qe{constructor(e,i,r){super(),n(this,"condition"),n(this,"expression1"),n(this,"expression2"),this.condition=e,this.expression1=i,this.expression2=r}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,i){return""}}class ro extends qe{constructor(e,i){super(),n(this,"leftValue"),n(this,"rightValue"),this.leftValue=e,this.rightValue=i}static parse(e){if(e.peekToken(0).Type==v.IDENT&&e.peekToken(1).Type==v.DOT&&e.peekToken(2).Type==v.IDENT){let i=new Dr(e.peekToken(0).Literal),r=new Dr(e.peekToken(2).Literal);return e.skipToken(3),new ro(i,r)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,i){return(i<=0?"":"    ".repeat(i))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Zs extends qe{constructor(e,i){super(),n(this,"leftValue"),n(this,"indexValue"),this.leftValue=e,this.indexValue=i}static parse(e){if(e.peekToken(0).Type==v.IDENT&&e.peekToken(1).Type==v.LEFTMEDI){let i=new Dr(e.peekToken(0).Literal);e.skipToken(2);let r=Se.parse(e);e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1);let s=new Zs(i,r);for(;e.peekToken(0).Type==v.LEFTMEDI;)e.skipToken(1),r=Se.parse(e),e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1),s=new Zs(s,r);return s}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,i){return(i<=0?"":"    ".repeat(i))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Oi extends qe{constructor(){super()}static parse(e){if(e.peekToken(0).Type==v.LEFTBIG){e.skipToken(1);let i=new Oi;for(let r=1;r>0&&e.peekToken(0).Type!=v.EOF;){let s=e.peekToken(0);if(s.Type==v.LEFTBIG){r++,e.skipToken(1);continue}if(s.Type==v.RIGHTBIG){r--,e.skipToken(1);continue}if(s.Type==v.SEMICOLON){e.skipToken(1);continue}if(s.isDataType()&&e.peekToken(1).Type==v.IDENT){i.addNode(st.parse(e));continue}if(s.Type==v.CONST&&e.peekToken(1).isDataType()&&e.peekToken(2).Type==v.IDENT){i.addNode(st.parse(e));continue}else if(s.Type==v.IDENT&&e.peekToken(1).Type==v.ASSIGN){i.addNode(Se.parse(e)),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1);continue}else if(s.Type==v.IDENT&&e.peekToken(1).Type==v.LEFTMEDI){let a=Zs.parse(e);if(e.peekToken(0).Type==v.ASSIGN){let o=e.peekToken(0);e.skipToken(1);let l=Se.parse(e);e.peekToken(0).Type==v.RIGHTMEDI&&e.skipToken(1),i.addNode(new hs(o,a,l));continue}i.addNode(a);continue}else if(s.Type==v.IDENT&&e.peekToken(1).Type==v.DOT){let a=Se.parse(e);i.addNode(a);continue}else if(s.Type==v.IDENT&&e.peekToken(1).isAssignOperation()){let a=e.peekToken(1),o=new Dr(s.Literal);e.skipToken(2);let l=Se.parse(e);e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1),i.addNode(new hs(a,o,l));continue}else if(s.Type==v.IDENT&&(e.peekToken(1).Type==v.INC||e.peekToken(1).Type==v.DEC)&&e.peekToken(2).Type==v.SEMICOLON){let a=e.peekToken(1);i.addNode(new ya(a,new Dr(s.Literal),void 0)),e.skipToken(3);continue}else if(s.Type==v.RETURN){i.addNode(Do.parse(e));continue}else if(s.Type==v.CONTINUE){i.addNode(Fh.parse(e));continue}else if(s.Type==v.WHILE){i.addNode(Js.parse(e));continue}else if(s.Type==v.FOR){i.addNode(qs.parse(e));continue}else if(s.Type==v.IF){i.addNode(aa.parse(e));continue}else if(s.Type==v.IDENT&&e.peekToken(1).Type==v.LEFTSAMLL){i.addNode(js.parse(e)),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+s.Literal+")"}return i}throw"Error parsing block: Unexpected symbol"}}class kh extends qe{constructor(e,i){super(),n(this,"type"),n(this,"qualifier"),this.type=i,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==v.PRECISION&&e.peekToken(1).Type==v.IDENT&&e.peekToken(2).isBuiltinType()){let i=new kh(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==v.SEMICOLON&&e.skipToken(1),i}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,i){return""}}class Ro extends qe{constructor(){super(),n(this,"scope",""),n(this,"qualifier",new Map)}addQualifier(e,i=""){this.qualifier.set(e,i)}static parse(e){if(e.peekToken(0).Type==v.LAYOUT&&e.peekToken(1).Type==v.LEFTSAMLL){let i=new Ro;e.skipToken(2);do if(e.peekToken(0).Type==v.IDENT){if(e.peekToken(1).Type==v.ASSIGN&&e.peekToken(2).Type==v.LITERAL){let r=e.peekToken(0).Literal,s=e.peekToken(2).Literal;if(i.addQualifier(r,s),e.skipToken(3),e.peekToken(0).Type==v.COMMA){e.skipToken(1);continue}let a=e.peekToken(0);a.Line=0}else if(e.peekToken(1).Type==v.RIGHTSAMLL){let r=e.peekToken(0).Literal;i.addQualifier(r,""),e.skipToken(1);break}else if(e.peekToken(1).Type==v.COMMA){let r=e.peekToken(0).Literal;i.addQualifier(r,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=v.RIGHTSAMLL);if(e.peekToken(0).Type==v.RIGHTSAMLL&&e.skipToken(1),i.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==v.SEMICOLON)return e.skipToken(1),i;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==v.IDENT&&e.peekToken(2).Type==v.SEMICOLON){let r=new st(e.peekToken(0).Literal,e.peekToken(1).Literal);return i.addNode(r),e.skipToken(3),i}else if(e.peekToken(0).Type==v.IDENT&&e.peekToken(1).Type==v.LEFTBIG){let r=Sr.parse(e);return i.addNode(r),e.peekToken(0).Type==v.IDENT&&e.peekToken(1).Type==v.SEMICOLON&&(r.addNode(new st(r.name,e.peekToken(0).Literal)),e.skipToken(2)),i}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,i){let r="";if(this.qualifier.size==1&&this.qualifier.has("location"))r+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))r+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))r+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))r+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))r+="@workgroup_size(",r+=this.qualifier.get("local_size_x")+", ",r+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",r+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",r+=")";else if(this.nodes.length<=0)return"";let s=this.nodes[0];if(s instanceof st){switch(s.type){case"sampler":case"texture2D":r+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ";break}e.addIdentifier(s.name,s.name),r+=s.name+": "+hi(s.type)+`;\r
`}else if(s instanceof Sr){if(this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ",s.nodes.length<=0){let a="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(a);)e.layoutUniformCount++,a="unif"+e.layoutUniformCount.toString();for(let o of s.fields)e.addIdentifier(o.name,a+"."+o.name);r+=a+": "+s.name+`;\r
`,e.layoutUniformCount++}else{let a=s.nodes[0];r+=a.name+": "+a.type+`;\r
`}return r}return r}}function hi(t){switch(t){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return t}class Hv{constructor(e){n(this,"_lexer"),n(this,"_rootNode"),this._lexer=e,this._rootNode=new qe,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==v.EOF;){if(this.peekToken(0).Type==v.SEMICOLON){this.skipToken(1);continue}let e=this.parseStatement();e!==null&&this._rootNode.addNode(e)}}parseStatement(){let e=this.peekToken();if(e.Type==v.LAYOUT&&this.peekToken(1).Type==v.LEFTSAMLL)return Ro.parse(this._lexer);if(e.Type==v.STRUCT)return this.skipToken(1),Sr.parse(this._lexer);if((e.isBuiltinType()||e.Type==v.VOID)&&this.peekToken(1).Type==v.IDENT&&this.peekToken(2).Type==v.LEFTSAMLL)return Oh.parse(this._lexer);if(e.Type==v.CONST&&this.peekToken(1).isDataType())return st.parse(this._lexer);if(e.isDataType()&&this.peekToken(1).Type==v.IDENT)return st.parse(this._lexer);if(e.Type==v.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==v.IDENT)return st.parse(this._lexer);if(e.Type==v.PRECISION)return kh.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(e){this._lexer.skipToken(e)}peekToken(e=0){return this._lexer.peekToken(e)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class Ml{static convertGLSL(e){var i=new Qv(e),r=new Fv(i),s=new Hv(r),a=new zv(s);return a.generateWGSL()}}n(Ml,"VertexShader","VertexShader"),n(Ml,"FragmentShader","FragmentShader");class Ac{constructor(){n(this,"setID",0),n(this,"bindingID",0),n(this,"name",""),n(this,"type","")}}class _c{constructor(){n(this,"name",""),n(this,"type",""),n(this,"locationID",0),n(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class Yv{constructor(){n(this,"uniformInfo",[]),n(this,"inputAttribute",[]),n(this,"outputAttribute",[]),n(this,"sourceCode","")}}var Bi=(t=>(t[t.vertex=0]="vertex",t[t.fragment=1]="fragment",t[t.computer=2]="computer",t))(Bi||{});class Xv{constructor(){n(this,"blendMode",Te.NONE),n(this,"depthCompare",zi.less),n(this,"depthWriteEnabled",!0),n(this,"frontFace","ccw"),n(this,"cullMode",zt.back),n(this,"topology",Uh.triangle_list),n(this,"depthBias",10),n(this,"useLight",!1),n(this,"useProbe",!1),n(this,"acceptGI",!1),n(this,"acceptShadow",!1),n(this,"castShadow",!1),n(this,"castReflection",!1),n(this,"receiveEnv",!1),n(this,"renderLayer",1e3),n(this,"renderOrder",2e3),n(this,"unclippedDepth",!1),n(this,"transparent",!1),n(this,"multisample",0),n(this,"label"),n(this,"useZ",!0),n(this,"splitTexture",!1),n(this,"alphaCutoff"),n(this,"useFragDepth",!1),n(this,"writeMasks",[])}setFromMapValues(e){e.has("blendMode")&&(this.blendMode=this.convertBlendMode(e.get("blendMode"))),e.has("depthCompare")&&(this.depthCompare=e.get("depthCompare")),e.has("depthWriteEnabled")&&(this.depthWriteEnabled=e.get("depthWriteEnabled")),e.has("frontFace")&&(this.frontFace=e.get("frontFace")),e.has("cullMode")&&(this.cullMode=e.get("cullMode")),e.has("topology")&&(this.topology=e.get("topology")),e.has("depthBias")&&(this.depthBias=e.get("depthBias")),e.has("useLight")&&(this.useLight=e.get("useLight")),e.has("useProbe")&&(this.useProbe=e.get("useProbe")),e.has("acceptGI")&&(this.acceptGI=e.get("acceptGI")),e.has("acceptShadow")&&(this.acceptShadow=e.get("acceptShadow")),e.has("castShadow")&&(this.castShadow=e.get("castShadow")),e.has("receiveEnv")&&(this.receiveEnv=e.get("receiveEnv")),e.has("renderLayer")&&(this.renderLayer=e.get("renderLayer")),e.has("renderOrder")&&(this.renderOrder=e.get("renderOrder")),e.has("unclippedDepth")&&(this.unclippedDepth=e.get("unclippedDepth")),e.has("multisample")&&(this.multisample=e.get("multisample")),e.has("label")&&(this.label=e.get("label")),e.has("useZ")&&(this.useZ=e.get("useZ"))}convertBlendMode(e){switch(e){case"ABOVE":return Te.ABOVE;case"ALPHA":return Te.ALPHA;case"NORMAL":return Te.NORMAL;case"ADD":return Te.ADD;case"BELOW":return Te.BELOW;case"ERASE":return Te.ERASE;case"MUL":return Te.MUL;case"SCREEN":return Te.SCREEN;case"DIVD":return Te.DIVD;case"SOFT_ADD":return Te.SOFT_ADD}return Te.NONE}}class Kv extends Or{constructor(){super(),n(this,"uniformNodes",[]),n(this,"_onChange",!0),this.bufferType=Hi.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let i=0;for(const r in e){const s=e[r];s||console.error(r,"is empty"),i+=s.size*4}i=Math.floor(i/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,i/4,null,"MaterialDataUniformGPUBuffer");for(const r in e){const s=e[r];s||console.error(r,"is empty");let a=this.memory.allocation_node(s.size*4);s.memoryInfo=a,s.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Ri{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}n(Ri,"renderShaderModulePool"),n(Ri,"renderShader");const Uf=class{constructor(){n(this,"reference")}static getInstance(){return this._ins||(this._ins=new Uf),this._ins}attached(t,e){this.reference||(this.reference=new Map);let i=this.reference.get(t);i||(i=new Map),i.set(e,t),this.reference.set(t,i)}detached(t,e){let i=this.reference.get(t);i&&i.delete(e)}hasReference(t){let e=this.reference.get(t);return e?e.size>0:!1}getReferenceCount(t){let e=this.reference.get(t);return e?e.size:0}getReference(t){return this.reference.get(t)||null}};let Me=Uf;n(Me,"_ins");class Pl{static getSharePipeline(e){return this.pipelineMap.get(e)||null}static setSharePipeline(e,i){this.pipelineMap.set(e,i)}}n(Pl,"pipelineMap",new Map);class ct extends wf{constructor(e,i){super(),n(this,"passType",xe.COLOR),n(this,"useRz",!1),n(this,"vsName"),n(this,"fsName"),n(this,"shaderState"),n(this,"textures"),n(this,"pipeline"),n(this,"bindGroupLayouts"),n(this,"envMap"),n(this,"prefilterMap"),n(this,"_sourceVS"),n(this,"_sourceFS"),n(this,"_destVS"),n(this,"_destFS"),n(this,"_vsShaderModule"),n(this,"_fsShaderModule"),n(this,"_textureGroup",-1),n(this,"_textureChange",!1),n(this,"_groupsShaderReflectionVarInfos"),n(this,"outBufferMask"),n(this,"_cacheEntries"),this.vsName=e.toLowerCase(),this.fsName=i.toLowerCase(),this.vsName in W||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in W||console.error("Shader Not Register, Please Register Shader!",this.fsName),W[this.vsName]&&(this._sourceVS=W[this.vsName]),W[this.fsName]&&(this._sourceFS=W[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new Xv,this.materialDataUniformBuffer=new Kv,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==zt.none}set doubleSide(e){let i=e?zt.none:this.cullMode;this.shaderState.cullMode!=i&&(this._valueChange=!0),this.shaderState.cullMode=i}get depthWriteEnabled(){return this.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.shaderState.depthWriteEnabled!=e&&(this._valueChange=!0),this.shaderState.depthWriteEnabled=e}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=Te.NORMAL&&e!=Te.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",i=""){this.vsEntryPoint=e,this.fsEntryPoint=i}setUniform(e,i){super.setUniform(e,i),this.materialDataUniformBuffer.onChange()}setTexture(e,i){i&&this.textures[e]!=i&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=i,e=="envMap"?this.envMap=i:e=="prefilterMap"&&(this.prefilterMap=i),i.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,i){let r=this.createGroupLayouts();this.createPipeline(e,i,r)}reBuild(e,i){this.compileShader(Bi.vertex,this._destVS,i),this.compileShader(Bi.fragment,this._destFS,i),this.genRenderPipeline(e,i)}apply(e,i,r){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=si.genRenderShaderVariant(this),this.reBuild(e,i),this._valueChange=!1,r&&r())}preCompile(e){this.preDefine(e),this.preCompileShader(Bi.vertex,this._sourceVS.concat()),this.preCompileShader(Bi.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,i){return i.renderTargetTextures.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),li.parse(e,this.defineValue)}setBindGroup(e,i){this.bindGroups[e]=i}checkBuffer(e,i){}preCompileShader(e,i,r){let s=i;if(s.indexOf("version ")!=-1){var a=Ml.convertGLSL(s);s=a.sourceCode}for(const o in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,o)){const l=this.constValues[o];s=s.replaceAll(`&${o}`,l.toString())}switch(e){case Bi.vertex:this._destVS=s;break;case Bi.fragment:this._destFS=s;break}}compileShader(e,i,r){let s=i;s=this.applyPostDefine(s,r);let a=i;for(let l in this.defineValue)a+=`${l}=${this.defineValue[l]},`;let o=Ri.renderShaderModulePool.get(a);switch(o||(s=this.applyPostDefine(s,r),o=D.device.createShaderModule({label:e==Bi.vertex?this.vsName:this.fsName,code:s}),o.getCompilationInfo().then(l=>{l.messages.length>0&&(console.log(s),console.log(l))}),Ri.renderShaderModulePool.set(a,o)),e){case Bi.vertex:this._vsShaderModule=o,this._destVS=s;break;case Bi.fragment:this._fsShaderModule=o,this._destFS=s;break}}getGroupLayout(e,i){let r=[];for(let s=0;s<i.length;s++){const a=i[s];if(a)if(a.varType=="uniform"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let o=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:o,buffer:{type:"uniform"}};r.push(l)}else if(a.varType=="storage-read"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let o=this._bufferDic.get(a.varName).visibility,l={binding:a.binding,visibility:o,buffer:{type:"read-only-storage"}};r.push(l)}else if(a.varType=="var")switch(a.dataType){case"sampler":{let o=a.varName.replace("Sampler",""),l=this.textures[o]?this.textures[o]:I.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.samplerBindingLayout};r.push(h),this._textureGroup=e}break;case"sampler_comparison":{let o=a.varName.replace("Sampler",""),l=this.textures[o]?this.textures[o]:I.res.redTexture,h={binding:a.binding,visibility:l.visibility,sampler:l.sampler_comparisonBindingLayout};r.push(h),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let o=this.textures[a.varName]?this.textures[a.varName]:I.res.redTexture,l={binding:a.binding,visibility:o.visibility,texture:o.textureBindingLayout};r.push(l),this._textureGroup=e,Me.getInstance().attached(o,this)}break;case"texture_external":{let o=this.textures[a.varName]?this.textures[a.varName]:I.res.redTexture,l={binding:a.binding,visibility:o.visibility,externalTexture:{}};r.push(l),this._textureGroup=e,Me.getInstance().attached(o,this)}break;default:{let o=this.textures[a.varName]?this.textures[a.varName]:I.res.redTexture,l={binding:a.binding,visibility:o.visibility,texture:o.textureBindingLayout};r.push(l),this._textureGroup=e,Me.getInstance().attached(o,this)}break}else{debugger;console.error("bind group can't empty")}}return r}genGroups(e,i,r=!1){if(!this.bindGroups[e]||r){const s=i[e];let a=[];for(let l=0;l<s.length;l++){const h=s[l];if(h){if(h.varType=="uniform"){let u=this._bufferDic.get(h.varName);if(u){if(u.bufferType==Hi.MaterialDataUniformGPUBuffer){let d=[];for(let f=0;f<h.dataFields.length;f++){const g=h.dataFields[f];this.uniforms[g.name]||console.error(`shader-${this.vsName}:${this.fsName} ${g.name}is empty`),d.push(this.uniforms[g.name])}this.materialDataUniformBuffer.initDataUniform(d)}let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${h.varName} is missing!`)}else if(h.varType=="storage-read"){let u=this._bufferDic.get(h.varName);if(u){let c={binding:h.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};a.push(c),this.checkBuffer(h.varName,u)}else console.error(`buffer ${h.varName} is missing!`)}else if(h.varType=="var")if(h.dataType=="sampler"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c||(c=I.res.blackTexture,this.setTexture(u,c)),c){let d={binding:h.binding,resource:c.gpuSampler};a.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else if(h.dataType=="sampler_comparison"){let u=h.varName.replace("Sampler",""),c=this.textures[u];if(c){let d={binding:h.binding,resource:c.gpuSampler_comparison};a.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}else{let u=this.textures[h.varName];if(u||(u=I.res.whiteTexture,this.setTexture(h.varName,u)),u){let c={binding:h.binding,resource:u.getGPUView()};a.push(c)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${h.varName} is missing! `)}}}let o=D.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:a});this.bindGroups[e]=o}}createPipeline(e,i,r){let s=e,a=this.shaderState,o=[];for(const u of i.renderTargetTextures)o.push({format:u.format});for(let u=0;u<o.length;u++){const c=o[u];a.writeMasks&&a.writeMasks.length>0&&(c.writeMask=a.writeMasks[u])}if(i.outColor!=-1){let u=o[i.outColor];a.blendMode!=Te.NONE?u.blend=Mf.getBlend(a.blendMode):delete u.blend}let l={label:this.vsName+"|"+this.fsName,layout:r,primitive:{topology:a.topology,cullMode:a.cullMode,frontFace:a.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(l.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:s.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(l.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:o}),a.multisample>0&&(l.multisample={count:a.multisample}),(i.zPreTexture||i.depthTexture)&&(a.blendMode!=Te.NONE,I.setting.render.zPrePass&&i.zPreTexture&&a.useZ?l.depthStencil={depthWriteEnabled:!1,depthCompare:zi.less,format:i.zPreTexture.format}:l.depthStencil={depthWriteEnabled:a.depthWriteEnabled,depthCompare:a.depthCompare,format:i.depthTexture.format});let h=Pl.getSharePipeline(this.shaderVariant);h?this.pipeline=h:(this.pipeline=T.createPipeline(l),Pl.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[Bo.getGlobalDataBindGroupLayout()];for(let r=1;r<e.groups.length;r++){let s=e.groups[r];if(s){let a=this.getGroupLayout(r,s);this._groupsShaderReflectionVarInfos[r]=s;let o=D.device.createBindGroupLayout({entries:a,label:`vs${this.vsName} fs${this.fsName} ${s.length}`});this.bindGroupLayouts[r]=o}else console.error("can't set empty group!",r)}let i=D.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),i}preDefine(e){let i=e.hasAttribute(z.TEXCOORD_1),r=e.hasAttribute(z.joints0),s=e.hasAttribute(z.a_morphPositions_0),a=e.hasAttribute(z.TANGENT),o=e.hasAttribute(z.color),l=this.shaderState.acceptGI,h=this.shaderState.useLight;i&&(this.defineValue.USE_SECONDUV=!0),r&&s?this.defineValue.USE_METAHUMAN=!0:(this.defineValue.USE_SKELETON=r,this.defineValue.USE_MORPHTARGETS=s),"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=a),this.defineValue.USE_GI=l,this.defineValue.USE_CASTSHADOW=this.shaderState.castShadow,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=h,this.defineValue.USE_VERTXCOLOR=o,I.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),I.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,I.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,I.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=I.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=I.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=I.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=Jt.Cascades>1,this.defineValue.USE_IES_PROFILE=Fs.use}genReflection(){this.shaderVariant=si.genRenderShaderVariant(this);let e=si.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let i=li.parse(this._destVS,this.defineValue);i=li.parse(i,this.defineValue),si.getShaderReflection2(i,this);let r=li.parse(this._destFS,this.defineValue);r=li.parse(r,this.defineValue),si.getShaderReflection2(r,this),si.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const i in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,i)){const r=this.textures[i];if(Me.getInstance().detached(r,this),e&&!Me.getInstance().hasReference(r))r.destroy(e);else{r.destroy(!1);let s=Me.getInstance().getReference(r);if(s){let a=[];s.forEach((o,l)=>{"name"in o?a.push(o.name):a.push("NaN")})}}}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(e),this.materialDataUniformBuffer=null}static destroyShader(e){Ri.renderShader.has(e)&&(Ri.renderShader.get(e).destroy(),Ri.renderShader.delete(e))}static getShader(e){return Ri.renderShader.get(e)}static createShader(e,i){let r=new ct(e,i);return Ri.renderShader.set(r.instanceID,r),r.instanceID}}class Wv extends ct{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.passType=xe.GI,this.setUniformVector3("eyesPos",new p),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let e=this.shaderState;e.frontFace="ccw",e.cullMode=zt.front,e.depthWriteEnabled=!1,e.depthCompare=zi.less}}class jv extends ct{constructor(){super("gbuffer_vs","gbuffer_fs"),n(this,"transparency"),this.setShaderEntry("VertMain","FragMain"),this.passType=xe.GI,this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=Te.NONE,this.setTexture("normalMap",I.res.normalTexture)}}class qv extends ct{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.passType=xe.SHADOW,this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",p.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class Jv extends ct{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.passType=xe.POINT_SHADOW,this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",p.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class Zv extends ct{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.passType=xe.DEPTH,this.setShaderEntry("main"),this.useRz=!1;let e=this.shaderState;e.receiveEnv=!1}}class An{static createGIPass(e,i){if(Zi.hasMask(e.rendererMask,vt.Sky)){if(!i.passShader.get(xe.GI)){let r=i.getSubShaders(xe.COLOR)[0],s=new Wv;s.setTexture("baseMap",r.getTexture("baseMap")),s.cullMode=r.cullMode,s.frontFace=r.frontFace,i.addRenderPass(s,0),s.preCompile(e.geometry)}}else this.castGBufferPass(e,i)}static castGBufferPass(e,i){let r=i.getDefaultShaders();for(let s=0;s<r.length;s++){const a=r[s];let o=i.getSubShaders(xe.GI);if(!o||o.length==0||o.length<s){let l=new jv;l.setTexture("baseMap",a.getTexture("baseMap")),l.setTexture("normalMap",a.getTexture("normalMap")),l.setTexture("emissiveMap",a.getTexture("emissiveMap")),l.setUniform("baseColor",a.getUniform("baseColor")),l.setUniform("envIntensity",a.getUniform("envIntensity")),l.setUniform("emissiveColor",a.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",a.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",a.getUniform("alphaCutoff")),l.cullMode=a.cullMode,l.frontFace=a.frontFace,l.preCompile(e.geometry),i.addRenderPass(l)}}}static createShadowPass(e,i){let r=Zi.hasMask(e.rendererMask,vt.SkinnedMesh),s=e.geometry.hasAttribute(z.TANGENT),a=e.geometry.hasAttribute(Fe.MORPH_POSITION_PREFIX+"0"),o=e.geometry.hasAttribute(Fe.MORPH_NORMAL_PREFIX+"0"),l=i.getSubShaders(xe.COLOR);for(let h=0;h<l.length;h++){const u=l[h];let c=i.getSubShaders(xe.SHADOW);if(!c||c.length<h+1){let f=new qv;f.setTexture("baseMap",u.getTexture("baseMap")),f.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),s&&f.setDefine("USE_TANGENT",s),r&&f.setDefine("USE_SKELETON",r),a&&f.setDefine("USE_MORPHTARGETS",a),o&&f.setDefine("USE_MORPHNORMALS",o),u.cullMode=="none"?f.shaderState.cullMode="none":u.cullMode=="back"?f.shaderState.cullMode="front":u.cullMode=="front"&&(f.shaderState.cullMode="back"),f.preCompile(e.geometry),i.addRenderPass(f)}let d=i.getSubShaders(xe.POINT_SHADOW);if(!d||d.length<h+1){let f=new Jv;f.setTexture("baseMap",u.getTexture("baseMap")),f.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),f.setDefine("USE_ALPHACUT",1);for(let g=0;g<1;g++)s&&f.setDefine("USE_TANGENT",s),r&&f.setDefine("USE_SKELETON",r),a&&f.setDefine("USE_MORPHTARGETS",a),o&&f.setDefine("USE_MORPHNORMALS",o),f.shaderState.cullMode="front",f.preCompile(e.geometry);i.addRenderPass(f)}}}static createDepthPass(e,i){let r=i.getSubShaders(xe.COLOR),s=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(Fe.MORPH_POSITION_PREFIX+"0"),o=e.geometry.hasAttribute(Fe.MORPH_NORMAL_PREFIX+"0"),l=Zi.hasMask(e.rendererMask,vt.SkinnedMesh);for(let h=0;h<r.length;h++){const u=r[h];let c=i.getSubShaders(xe.DEPTH);if(!c&&u.shaderState.useZ&&(!c||c.length<h)){let d=new Zv;d.setTexture("baseMap",u.getTexture("baseMap")),s||d.setDefine("USE_TANGENT",s),l&&d.setDefine("USE_SKELETON",l),a&&d.setDefine("USE_MORPHTARGETS",a),o&&d.setDefine("USE_MORPHNORMALS",o),d.cullMode=u.cullMode,d.frontFace=u.frontFace,d.preCompile(e.geometry),i.addRenderPass(d)}}}}class $v{constructor(e){n(this,"renderer"),n(this,"owner"),n(this,"uuid"),this.renderer=e,this.uuid=e.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(e){this.owner&&this.leaveNode(),this.owner=e,e.entities.set(this.uuid,this)}update(e){var i;return(i=this.owner)!=null&&i.tryInsertEntity(this)||(this.leaveNode(),e.tryInsertEntity(this)),this.owner}}var ex=Object.defineProperty,tx=Object.getOwnPropertyDescriptor,ha=(t,e,i,r)=>{for(var s=r>1?void 0:r?tx(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&ex(e,i,s),s};class ts extends Zt{constructor(){super(...arguments),n(this,"instanceCount",0),n(this,"lodLevel",0),n(this,"alwaysRender",!1),n(this,"instanceID"),n(this,"drawType",0),n(this,"_geometry"),n(this,"_materials",[]),n(this,"_castShadow",!0),n(this,"_castReflection",!1),n(this,"_castGI",!1),n(this,"_rendererMask",vt.Default),n(this,"_inRenderer",!1),n(this,"_readyPipeline",!1),n(this,"_combineShaderRefection"),n(this,"_ignoreEnvMap"),n(this,"_ignorePrefilterMap"),n(this,"__renderOrder",0),n(this,"_renderOrder",0),n(this,"isRenderOrderChange"),n(this,"needSortOnCameraZ"),n(this,"_octreeBinder"),n(this,"preInit",!1),n(this,"_renderLayer",to.None),n(this,"_computes")}init(){this.renderOrder=0,this.rendererMask=vt.Default,this.instanceID=If().toString(),this._computes=[]}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new $v(this)},this.transform.eventDispatcher.addEventListener(pt.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(pt.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var i,r;(r=(i=this._octreeBinder)==null?void 0:i.entity)==null||r.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._geometry&&Me.getInstance().detached(this._geometry,this),Me.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=Zi.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=Zi.removeMask(this.rendererMask,e)}hasMask(e){return Zi.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let r=0;r<this._materials.length;r++){let s=this._materials[r];Me.getInstance().detached(s,this),s.shader&&s.shader.computes&&this.removeComputes(s.shader.computes)}for(let r=0;r<e.length;r++){let s=e[r];Me.getInstance().attached(s,this),s.shader&&s.shader.computes&&this.addComputes(s.shader.computes)}this._materials=e;let i=0;for(let r=0;r<e.length;r++){const s=e[r].getPass(xe.COLOR)[0];s.shaderState.transparent&&(i=i>s.renderOrder?i:s.renderOrder)}this.renderOrder=i,this._readyPipeline||this.initPipeline()}addComputes(e){this._computes.push(...e)}removeComputes(e){for(const i of e){let r=this._computes.indexOf(i);r!=-1&&this._computes.splice(r,1)}}addRendererMask(e){this._rendererMask=Zi.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=Zi.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),ie.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){ie.instance.removeRenderNode(this.transform.scene3D,this)}selfCloneMaterials(e){let i=[];for(let r=0,s=this.materials.length;r<s;r++){const a=this.materials[r].clone();i.push(a)}return this.materials=i,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let i=0;i<this._materials.length;i++){let r=this._materials[i].getPass(xe.COLOR);for(let s=0;s<r.length;s++){const a=r[s];a.shaderReflection||a.preCompile(this._geometry),this._geometry.generate(a.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let i=0;i<this.materials.length;i++){const r=this.materials[i].getPass(xe.COLOR)[0];r.renderOrder>=3e3?e=e>r.renderOrder?e:r.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&ie.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let e=0;e<this.materials.length;e++){const i=this.materials[e];An.createGIPass(this,i.shader)}for(let e=0;e<this.materials.length;e++){const i=this.materials[e];i.castShadow&&An.createShadowPass(this,i.shader)}if(this.castReflection)for(let e=0;e<this.materials.length;e++){const i=this.materials[e];i.castShadow&&An.createShadowPass(this,i.shader)}if(!Zi.hasMask(this.rendererMask,vt.IgnoreDepthPass)&&I.setting.render.zPrePass)for(let e=0;e<this.materials.length;e++){const i=this.materials[e];An.createDepthPass(this,i.shader)}else for(let e=0;e<this.materials.length;e++)this.materials[e].shader.removeShaderByIndex(xe.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,i,r){let s=this,a=s.transform._worldMatrix;for(let o=0;o<s.materials.length;o++){const l=s.materials[o];if(!l||!l.enable)continue;let h=l.getPass(i);if(!(!h||h.length==0)){T.bindGeometryBuffer(r.encoder,s._geometry);for(let u=0;u<h.length;u++){if(!h||h.length==0)continue;const c=h[u];if(c.pipeline){c.shaderState.splitTexture&&(r.endRenderPass(),Ut.WriteSplitColorTexture(s.instanceID),r.beginOpaqueRenderPass(),T.bindCamera(r.encoder,e.camera),T.bindGeometryBuffer(r.encoder,s._geometry)),T.bindPipeline(r.encoder,c);let d=s._geometry.subGeometries[o].lodLevels[s.lodLevel];s.instanceCount>0?T.drawIndexed(r.encoder,d.indexCount,s.instanceCount,d.indexStart,0,0):T.drawIndexed(r.encoder,d.indexCount,1,d.indexStart,0,a.index)}}}}}renderPass2(e,i,r,s,a,o=!1){if(!this.enable)return;let l=this,h=l.object3D.transform._worldMatrix;for(let u=0;u<this.materials.length;u++){let c=this.materials[u].getPass(i);if(!c||c.length==0)return;if(this.drawType==2)for(let d of c)d.pipeline&&(T.bindPipeline(a,d),T.draw(a,6,1,0,h.index));else{T.bindGeometryBuffer(a,l._geometry);for(let d of c)if(d.pipeline){T.bindPipeline(a,d);let f=l._geometry.subGeometries[u].lodLevels[l.lodLevel];T.drawIndexed(a,f.indexCount,1,f.indexStart,0,h.index)}}}}recordRenderPass2(e,i,r,s,a,o=!1){if(!this.enable)return;let l=this;for(let h=0;h<this.materials.length;h++){let u=this.materials[h].getPass(i);if(!u||u.length==0)return;let c=l.object3D.transform._worldMatrix;for(let d=0;d<u.length;d++){const f=u[d];T.bindPipeline(a,f);let g=l._geometry.subGeometries[h].lodLevels[l.lodLevel];T.drawIndexed(a,g.indexCount,1,g.indexStart,0,c.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this.preInit=!1)}nodeUpdate(e,i,r,s){this.preInit=!0;let a=this,o=e.scene.envMap;for(let l=0;l<a.materials.length;l++){let h=a.materials[l].getPass(i);if(h)for(let u=0;u<h.length;u++){const c=h[u];if(c.shaderState.splitTexture){let _=Ut.CreateSplitTexture(a.instanceID);c.setTexture("splitTexture_Map",_)}if(!a._ignoreEnvMap&&c.envMap!=o&&c.setTexture("envMap",o),c.setTexture("prefilterMap",o),c.pipeline){c.apply(a._geometry,r,()=>a.noticeShaderChange());continue}let d=I.res.getTexture("BRDFLUT");c.setTexture("brdflutMap",d);let f=I.getRenderJob(e).shadowMapPassRenderer;f&&f.depth2DArrayTexture&&c.setTexture("shadowMap",I.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture);let g=I.getRenderJob(e).pointLightShadowRenderer;g&&g.cubeArrayTexture&&c.setTexture("pointShadowMap",g.cubeArrayTexture);let m=Fs.iesTexture;m&&c.setTexture("iesTextureArrayMap",m),r.irradianceBuffer&&r.irradianceBuffer.length>0&&(c.setTexture("irradianceMap",r.irradianceBuffer[0]),c.setTexture("irradianceDepthMap",r.irradianceBuffer[1]));let A=Ze.getLightEntries(e.scene);A&&(c.setStorageBuffer("lightBuffer",A.storageGPUBuffer),A.irradianceVolume&&c.setUniformBuffer("irradianceData",A.irradianceVolume.irradianceVolumeBuffer)),s&&(c.setStorageBuffer("clustersUniform",s.clustersUniformBuffer),c.setStorageBuffer("lightAssignBuffer",s.lightAssignBuffer),c.setStorageBuffer("assignTable",s.assignTableBuffer),c.setStorageBuffer("clusterBuffer",s.clusterBuffer)),c.apply(a._geometry,r)}}}beforeDestroy(e){Me.getInstance().detached(this._geometry,this),Me.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let i=0;i<this._materials.length;i++){const r=this._materials[i];Me.getInstance().detached(r,this),Me.getInstance().hasReference(r)||r.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=null,this._materials=null,this._combineShaderRefection=null}}ha([er],ts.prototype,"materials",1),ha([er],ts.prototype,"castShadow",1),ha([er],ts.prototype,"castShadow",1),ha([er],ts.prototype,"castGI",1),ha([er],ts.prototype,"castGI",1);let ix=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(0) position: vec4<f32>,
        @location(1) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(0) varying_WPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }
`,rx=`
    struct FragmentOutput {
        @location(0) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(1) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(2) worldNormal: vec4<f32>,
            @location(3) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn main(  
        @location(0) vWorldPos: vec4<f32>,
        @location(1) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`;class sx{constructor(e,i){n(this,"mCount"),n(this,"mBatchSize"),n(this,"mBatchCount"),n(this,"mMinIndexCount"),n(this,"mOffset"),n(this,"mIndexBuffer"),n(this,"mDataBuffer"),n(this,"mBatchBuffers"),n(this,"mVertexShader"),n(this,"mFragmentShader"),n(this,"mRenderPipeline"),n(this,"mRenderPipelineLayout"),n(this,"mVertexBufferLayout"),n(this,"mGPUPrimitiveTopology"),this.mMinIndexCount=e,this.mGPUPrimitiveTopology=i,this.mBatchSize=Math.trunc(65536/this.mMinIndexCount),this.init()}reset(){this.mCount=0,this.mOffset=0,this.mBatchCount=0}addShapeData(e){let i=e.shapeData;for(;i.length>0;){if(this.mOffset>=this.mDataBuffer.length&&this.flush(),this.mOffset+i.length<=this.mDataBuffer.length){this.mDataBuffer.set(i,this.mOffset),this.mOffset+=i.length;break}let r=this.mDataBuffer.length-this.mOffset;this.mDataBuffer.set(i,this.mOffset),this.mOffset+=r,i=i.slice(r)}}flush(){if(this.mOffset>0){let e;this.mBatchCount<this.mBatchBuffers.length?e=this.mBatchBuffers[this.mBatchCount]:(e=D.device.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.mBatchBuffers.push(e)),D.device.queue.writeBuffer(e,0,this.mDataBuffer,0,this.mOffset),this.mCount+=this.mOffset/8,this.mBatchCount++,this.mOffset=0}}render(e,i){const r=D.device;if(!this.mRenderPipeline){let s=e.renderTargetTextures;if(e.outColor!=-1){let o=s[e.outColor];o.blend=Mf.getBlend(Te.ALPHA)}this.mRenderPipelineLayout=r.createPipelineLayout({bindGroupLayouts:[Bo.getGlobalDataBindGroupLayout()]});let a={label:"Graphic3DFixedRenderPipeline",layout:this.mRenderPipelineLayout,vertex:{module:this.mVertexShader,entryPoint:"main",buffers:[this.mVertexBufferLayout]},fragment:{module:this.mFragmentShader,entryPoint:"main",targets:s},primitive:{topology:this.mGPUPrimitiveTopology,cullMode:zt.none,frontFace:"ccw"}};e.depthTexture&&(a.depthStencil={depthWriteEnabled:!0,depthCompare:zi.less_equal,format:e.depthTexture.format}),this.mRenderPipeline=T.createPipeline(a)}if(this.flush(),this.mBatchCount>0){i.setPipeline(this.mRenderPipeline),i.setIndexBuffer(this.mIndexBuffer,"uint16");let s=this.mCount/this.mMinIndexCount;for(let a=Math.trunc(s/this.mBatchSize)-1;a>=0;a--)i.setVertexBuffer(0,this.mBatchBuffers[a]),i.drawIndexed(this.mMinIndexCount*this.mBatchSize,1,0,0,0);s=s%this.mBatchSize,s!=0&&(i.setVertexBuffer(0,this.mBatchBuffers[this.mBatchCount-1]),i.drawIndexed(this.mMinIndexCount*s,1,0,0,0))}}init(){const e=D.device;let i=new Uint16Array((Math.trunc(this.mMinIndexCount*this.mBatchSize/4)+1)*4);for(let r=0;r<i.length;r++)i[r]=r;this.mIndexBuffer=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.mIndexBuffer,0,i),this.mVertexBufferLayout={arrayStride:(4+4)*4,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]},this.mBatchBuffers=[],this.mDataBuffer=new Float32Array((4+4)*i.length),this.mBatchBuffers.push(e.createBuffer({size:this.mDataBuffer.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})),this.mVertexShader=this.createShaderModule("Graphic3DFixedRenderPipeline.vs",li.parse(ix,{})),this.mFragmentShader=this.createShaderModule("Graphic3DFixedRenderPipeline.fs",li.parse(rx,{})),this.reset()}createShaderModule(e,i){let r=D.device.createShaderModule({label:e,code:i});return r.getCompilationInfo().then(s=>{s.messages.length>0&&(console.log(i),console.log(s))}),r}}class Er{}n(Er,"ShapeVertexSize",8);class vc{constructor(e){n(this,"uuid"),n(this,"type"),n(this,"color"),n(this,"count",0),n(this,"shapeData"),n(this,"dirtyData",!1),n(this,"memoryDataIndex",-1),n(this,"transformIndex"),this.transformIndex=e}buildAxis(e=new p(0,0,0),i=10){this.buildLines([e,new p(e.x+i,e.y,e.z)],Y.hexRGBColor(Y.RED)),this.buildLines([e,new p(e.x,e.y+i,e.z)],Y.hexRGBColor(Y.GREEN)),this.buildLines([e,new p(e.x,e.y,e.z+i)],Y.hexRGBColor(Y.BLUE))}buildLines(e,i=Y.COLOR_WHITE){if(!(e.length<2)){if(e.length==2){this.fillShapeData(e,i);return}var r=new Array(e.length+e.length-2);for(let s=1,a=0;s<e.length;++s)r[a++]=e[s-1],r[a++]=e[s];this.fillShapeData(r,i)}}buildArcLine(e,i,r,s,a=16,o=p.Y_AXIS,l=Y.COLOR_WHITE){const h=(s-r)*We;r*=We;var u=[];for(let g=0;g<=a;++g){g>1&&u.push(u[u.length-1]);var c=h*(g/a)+r,d=i*Math.cos(c),f=i*Math.sin(c);switch(o){case p.X_AXIS:u.push(e.add(new p(0,d,f)));break;case p.Y_AXIS:u.push(e.add(new p(d,0,f)));break;case p.Z_AXIS:u.push(e.add(new p(d,f,0)));break;default:u.push(e.add(new p(d,f,0)));break}}this.fillShapeData(u,l)}buildCircle(e,i,r=32,s=p.Y_AXIS,a=Y.COLOR_WHITE){var o=[];for(let c=0;c<=r;++c){var l=2*Math.PI*c/r,h=i*Math.cos(l),u=i*Math.sin(l);switch(s){case p.X_AXIS:o.push(e.add(new p(0,h,u)));break;case p.Y_AXIS:o.push(e.add(new p(h,0,u)));break;case p.Z_AXIS:o.push(e.add(new p(h,u,0)));break;default:o.push(e.add(new p(h,u,0)));break}c>0&&o.push(o[o.length-1])}o.push(o[0]),this.fillShapeData(o,a)}fillShapeData(e,i,r=!1){if(!this.shapeData)this.shapeData=new Float32Array(Er.ShapeVertexSize*e.length);else if(this.count+Er.ShapeVertexSize*e.length>=this.shapeData.length){let s=new Float32Array(this.shapeData.length+Er.ShapeVertexSize*e.length);s.set(this.shapeData),this.shapeData=s}if(r||this.dirtyData==!1){const s=this.shapeData;for(let a=0;a<e.length;++a){const o=e[a];if(s[this.count++]=o.x,s[this.count++]=o.y,s[this.count++]=o.z,s[this.count++]=this.transformIndex,i instanceof Y)s[this.count++]=i.r,s[this.count++]=i.g,s[this.count++]=i.b,s[this.count++]=i.a;else{const l=i[a];s[this.count++]=l.r,s[this.count++]=l.g,s[this.count++]=l.b,s[this.count++]=l.a}}}this.dirtyData=!0}reset(){this.count=0}}class Qh extends ts{constructor(e,i){super(),n(this,"shapes"),n(this,"mDirtyData",!1),n(this,"mMinIndexCount"),n(this,"mGPUPrimitiveTopology"),n(this,"mRenderPipeline"),this.alwaysRender=!0,this.mMinIndexCount=e,this.mGPUPrimitiveTopology=i,this.shapes=new Map,this.addRendererMask(vt.Particle)}fillShapeData(e,i,r,s){this.mDirtyData=!0;var a;this.shapes.has(e)?(a=this.shapes.get(e),a.shapeData.length<Er.ShapeVertexSize*s.length&&(a.shapeData=new Float32Array(Er.ShapeVertexSize*s.length))):(a=new vc(this.transform._worldMatrix.index),a.type=i,a.color=r,a.shapeData=new Float32Array(Er.ShapeVertexSize*s.length));const o=a.shapeData,l=this.transform._worldMatrix.index;for(let h=0,u=0;h<s.length;++h){const c=s[h];o[u++]=c.x,o[u++]=c.y,o[u++]=c.z,o[u++]=l,o[u++]=r.r,o[u++]=r.g,o[u++]=r.b,o[u++]=r.a}this.shapes.set(e,a)}init(){super.init(),this.castGI=!1,this.castShadow=!1,this.mRenderPipeline=new sx(this.mMinIndexCount,this.mGPUPrimitiveTopology)}removeShape(e){this.shapes.has(e)&&(this.mDirtyData=!0,this.shapes.delete(e))}initPipeline(){this.object3D.bound=new _t(p.ZERO,p.MAX),this._readyPipeline=!0}nodeUpdate(e,i,r,s){this.mDirtyData&&(this.mRenderPipeline.reset(),this.shapes.forEach((a,o)=>{this.mRenderPipeline.addShapeData(a)}),this.mDirtyData=!1)}renderPass2(e,i,r,s,a,o=!1){this.mRenderPipeline.render(r,a)}allocGraphics3DShape(e,i){let r;return this.shapes.has(e)?(r=this.shapes.get(e),r.reset()):(r=new vc(i),r.uuid=e,r.type="line",r.color=Y.COLOR_WHITE,this.shapes.set(r.uuid,r)),this.mDirtyData=!0,r}}class ax{constructor(){n(this,"opaqueList",[]),n(this,"transparentList",[]),n(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class nx{constructor(){n(this,"renderGroup"),this.renderGroup=new Map}collect_add(e){let i="",r="";i+=e.geometry.instanceID;for(let a=0;a<e.materials.length;a++){const o=e.materials[a];r+=o.shader.getDefaultColorShader().shaderVariant}let s=i+r;this.renderGroup.has(s)||this.renderGroup.set(s,{bundleMap:new Map,key:s,renderNodes:[]}),this.renderGroup.get(s).renderNodes.indexOf(e)==-1&&this.renderGroup.get(s).renderNodes.push(e)}}class ox{constructor(){n(this,"renderShaderUpdateList",new Map),n(this,"renderNodeList",new Map)}collect_add(e){let i=e.transform.view3D;i&&e.materials&&e.materials.forEach(r=>{let s=this.renderShaderUpdateList.get(i);s||(s=new Map,this.renderShaderUpdateList.set(i,s));let a=this.renderNodeList.get(i);a||(a=new Map,this.renderNodeList.set(i,a)),a.set(e.instanceID,e);let o=r.getAllPass();for(let l=0;l<o.length;l++){const h=o[l];let u=`${e.geometry.instanceID+h.instanceID}`,c=s.get(u);c||(c=new Map,s.set(u,c)),c.set(e.instanceID,e)}})}collect_remove(e){let i=e.transform.view3D;if(i&&e.materials){let r=this.renderShaderUpdateList.get(i);r&&e.materials.forEach(s=>{let a=s.getAllPass();for(let o=0;o<a.length;o++){const l=a[o];let h=`${e.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const Lf=class{constructor(){n(this,"_sceneLights"),n(this,"_sceneGIProbes"),n(this,"_op_RenderNodes"),n(this,"_tr_RenderNodes"),n(this,"_octreeRenderNodes"),n(this,"_graphics"),n(this,"_op_renderGroup"),n(this,"_tr_renderGroup"),n(this,"_renderShaderCollect"),n(this,"state",{giLightingChange:!0}),n(this,"sky"),n(this,"_collectInfo"),n(this,"rendererOctree"),this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new ax,this._renderShaderCollect=new ox,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new Lf),this._instance}getPashList(t,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(t);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(t)}sortRenderNode(t,e){for(let i=t.length-1;i>0;i--)if(t[i].renderOrder<e.renderOrder){t.push(e);return}t.push(e)}addRenderNode(t,e){if(!t)return;let i=e.renderOrder>=3e3;if(e.hasMask(vt.Sky))this.sky=e;else if(e instanceof Qh)this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(mc.hasMask(e.renderLayer,to.None)){this.removeRenderNode(t,e);let r=i?this._tr_RenderNodes:this._op_RenderNodes;r.has(t)||r.set(t,[]),r.get(t).push(e),I.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(t));let s=this.getPashList(t,e);s.indexOf(e)==-1&&this.sortRenderNode(s,e)}else{this.removeRenderNode(t,e);let r=i?this._tr_renderGroup:this._op_renderGroup;r.has(t)||r.set(t,new nx),r.get(t).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(t){let e,i=I.setting.occlusionQuery.octree;if(i&&(e=this._octreeRenderNodes.get(t),!e)){let r=new p(i.x,i.y,i.z),s=new p(i.width,i.height,i.depth),a=new _t(r,s);e=new xa(a),this._octreeRenderNodes.set(t,e)}return e}removeRenderNode(t,e){if(e.detachSceneOctree(),e.hasMask(vt.Sky))this.sky=null;else if(mc.hasMask(e.renderLayer,to.None)){let i=this.getPashList(t,e);if(i){let r=i.indexOf(e);r!=-1&&i.splice(r,1)}}this._renderShaderCollect.collect_remove(e)}addLight(t,e){if(!this._sceneLights.has(t))this._sceneLights.set(t,[e]);else{let i=this._sceneLights.get(t);if(i.length>=I.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",I.setting.light.maxLight);return}i.indexOf(e)!=-1||i.push(e)}}removeLight(t,e){if(this._sceneLights.has(t)){let i=this._sceneLights.get(t),r=i.indexOf(e);r!=-1&&i.splice(r,1)}}getLights(t){return this._sceneLights.get(t)||[]}addGIProbe(t,e){this._sceneGIProbes.has(t)?this._sceneGIProbes.get(t).push(e):this._sceneGIProbes.set(t,[e])}removeGIProbe(t,e){if(this._sceneGIProbes.has(t)){let i=this._sceneGIProbes.get(t),r=i.indexOf(e);r!=-1&&i.splice(r,1)}}getProbes(t){return this._sceneGIProbes.get(t)||[]}autoSortRenderNodes(t){let e=this._tr_RenderNodes.get(t);if(!e)return;let i=!1;for(const r of e)if(r.isRenderOrderChange||r.needSortOnCameraZ){i=!0;break}if(i){for(const r of e){let s=r.renderOrder;if(r.needSortOnCameraZ){let a=Lv.worldToCameraDepth(r.object3D);a=1-Math.max(0,Math.min(1,a)),s+=a}r.__renderOrder=s,r.isRenderOrderChange=!1}e.sort((r,s)=>r.__renderOrder>s.__renderOrder?1:-1)}return this}getRenderNodes(t,e){if(this.autoSortRenderNodes(t),this._collectInfo.clean(),this._collectInfo.sky=this.sky,I.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(t),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let i=this._op_RenderNodes.get(t);i&&(this._collectInfo.opaqueList=i.concat());let r=this._tr_RenderNodes.get(t);r&&(this._collectInfo.transparentList=r.concat())}return this._collectInfo}getOpRenderGroup(t){return this._op_renderGroup.get(t)}getTrRenderGroup(t){return this._tr_renderGroup.get(t)}getGraphicList(){return this._graphics}getRenderShaderCollect(t){return this._renderShaderCollect.renderShaderUpdateList.get(t)}};let ie=Lf;n(ie,"_instance");class lx{constructor(){n(this,"setting"),n(this,"probesBufferData"),n(this,"probesBuffer"),n(this,"isVolumeFrameChange",!0),n(this,"randomOrientation"),n(this,"startPosition",new p),n(this,"isVolumeChange",!0),n(this,"irradianceVolumeBuffer"),n(this,"directionDistance",20),n(this,"randomSeedCount",3),n(this,"useRandomIndex",0),n(this,"centerDirection",new p(0,0,this.directionDistance).normalize(1)),n(this,"arroundPositions",[]),n(this,"debugX",0),n(this,"debugY",0),n(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),te.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(e){this.setting=e,this.randomOrientation=new te(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new an(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let i=0;i<this.randomSeedCount;i++){let r=Math.PI*2*i/this.randomSeedCount,s=new p(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(s)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(e){let i=this.probesBufferData;for(let r of e){let s=r.index*4;i[s+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let e=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(e*4),this.probesBufferData.fill(-1),this.probesBuffer=new At(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(e,i,r,s){let a=this.setting,o=this.setting.probeSpace;return s=s||new p,s.x=e*o-o*(a.probeXCount-1)*.5+a.offsetX,s.y=i*o-o*(a.probeYCount-1)*.5+a.offsetY,s.z=r*o-o*(a.probeZCount-1)*.5+a.offsetZ,s}fillIrradianceData(){let e=this.setting,i=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",e.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",e.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",e.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",i.x),this.irradianceVolumeBuffer.setFloat("startY",i.y),this.irradianceVolumeBuffer.setFloat("startZ",i.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",e.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",e.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",e.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",e.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",e.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",e.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",e.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",e.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",e.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",e.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",e.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",e.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",e.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",e.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",e.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",e.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",e.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class hx{constructor(){n(this,"storageGPUBuffer"),n(this,"irradianceVolume"),n(this,"_lightList",[]),this.storageGPUBuffer=new At($n.lightSize*I.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new lx,this.irradianceVolume.init(I.setting.gi);for(let e=0;e<I.setting.light.maxLight;e++){let i=this.storageGPUBuffer.memory.allocation_node($n.lightSize*4);this._lightList.push(i)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e){this.storageGPUBuffer.clean();let i=ie.instance.getLights(e.scene);for(let r=0;r<i.length;r++){const s=i[r].lightData;s.index=r,this.writeLightBytes(s,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(e,i){i.offset=0,i.writeFloat(e.index),i.writeInt32(e.lightType),i.writeFloat(e.radius),i.writeFloat(e.linear),i.writeVector3(e.lightPosition),i.writeFloat(e.lightMatrixIndex),i.writeVector3(e.direction),i.writeFloat(e.quadratic),i.writeRGBColor(e.lightColor),i.writeFloat(e.intensity),i.writeFloat(e.innerAngle),i.writeFloat(e.outerAngle),i.writeFloat(e.range),i.writeInt32(e.castShadowIndex),i.writeVector3(e.lightTangent),i.writeFloat(e.iesIndex)}}class ux{constructor(){n(this,"gpuBuffer"),n(this,"probes"),n(this,"memoryDo"),n(this,"_probeInfoList")}initDataUniform(e){this.memoryDo=new tn,this.probes=e,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(e.length*17*4);for(let r=0;r<e.length;r++){var i=17;let s=this.memoryDo.allocation_node(i*4);this._probeInfoList.push(s);let a=e[r].transform.worldPosition;s.setArray(0,[a.x,a.y,a.z])}this.gpuBuffer=D.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const e=this.memoryDo.shareDataBuffer;let i=this.memoryDo.shareDataBuffer.byteLength,r=0;const s=5e3*64;for(;r<i;)D.device.queue.writeBuffer(this.gpuBuffer,r,e,r,Math.floor(Math.min(s,i-r))),r+=s}}class cx extends Or{constructor(e,i=0,r){super(),n(this,"size"),this.bufferType=Hi.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|i,e,r,"MatrixGPUBuffer")}writeBufferByHeap(e,i){let r=D.device;if(e.length>0){let s=null;for(;this.mapAsyncReady.length&&(s=this.mapAsyncReady.shift(),s.usedSize!=e.byteLength);)s.destroy(),this.mapAsyncBuffersOutstanding--,s=null;s||(s=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),s.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,i);new Float32Array(s.getMappedRange(0,i*4)).set(a),s.unmap();const o=r.createCommandEncoder();o.copyBufferToBuffer(s,0,this.buffer,0,i*4),r.queue.submit([o.finish()]),s.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(s))}}}class dx{constructor(){n(this,"uuid"),n(this,"index"),n(this,"usage"),n(this,"groupBufferSize"),n(this,"matrixBufferDst"),this.uuid=bi(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=te.maxCount*te.blockBytes,this.matrixBufferDst=new cx(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(e){const i=te.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(i,e)}}class Ze{static init(){this.modelMatrixBindGroup=new dx,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map}static getCameraGroup(e){let i=this._cameraBindGroups.get(e);return i||(i=new Pv(this.modelMatrixBindGroup),this._cameraBindGroups.set(e,i)),e.isShadowCamera?i.setShadowCamera(e):i.setCamera(e),i}static getLightEntries(e){e||console.log("getLightEntries scene is null");let i=this._lightEntriesMap.get(e);return i||(i=new hx,this._lightEntriesMap.set(e,i)),this._lightEntriesMap.get(e)}static updateProbes(e){this._probeEntries||(this._probeEntries=new ux,this._probeEntries.initDataUniform(e))}}n(Ze,"_cameraBindGroups"),n(Ze,"_lightEntriesMap"),n(Ze,"_probeEntries"),n(Ze,"modelMatrixBindGroup");const Ca=class{static bindPipeline(t,e){if(Ca.lastShader!=e)Ca.lastShader=e;else return;Ca.lastPipeline!=e.pipeline&&(Ca.lastPipeline=e.pipeline,t.setPipeline(e.pipeline));for(let i=1;i<e.bindGroups.length;i++){const r=e.bindGroups[i];r&&t.setBindGroup(i,r)}}static bindCamera(t,e){let i=Ze.getCameraGroup(e);t.setBindGroup(0,i.globalBindGroup)}static bindGeometryBuffer(t,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&t.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let i=e.vertexBuffer.vertexGPUBuffer,r=e.vertexBuffer.vertexBufferLayouts;for(let s=0;s<r.length;s++){const a=r[s];t.setVertexBuffer(s,i.buffer,a.offset,a.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(t){return ai.countStart("GPUContext","pipeline"),D.device.createRenderPipeline(t)}static beginCommandEncoder(){return ai.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&D.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=D.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(t){this.LastCommand==t&&(D.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,ai.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(t){return D.device.createRenderBundleEncoder(t)}static beginRenderPass(t,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.renderTargets&&e.renderTargets.length>0){for(let i=0;i<e.renderTargets.length;++i){const r=e.renderTargets[i];let s=e.renderPassDescriptor.colorAttachments[i];e.multisample>0&&e.renderTargets.length==1?(s.view=e.multiTexture.createView(),s.resolveTarget=r.getGPUView()):s.view=r.getGPUTexture().createView()}return t.beginRenderPass(e.renderPassDescriptor)}else{let i=e.renderPassDescriptor.colorAttachments[0];return i&&(e.multisample>0?(i.view=e.multiTexture.createView(),i.resolveTarget=D.context.getCurrentTexture().createView()):i.view=D.context.getCurrentTexture().createView()),t.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(t,e,i,r,s,a){t.drawIndexed(e,i,r,s,a),this.drawCount++}static draw(t,e,i,r,s){t.draw(e,i,r,s),this.drawCount++}static endPass(t){t.insertDebugMarker("end"),t.end()}static computeCommand(t,e){let i=t.beginComputePass();for(let r=0;r<e.length;r++)e[r].compute(i);i.end()}};let T=Ca;n(T,"lastGeometry"),n(T,"lastPipeline"),n(T,"lastShader"),n(T,"drawCount",0),n(T,"renderPassCount",0),n(T,"geometryCount",0),n(T,"pipelineCount",0),n(T,"matrixCount",0),n(T,"lastRenderPassState"),n(T,"LastCommand");class xc{constructor(){n(this,"source"),n(this,"input"),n(this,"output")}reset(e){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=e}apply(e){if(this.source){if(!this.input){let i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new At(this.source.length,i,this.source),this.input.apply()}if(!this.output){let i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new At(e*3,i),this.output.apply()}}}}class fx{constructor(){n(this,"enable"),n(this,"morphTargetsRelative"),n(this,"MaxMorphTargetCount",64),n(this,"_computeConfigArray"),n(this,"_computeConfigBuffer"),n(this,"_morphInfluenceArray"),n(this,"_morphInfluenceBuffer"),n(this,"_positionAttrDataGroup"),n(this,"_normalAttrDataGroup"),n(this,"_isInfluenceDirty"),n(this,"_morphTargetCount"),n(this,"_totalVertexCount"),n(this,"_computeShader"),n(this,"_computeShaders"),n(this,"_computeWorkGroupXY",1),n(this,"_collectMorphTargetData"),n(this,"_blendTarget"),this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new xc,this._normalAttrDataGroup=new xc}initMorphTarget(e){this._collectMorphTargetData=this.collectMorphTargetList(e),this._computeShader&&this._computeShader.destroy();let i=Ue.CsMain;this._computeShader=new di(i),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(e){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),e.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),e.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&e.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(e){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,T.computeCommand(e,this._computeShaders)}updateInfluence(e,i){this._isInfluenceDirty=!0,this._morphInfluenceArray[e]=i}get blendShape(){return this._blendTarget}collectMorphTargetList(e){let i=this.collectAttribute("a_morphPositions_",e),r=i.length,s=i[0].data.length/3;if(this._blendTarget={},e.blendShapeData)for(let h=0;h<e.blendShapeData.shapeIndexs.length;h++){let u=e.blendShapeData.shapeIndexs[h],c=e.blendShapeData.shapeNames[h].split("."),d=c[c.length-1];this._blendTarget[d]=f=>this.updateInfluence(u,f)}let a=new Float32Array(s*r*3);{let h=0;for(let u=0;u<r;u++){let c=i[u];a.set(c.data,h),h+=c.data.length}}let o=this.collectAttribute("a_morphNormals_",e),l;if(o&&o.length>0){let h=0;l=new Float32Array(s*r*3);for(let u=0;u<r;u++){let c=o[u];l.set(c.data,h),h+=c.data.length}}return{mtCount:r,vCount:s,mergedPos:a,mergedNormal:l}}collectAttribute(e,i){let r=[];for(let s=0;s<this.MaxMorphTargetCount;s++){let a=e+s,o=i.getAttribute(a);if(o)r[s]=o;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let e=0;for(let i=0;i<this._morphTargetCount;i++)e+=this._morphInfluenceArray[i];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-e,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(e){let i=Math.ceil(Math.sqrt(e)),r=Math.ceil(Math.log2(i));return i=Math.pow(2,r),i}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new an(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new At(this.MaxMorphTargetCount,e)}}var gx=Object.defineProperty,px=Object.getOwnPropertyDescriptor,ua=(t,e,i,r)=>{for(var s=r>1?void 0:r?px(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&gx(e,i,s),s};let Pe=class extends ts{constructor(){super(),n(this,"receiveShadow"),n(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(t){t.addComponent(Pe).copyComponent(this)}copyComponent(t){return super.copyComponent(t),this.receiveShadow=t.receiveShadow,this}get geometry(){return this._geometry}set geometry(t){super.geometry=t;let e=t.morphTargetDictionary!=null;e&&(this.morphData||(this.morphData=new fx),this.morphData.morphTargetsRelative=t.morphTargetsRelative,this.morphData.initMorphTarget(t)),this.morphData&&(this.morphData.enable=e),this.morphData&&this.morphData.enable?this.addRendererMask(vt.MorphTarget):this.removeRendererMask(vt.MorphTarget),this.object3D.bound=this._geometry.bounds.clone(),this._readyPipeline||(this.initPipeline(),this._computes&&this._computes&&(this.onCompute=b0(this.onCompute,()=>{for(let i=0;i<this._computes.length;i++)this._computes[i].onUpdate()})))}get material(){return this._materials[0]}set material(t){this.materials=[t]}setMorphInfluence(t,e){if(this.morphData&&this.morphData.enable){let i=this._geometry.morphTargetDictionary[t];i>=0&&this.morphData.updateInfluence(i,e)}}setMorphInfluenceIndex(t,e){this.morphData&&this.morphData.enable&&t>=0&&this.morphData.updateInfluence(t,e)}onCompute(t,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(t,e,i,r){if(this.morphData&&this.morphData.enable)for(let s=0;s<this.materials.length;s++){let a=this.materials[s].getPass(e);if(a)for(let o=0;o<a.length;o++)this.morphData.applyRenderShader(a[o])}super.nodeUpdate(t,e,i,r)}destroy(t){super.destroy(t)}};ua([er],Pe.prototype,"geometry",1),ua([er],Pe.prototype,"geometry",1),ua([er],Pe.prototype,"material",1),ua([er],Pe.prototype,"material",1),Pe=ua([Ci(Pe,"MeshRenderer")],Pe);class mx{constructor(){n(this,"label",""),n(this,"customSize",!1),n(this,"zPreTexture",null),n(this,"depthTexture",null),n(this,"renderTargetTextures"),n(this,"outColor",-1),n(this,"renderTargets"),n(this,"rtTextureDescriptors"),n(this,"irradianceBuffer"),n(this,"multisample",0),n(this,"multiTexture"),n(this,"depthViewIndex",0),n(this,"depthCleanValue",0),n(this,"isOutTarget",!0),n(this,"camera3D"),n(this,"rtFrame"),n(this,"renderPassDescriptor"),n(this,"renderBundleEncoderDescriptor"),n(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:I.res.redTexture}}const ba=class{static createRendererPassState(t,e=null){let i=new mx;if(i.label=t.label,i.customSize=t.customSize,i.rtFrame=t,i.zPreTexture=t.zPreTexture,i.depthTexture=t.depthTexture,i.depthViewIndex=t.depthViewIndex,i.isOutTarget=t.isOutTarget,i.depthCleanValue=t.depthCleanValue,i.depthLoadOp=t.depthLoadOp,t&&t.renderTargets.length>0){i.renderTargets=t.renderTargets,i.rtTextureDescriptors=t.rtDescriptors,i.renderPassDescriptor=ba.getRenderPassDescriptor(i),i.renderBundleEncoderDescriptor=ba.getRenderBundleDescriptor(i),i.renderTargetTextures=[];for(let r=0;r<t.renderTargets.length;r++){const s=t.renderTargets[r];i.renderTargetTextures[r]={format:s.format},s.name.indexOf(ht.colorBufferTex_NAME)!=-1&&(i.outColor=r)}}else i.renderPassDescriptor=ba.getRenderPassDescriptor(i,e),i.renderBundleEncoderDescriptor=ba.getRenderBundleDescriptor(i),i.renderTargetTextures=[{format:D.presentationFormat}],i.outColor=0;return i}static getRenderPassDescriptor(t,e=null){D.device,D.presentationSize;let i=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let s=0;s<t.renderTargets.length;s++){const a=t.renderTargets[s],o=t.rtTextureDescriptors[s];i.push({view:a.getGPUView(),resolveTarget:void 0,loadOp:o.loadOp,clearValue:o.clearValue,storeOp:o.storeOp})}}else if(!t.customSize){let s=D.canvasConfig&&D.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];t.isOutTarget==!0&&i.push({view:void 0,resolveTarget:void 0,loadOp:D.canvasConfig&&D.canvasConfig.alpha||e!=null?"load":"clear",clearValue:s,storeOp:"store"})}let r=null;return t.depthTexture||t.zPreTexture?(t.zPreTexture&&(t.depthTexture=t.zPreTexture),r={label:`${t.label} renderPassDescriptor zPreTexture${t.zPreTexture?"load":"clear"}`,colorAttachments:i,depthStencilAttachment:{view:t.depthTexture.getGPUView(),depthLoadOp:t.zPreTexture?"load":t.depthLoadOp,depthClearValue:t.zPreTexture?1:t.depthCleanValue,depthStoreOp:"store"}}):r={colorAttachments:i,label:"renderPassDescriptor not writeDepth"},this.renderPassDescriptorCount++,r}static getRenderBundleDescriptor(t){D.presentationSize;let e=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let r=0;r<t.renderTargets.length;r++){const s=t.renderTargets[r];e.push(s.format)}}let i=null;return t.depthTexture?i={colorFormats:e,depthStencilFormat:t.depthTexture.format}:i={colorFormats:e},this.renderPassDescriptorCount++,i}};let ui=ba;n(ui,"bindGroupDescriptorCount",0),n(ui,"bindTextureDescriptorCount",0),n(ui,"renderPassDescriptorCount",0),n(ui,"pipelineDescriptorCount",0);class qo extends Or{constructor(e){super(),n(this,"node"),this.bufferType=Hi.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,i){let r=D.device;this.byteSize=i*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({label:"VertexGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new tn,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var Rt=(t=>(t[t.split=0]="split",t[t.compose=1]="compose",t[t.compose_bin=2]="compose_bin",t))(Rt||{});class Ax{constructor(){n(this,"vertexCount",0),n(this,"vertexGPUBuffer"),n(this,"geometryType",Rt.compose),n(this,"_vertexBufferLayouts"),n(this,"_attributeSlotLayouts"),n(this,"_attributeLocation"),this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(e,i){switch(this.geometryType){case Rt.split:this.createSplitVertexBuffer(e,i);break;case Rt.compose:this.createComposeVertexBuffer(e,i);break;case Rt.compose_bin:this.createComposBinVertexBuffer(e,i);break}}createSplitVertexBuffer(e,i){let r=0;for(let s=0;s<i.attributes.length;s++){const a=i.attributes[s];if(a.name=="index")continue;this._attributeLocation[a.name]=a.location;let o={name:a.name,format:a.format,offset:0,shaderLocation:a.location,stride:os[a.format]};this._attributeSlotLayouts[a.location]=[o];let l=e.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l));let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[a.location]={name:a.name,arrayStride:a.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[a.location],offset:r*4,size:this.vertexCount*a.size*4},r+=this.vertexCount*a.size}this.vertexGPUBuffer=new qo(r)}createComposeVertexBuffer(e,i){this._attributeSlotLayouts[0]=[];let r=0;for(let s=0;s<i.attributes.length;s++){const a=i.attributes[s];if(a.name=="index"||a.type=="builtin")continue;this._attributeLocation[a.name]=a.location;let o={name:a.name,format:a.format,offset:r*4,shaderLocation:a.location,stride:os[a.format]};this._attributeSlotLayouts[0][a.location]=o;let l=e.get(a.name);if(l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,l)),l.data){let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h}r+=a.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new qo(this.vertexCount*r)}createComposBinVertexBuffer(e,i){this._attributeSlotLayouts[0]=[];let r=0;for(let a=0;a<i.attributes.length;a++){const o=i.attributes[a];if(o.name=="index"||o.type=="builtin")continue;this._attributeLocation[o.name]=o.location;let l={name:o.name,format:o.format,offset:r*4,shaderLocation:o.location,stride:os[o.format]};this._attributeSlotLayouts[0][o.location]=l;let h=e.get(o.name);if(h||(h={attribute:o.name,data:new Float32Array(o.size*this.vertexCount)},e.set(o.name,h)),h.data){let u=h.data.length/l.stride;this.vertexCount!=0&&this.vertexCount!=u&&console.error(" vertex count not match attribute count"),this.vertexCount=u}r+=o.size}let s=e.get(z.all).data.length/r;this.vertexCount=s,this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new qo(this.vertexCount*r)}upload(e,i){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case Rt.split:{let s=this._attributeLocation[e],a=this._vertexBufferLayouts[s];this.vertexGPUBuffer.node.setFloat32Array(a.offset/4,i.data)}break;case Rt.compose:for(let s=0;s<this.vertexCount;s++){const a=this._attributeSlotLayouts[0][this._attributeLocation[e]];for(let o=0;o<a.stride;o++){let l=i.data[s*a.stride+o],h=s*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+o;this.vertexGPUBuffer.node.setFloat(l,h)}}break;case Rt.compose_bin:this.vertexGPUBuffer.node.setFloat32Array(0,i.data);break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(e){switch(this.geometryType){case Rt.split:for(let i=0;i<this._vertexBufferLayouts.length;i++){const r=this._vertexBufferLayouts[i];let s=e.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,s.data)}break;case Rt.compose:for(let i=0;i<this.vertexCount;i++)this._attributeSlotLayouts.forEach(r=>{for(let s=0;s<r.length;s++){const a=r[s];let o=e.get(a.name);for(let l=0;l<a.stride;l++){let h=o.data[i*a.stride+l],u=i*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,u)}}});break;case Rt.compose_bin:{let i=e.get(z.all);this.vertexGPUBuffer.node.setFloat32Array(0,i.data)}break}this.vertexGPUBuffer.apply()}compute(){}destroy(e){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(e),this.vertexGPUBuffer=null}}class _x extends Or{constructor(e){super(),n(this,"indicesNode"),this.bufferType=Hi.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,i){let r=D.device;this.byteSize=i.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({label:"IndicesGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new tn,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),i&&(this.indicesNode=this.memory.allocation_node(i.length*4),this.indicesNode.setArrayBuffer(0,i),this.apply())}}class vx{constructor(){n(this,"uuid",""),n(this,"name"),n(this,"indicesGPUBuffer"),n(this,"indicesFormat","uint16"),n(this,"indicesCount",0)}createIndicesBuffer(e){e.data instanceof Uint16Array?this.indicesFormat="uint16":e.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=e.data.length,this.indicesGPUBuffer=new _x(e.data)}upload(e){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,e),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class xx{constructor(){n(this,"lodLevels")}}const Kr=class{constructor(){n(this,"instanceID"),n(this,"name"),n(this,"subGeometries",[]),n(this,"morphTargetsRelative"),n(this,"morphTargetDictionary"),n(this,"skinNames"),n(this,"bindPose"),n(this,"blendShapeData"),n(this,"vertexDim"),n(this,"_bounds"),n(this,"_attributeMap"),n(this,"_attributes"),n(this,"_indicesBuffer"),n(this,"_vertexBuffer"),n(this,"_onChange",!0),n(this,"_wireframeLines"),this.instanceID=bi(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new Ax}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(t){this._vertexBuffer.geometryType=t}get bounds(){if(!this._bounds){this._bounds=new _t(new p,new p(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let t=this.getAttribute(z.position);if(t&&t.data)for(let e=0;e<t.data.length/3;e++){const i=t.data[e*3+0],r=t.data[e*3+1],s=t.data[e*3+2];this._bounds.min.x>i&&(this._bounds.min.x=i),this._bounds.min.y>r&&(this._bounds.min.y=r),this._bounds.min.z>s&&(this._bounds.min.z=s),this._bounds.max.x<i&&(this._bounds.max.x=i),this._bounds.max.y<r&&(this._bounds.max.y=r),this._bounds.max.z<s&&(this._bounds.max.z=s)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(t){this._bounds=t}addSubGeometry(...t){let e=new xx;return e.lodLevels=t,this.subGeometries.push(e),e}generate(t){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(z.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,t),this._vertexBuffer.updateAttributes(this._attributeMap))}setIndices(t){if(!this._attributeMap.has(z.indices)){let e={attribute:z.indices,data:t};this._attributeMap.set(z.indices,e),this._indicesBuffer=new vx,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(t,e){if(t==z.indices)this.setIndices(e);else{let i={attribute:t,data:e};this._attributeMap.set(t,i),this._attributes.push(t)}}getAttribute(t){return this._attributeMap.get(t)}hasAttribute(t){return this._attributeMap.has(t)}genWireframe(){if(this._wireframeLines)return this._wireframeLines;if(this.geometryType==Rt.split||this.geometryType==Rt.compose){let t=this.getAttribute(z.position),e=this.getAttribute(z.indices);if(e&&t&&e.data.length>0){let i=t.data,r=[];for(let s=0;s<e.data.length/3;s++){const a=e.data[s*3+0],o=e.data[s*3+1],l=e.data[s*3+2];let h=new p(i[a*3+0],i[a*3+1],i[a*3+2]),u=new p(i[o*3+0],i[o*3+1],i[o*3+2]),c=new p(i[l*3+0],i[l*3+1],i[l*3+2]);r.push(h,u),r.push(u,c),r.push(c,h)}return this._wireframeLines=r,r}}else if(this.geometryType==Rt.compose_bin){let t=this.getAttribute(z.all),e=this.vertexDim,i=this.getAttribute(z.indices);if(i&&t&&i.data.length>0){let r=t.data,s=[];for(let a=0;a<i.data.length/3;a++){const o=i.data[a*3+0],l=i.data[a*3+1],h=i.data[a*3+2];let u=new p(r[o*e+0],r[o*e+1],r[o*e+2]),c=new p(r[l*e+0],r[l*e+1],r[l*e+2]),d=new p(r[h*e+0],r[h*e+1],r[h*e+2]);s.push(u,c),s.push(c,d),s.push(d,u)}return this._wireframeLines=s,s}}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let t=this.getAttribute(z.position),e=this.getAttribute(z.normal),i=this.getAttribute(z.indices);if(!t||!e||!i)return this;let r=i.data.length/3,s=Kr.point1,a=Kr.point2,o=Kr.point3,l=Kr.crossA,h=Kr.crossB,u=Kr.crossRet;for(let c=0;c<r;c++){let d=i.data[c*3],f=i.data[c*3+1],g=i.data[c*3+2];s.set(t.data[d*3],t.data[d*3+1],t.data[d*3+2]),a.set(t.data[f*3],t.data[f*3+1],t.data[f*3+2]),o.set(t.data[g*3],t.data[g*3+1],t.data[g*3+2]),p.sub(s,a,l).normalize(),p.sub(s,o,h).normalize();let m=l.crossProduct(h,u).normalize();e.data[d*3]=e.data[f*3]=e.data[g*3]=m.x,e.data[d*3+1]=e.data[f*3+1]=e.data[g*3+1]=m.y,e.data[d*3+2]=e.data[f*3+2]=e.data[g*3+2]=m.z}return this._vertexBuffer.upload(z.normal,e),this}isPrimitive(){return!1}destroy(t){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};let wt=Kr;n(wt,"crossA",p.UP.clone()),n(wt,"crossB",p.UP.clone()),n(wt,"crossRet",p.UP.clone()),n(wt,"point1",p.UP.clone()),n(wt,"point2",p.UP.clone()),n(wt,"point3",p.UP.clone());class yx extends wt{constructor(e,i,r=1,s=1,a=p.Y_AXIS){super(),n(this,"width"),n(this,"height"),n(this,"segmentW"),n(this,"segmentH"),n(this,"up"),this.width=e,this.height=i,this.segmentW=r,this.segmentH=s,this.up=a,this.buildGeometry(this.up)}buildGeometry(e){var i,r,s,a,o=this.segmentW+1;(this.segmentH+1)*o,this.bounds=new _t(p.ZERO.clone(),new p(this.width,1,this.height)),s=this.segmentH*this.segmentW*6;let l=(this.segmentW+1)*(this.segmentH+1),h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),d;this.segmentW*this.segmentH*2*3>=Uint16Array.length?d=new Uint32Array(this.segmentW*this.segmentH*2*3):d=new Uint16Array(this.segmentW*this.segmentH*2*3),s=0;for(var f=0,g=0,m=0,A=0;A<=this.segmentH;++A)for(var _=0;_<=this.segmentW;++_){switch(i=(_/this.segmentW-.5)*this.width,r=(A/this.segmentH-.5)*this.height,e){case p.Y_AXIS:h[f++]=i,h[f++]=0,h[f++]=r,u[g++]=0,u[g++]=1,u[g++]=0;break;case p.Z_AXIS:h[f++]=i,h[f++]=-r,h[f++]=0,u[g++]=0,u[g++]=0,u[g++]=1;break;case p.X_AXIS:h[f++]=0,h[f++]=i,h[f++]=r,u[g++]=1,u[g++]=0,u[g++]=0;break;default:h[f++]=i,h[f++]=0,h[f++]=r,u[g++]=0,u[g++]=1,u[g++]=0;break}c[m++]=_/this.segmentW,c[m++]=A/this.segmentH,_!=this.segmentW&&A!=this.segmentH&&(a=_+A*o,d[s++]=a+1,d[s++]=a,d[s++]=a+o,d[s++]=a+1,d[s++]=a+o,d[s++]=a+o+1)}this.setIndices(d),this.setAttribute(z.position,h),this.setAttribute(z.normal,u),this.setAttribute(z.uv,c),this.setAttribute(z.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class Yi{constructor(){n(this,"instanceID"),n(this,"name"),n(this,"enable",!0),n(this,"_defaultSubShader"),n(this,"_shader")}set shader(e){this._shader=e,this._defaultSubShader=e.getDefaultShaders()[0]}get shader(){return this._shader}get doubleSide(){return this._defaultSubShader.doubleSide}set doubleSide(e){this._defaultSubShader.doubleSide=e}get castShadow(){return this._defaultSubShader.shaderState.castShadow}set castShadow(e){this._defaultSubShader.shaderState.castShadow=e}get blendMode(){return this._defaultSubShader.blendMode}set blendMode(e){this._defaultSubShader.blendMode=e}get depthCompare(){return this._defaultSubShader.depthCompare}set depthCompare(e){this._defaultSubShader.depthCompare=e}get transparent(){return this._defaultSubShader.shaderState.transparent}set transparent(e){this._defaultSubShader.shaderState.transparent=e,e&&(this._defaultSubShader.renderOrder=3e3)}get cullMode(){return this._defaultSubShader.cullMode}set cullMode(e){this._defaultSubShader.cullMode=e}get depthWriteEnabled(){return this._defaultSubShader.depthWriteEnabled}set depthWriteEnabled(e){this._defaultSubShader.depthWriteEnabled=e}set useBillboard(e){this._defaultSubShader.setDefine("USE_BILLBOARD",e)}getPass(e){return this._shader.getSubShaders(e)}getAllPass(){return this._shader.getSubShaders(xe.COLOR)}clone(){let e=new Yi;return e.shader=this.shader.clone(),e}destroy(e){this._shader.destroy(),this._shader=null}setDefine(e,i){this.shader.setDefine(e,i)}setTexture(e,i){this._shader.setTexture(e,i)}setStorageBuffer(e,i){this._shader.setStorageBuffer(e,i)}setUniformBuffer(e,i){this._shader.setStorageBuffer(e,i)}setUniformFloat(e,i){this._shader.setUniformFloat(e,i)}setUniformVector2(e,i){this._shader.setUniformVector2(e,i)}setUniformVector3(e,i){this._shader.setUniformVector3(e,i)}setUniformVector4(e,i){this._shader.setUniformVector4(e,i)}setUniformColor(e,i){this._shader.setUniformColor(e,i)}getUniformFloat(e){return this._shader.getUniform(e).data}getUniformV2(e){return this._shader.getUniformVector2(e)}getUniformV3(e){return this._shader.getUniformVector3(e)}getUniformV4(e){return this._shader.getUniformVector4(e)}getUniformColor(e){return this._shader.getUniformColor(e)}getTexture(e){return this._shader.getTexture(e)}getStorageBuffer(e){return this._shader.getStorageBuffer(e)}getStructStorageBuffer(e){return this._shader.getStructStorageBuffer(e)}getUniformBuffer(e){return this._shader.getUniformBuffer(e)}applyUniform(){this._shader.applyUniform()}}class $t{constructor(){n(this,"computes"),n(this,"passShader"),this.computes=[],this.passShader=new Map}addRenderPass(e,i=-1){let r=this.passShader.get(e.passType)||[];i==-1?r.push(e):r.splice(i,-1,e),this.passShader.set(e.passType,r)}removeShader(e,i=-1){let r=this.passShader.get(e.passType);if(r)if(i==-1){let s=r.indexOf(e);s!=-1&&r.splice(s)}else r.splice(i,1)}removeShaderByIndex(e,i=-1){let r=this.passShader.get(e);r&&(i==-1?this.passShader.delete(e):r.splice(i,1))}getSubShaders(e){return this.passShader.get(e)||[]}hasSubShaders(e){return this.passShader.get(e).length>0}getDefaultShaders(){return this.passShader.get(xe.COLOR)}getDefaultColorShader(){return this.passShader.get(xe.COLOR)[0]}setDefine(e,i){for(const r of this.passShader)for(const s of r[1])s.setDefine(e,i)}deleteDefine(e){for(const i of this.passShader)for(const r of i[1])r.deleteDefine(e)}setUniform(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniform(e,i)}setUniformFloat(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformFloat(e,i)}setUniformVector2(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformVector2(e,i)}setUniformVector3(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformVector3(e,i)}setUniformVector4(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformVector4(e,i)}setUniformColor(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformColor(e,i)}getUniform(e){return this.getDefaultColorShader().getUniform(e)}getUniformFloat(e){return this.getDefaultColorShader().getUniformFloat(e)}getUniformVector2(e){return this.getDefaultColorShader().getUniformVector2(e)}getUniformVector3(e){return this.getDefaultColorShader().getUniformVector3(e)}getUniformVector4(e){return this.getDefaultColorShader().getUniformVector4(e)}getUniformColor(e){return this.getDefaultColorShader().getUniformColor(e)}setTexture(e,i){for(const r of this.passShader)for(const s of r[1])s.setTexture(e,i);this.setDefine(`USE_${e.toLocaleUpperCase()}`,!0)}getTexture(e){return this.getDefaultColorShader().textures[e]}setUniformBuffer(e,i){for(const r of this.passShader)for(const s of r[1])s.setUniformBuffer(e,i)}getUniformBuffer(e){return this.getDefaultColorShader().getBuffer(e)}setStorageBuffer(e,i){for(const r of this.passShader)for(const s of r[1])s.setStorageBuffer(e,i)}getStorageBuffer(e){return this.getDefaultColorShader().getBuffer(e)}setStructStorageBuffer(e,i){for(const r of this.passShader)for(const s of r[1])s.setStructStorageBuffer(e,i)}getStructStorageBuffer(e){return this.getDefaultColorShader().getBuffer(e)}noticeValueChange(){for(const e of this.passShader)for(const i of e[1])i.noticeValueChange()}destroy(){this.getDefaultColorShader().destroy()}clone(){let e=new $t,i=this.getDefaultShaders();for(const r of i)e.addRenderPass(r);return e}applyUniform(){for(const e of this.passShader)for(const i of e[1])i.applyUniform()}}var Cx=Object.defineProperty,bx=Object.getOwnPropertyDescriptor,Ix=(t,e,i,r)=>{for(var s=r>1?void 0:r?bx(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Cx(e,i,s),s};let Ul=class extends $t{constructor(t="QuadGlsl_vs",e="QuadGlsl_fs"){super();let i=new ct(t,e);this.addRenderPass(i);let r=i.shaderState;i.blendMode=Te.NONE,r.frontFace="cw",r.depthWriteEnabled=!1,r.depthCompare=zi.always,r.multisample=0,this.setTexture("baseMap",I.res.blackTexture),this.setUniformFloat("x",0),this.setUniformFloat("y",0),this.setUniformFloat("width",100),this.setUniformFloat("height",100)}};Ul=Ix([Lr],Ul);class zh extends me{constructor(e="QuadGlsl_vs",i="QuadGlsl_fs",r,s=0,a=!1){super(),n(this,"width",128),n(this,"height",128),n(this,"quadRenderer"),n(this,"material"),n(this,"rendererPassState"),n(this,"quadShader");let o=r?r.renderTargets:[];this.material=new Yi,this.quadShader=new Ul(e,i),this.material.shader=this.quadShader,this.quadRenderer=this.addComponent(Pe),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=a?2:0,this.quadRenderer.geometry=new yx(100,100,1,1),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=ui.createRendererPassState(r,"load"),s>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=D.device.createTexture({size:{width:D.presentationSize[0],height:D.presentationSize[1]},sampleCount:s,format:o.length>0?o[0].format:D.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT})),D.addEventListener(ds.RESIZE,l=>{this.rendererPassState=ui.createRendererPassState(r,"load"),s>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=D.device.createTexture({size:{width:D.presentationSize[0],height:D.presentationSize[1]},sampleCount:s,format:o.length>0?o[0].format:D.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))},this)}renderTarget(e,i,r){let s=e.camera,a=T.beginRenderPass(r,i.rendererPassState);T.bindCamera(a,s),i.quadRenderer.nodeUpdate(e,xe.COLOR,i.rendererPassState,null),i.quadRenderer.renderPass2(e,xe.COLOR,i.rendererPassState,null,a),T.endPass(a)}renderToViewQuad(e,i,r,s){let a=e.camera;i.quadShader.setTexture("baseMap",s);let o=T.beginRenderPass(r,i.rendererPassState);T.bindCamera(o,a),i.quadRenderer.nodeUpdate(e,xe.COLOR,i.rendererPassState,null),i.quadRenderer.renderPass2(e,xe.COLOR,i.rendererPassState,null,o),T.endPass(o)}}class jt{constructor(){n(this,"storeOp","store"),n(this,"loadOp","clear"),n(this,"clearValue",[0,0,0,0])}}class Xi{constructor(e,i,r,s,a=!0){n(this,"label"),n(this,"customSize",!1),n(this,"renderTargets"),n(this,"rtDescriptors"),n(this,"zPreTexture"),n(this,"depthTexture"),n(this,"depthViewIndex",0),n(this,"depthCleanValue",1),n(this,"depthLoadOp","clear"),n(this,"isOutTarget",!0),this.renderTargets=e,this.rtDescriptors=i,this.depthTexture=r,this.zPreTexture=s,this.isOutTarget=a}clone2Frame(e){e.renderTargets.push(...this.renderTargets.concat());for(let i=0;i<this.rtDescriptors.length;i++){const r=this.rtDescriptors[i];let s=new jt;s.loadOp=r.loadOp,s.storeOp=r.storeOp,s.clearValue=r.clearValue,e.rtDescriptors.push(s)}e.depthTexture=this.depthTexture,e.zPreTexture=this.zPreTexture,e.customSize=this.customSize}clone(){let e=new Xi([],[]);return this.clone2Frame(e),e}}class Qt extends Lt{constructor(e,i,r=le.rgba8unorm,s=!1,a,o=1,l=0,h=!0,u=!0){super(e,i,o),n(this,"resolveTarget"),n(this,"sampleCount"),n(this,"autoResize"),n(this,"clear"),this.name=bi(),this.autoResize=u,this.useMipmap=s,this.sampleCount=l,this.format=r,this.numberLayer=o,this.clear=h,a!=null?this.usage=a:this.usage=a|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,i),u&&D.addEventListener(ds.RESIZE,c=>{let{width:d,height:f}=c.data;this.resize(d,f),this._textureChange=!0},this)}resize(e,i){let r=D.device;this.gpuTexture&&(Lt.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=i,this.createTextureDescriptor(e,i,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==le.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=r.createSampler({})):this.format==le.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=D.device.createSampler({}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==le.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=D.device.createSampler({}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=ci.clamp_to_edge,this.addressModeV=ci.clamp_to_edge,this.gpuSampler=r.createSampler(this)),this._textureChange=!0}create(e,i,r=!0){let s=D.device;const a=e*4;let o=new Float32Array(e*i*4);const l=s.createBuffer({size:o.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,o);const h=T.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:i,depthOrArrayLayers:1}),T.endCommandEncoder(h)}clone(){let e=new Qt(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount,this.clear,this.autoResize);return e.name="clone_"+e.name,e}readTextureToImage(){let e=D.device,i=D.windowWidth,r=D.windowHeight,s=new Float32Array(i*r*4);const a=e.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return T.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[i,r]),a.getMappedRange(0,s.byteLength)}}const Un=class{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(t,e,i,r,s=!1,a=0){let o=this.rtTextureMap.get(t);return o||(t==ht.colorBufferTex_NAME?o=new Qt(e,i,r,s,void 0,1,a,!1):o=new Qt(e,i,r,s,void 0,1,a,!0),o.name=t,Un.rtTextureMap.set(t,o)),o}static createRTTextureArray(t,e,i,r,s=1,a=!1,o=0){let l=this.rtTextureMap.get(t);return l||(l=new Qt(e,i,r,a,void 0,s,o),l.name=t,Un.rtTextureMap.set(t,l)),l}static createViewQuad(t,e,i,r,s=0){let a=new Xi([r],[new jt]),o=new zh(e,i,a,s);return Un.rtViewQuad.set(t,o),o}static getTexture(t){return this.rtTextureMap.get(t)}static CreateSplitTexture(t){let e=this.getTexture(ht.colorBufferTex_NAME),i=this.getTexture(t+"_split");return i||(i=this.createRTTexture(t+"_split",e.width,e.height,e.format,!1)),i}static WriteSplitColorTexture(t){let e=this.getTexture(ht.colorBufferTex_NAME),i=this.getTexture(t+"_split");const r=T.beginCommandEncoder();r.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:i.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:i.width,height:i.height,depthOrArrayLayers:1}),T.endCommandEncoder(r)}};let Ut=Un;n(Ut,"rtTextureMap"),n(Ut,"rtViewQuad");class wx{constructor(e){n(this,"command"),n(this,"encoder"),n(this,"rendererPassStates"),n(this,"rtFrame"),this.rtFrame=e,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,T.cleanCache()}beginContinueRendererPassState(e="load",i="load"){if(this.rendererPassStates.length>0){let r=this.rtFrame.clone();for(const a of r.rtDescriptors)a.loadOp="load";r.depthLoadOp=i;let s=ui.createRendererPassState(r,e);return this.rendererPassStates.push(s),s}else{this.rtFrame.depthLoadOp=i;let r=ui.createRendererPassState(this.rtFrame,e);return this.rendererPassStates.push(r),r}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginOpaqueRenderPass(){this.beginContinueRendererPassState("clear","clear"),this.begineNewCommand(),this.beginNewEncoder()}beginTransparentRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=T.beginCommandEncoder(),this.command}endCommand(){T.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=T.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){T.endPass(this.encoder),this.encoder=null}}class ms extends Ur{constructor(){super(),n(this,"rendererPassState"),n(this,"splitRendererPassState"),n(this,"useRenderBundle",!1),n(this,"debugViewQuads"),n(this,"debugTextures"),n(this,"renderContext"),n(this,"_rendererType"),n(this,"_rtFrame"),this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=ui.createRendererPassState(e);let i=e.clone();i.depthLoadOp="load";for(const r of i.rtDescriptors)r.loadOp="load";this.splitRendererPassState=ui.createRendererPassState(i)}this.renderContext=new wx(e)}setIrradiance(e,i){this.rendererPassState.irradianceBuffer=[e,i]}compute(e,i){}render(e,i,r,s=!1){T.cleanCache();let a=e.camera,o=e.scene;this.rendererPassState.camera3D=a;let l=ie.instance.getRenderNodes(o,a),h=this.renderBundleOp(e,l,i,r),u=s?[]:this.renderBundleTr(e,l,i,r);{let c=T.beginCommandEncoder(),d=T.beginRenderPass(c,this.rendererPassState);h.length>0&&d.executeBundles(h),!s&&ie.instance.sky&&(T.bindCamera(d,a),ie.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,d)),this.drawRenderNodes(e,d,c,l.opaqueList,i),T.endPass(d),T.endCommandEncoder(c)}{let c=T.beginCommandEncoder(),d=T.beginRenderPass(c,this.rendererPassState);u.length>0&&d.executeBundles(u),s||(T.bindCamera(d,a),this.drawRenderNodes(e,d,c,l.transparentList,i)),T.endPass(d),T.endCommandEncoder(c)}}nodeUpload(e,i,r){}occlusionRenderNodeTest(e,i,r){return r?r.occlusionRenderNodeTest(e)>0:!0}renderOp(e,i,r,s,a){}renderTr(e,i,r,s,a){}renderBundleOp(e,i,r,s){let a=ie.instance.getOpRenderGroup(e.scene);if(a){let o=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=T.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}renderBundleTr(e,i,r,s){let a=ie.instance.getTrRenderGroup(e.scene);if(a){let o=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=T.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,h,l.renderNodes,s);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}recordRenderBundleNode(e,i,r,s){T.bindCamera(i,e.camera),T.bindGeometryBuffer(i,r[0].geometry);for(let a=0;a<r.length;++a){let o=r[a];o.transform.worldMatrix.index,o.transform.enable&&o.recordRenderPass2(e,this._rendererType,this.rendererPassState,s,i)}}drawRenderNodes(e,i,r,s,a,o){T.bindCamera(i,e.camera);for(let l=I.setting.render.drawOpMin;l<Math.min(s.length,I.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&h.renderPass2(e,this._rendererType,this.rendererPassState,o,i)}}setDebugTexture(e){for(let i=0;i<e.length;i++){let r=e[i],s="Quad_vert_wgsl",a="Quad_frag_wgsl";switch(r.format){case le.rgba8sint:case le.rgba8uint:case le.rgba8unorm:case le.rgba16float:case le.rgba32float:a="Quad_frag_wgsl";break;case le.depth24plus:case le.depth32float:a="Quad_depth2d_frag_wgsl",r.textureBindingLayout.viewDimension=="cube"&&(a="Quad_depthCube_frag_wgsl");break}let o=new zh(s,a,new Xi([],[]));this.debugTextures.push(e[i]),this.debugViewQuads.push(o)}}}class Sx extends ms{constructor(){super(),this.passType=xe.COLOR}render(e,i,r,s=!1){this.renderContext.clean();let a=e.scene,o=e.camera;this.rendererPassState.camera3D=o;let l=ie.instance.getRenderNodes(a,o),h=this.renderBundleOp(e,l,i,r),u=s?[]:this.renderBundleTr(e,l,i,r);ai.start("colorPass Renderer");{ai.start("ColorPass Draw Opaque"),this.renderContext.beginOpaqueRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;T.bindCamera(c,o),h.length>0&&(ie.instance.getOpRenderGroup(a),c.executeBundles(h)),!s&&ie.instance.sky&&(T.bindCamera(c,o),ie.instance.sky.preInit||ie.instance.sky.nodeUpdate(e,this._rendererType,this.rendererPassState,r),ie.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,c)),l.opaqueList&&(T.bindCamera(c,o),this.drawNodes(e,this.renderContext,l.opaqueList,i,r),this.renderContext.endRenderPass(),ai.end("ColorPass Draw Opaque"))}{ai.start("ColorPass Draw Transparent"),this.renderContext.beginTransparentRenderPass(),this.renderContext.command;let c=this.renderContext.encoder;u.length>0&&c.executeBundles(u),!s&&l.transparentList&&(T.bindCamera(c,o),this.drawNodes(e,this.renderContext,l.transparentList,i,r));let d=ie.instance.getGraphicList();for(let f=0;f<d.length;f++){const g=d[f];g.transform.worldMatrix.index,g.nodeUpdate(e,this._rendererType,this.splitRendererPassState,r),g.renderPass2(e,this._rendererType,this.splitRendererPassState,r,c)}this.renderContext.endRenderPass(),ai.end("ColorPass Draw Transparent")}ai.end("colorPass Renderer")}drawNodes(e,i,r,s,a){let o=ie.instance.getRenderShaderCollect(e);if(o){for(const l of o){let h=l[1];for(const u of h){let c=u[1];if(c.preInit){c.nodeUpdate(e,this._rendererType,this.rendererPassState,a);break}}}for(let l=I.setting.render.drawOpMin;l<Math.min(r.length,I.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState,a),h.renderPass(e,this.passType,this.renderContext))}}}occlusionRenderNodeTest(e,i,r){return r.zDepthRenderNodeTest(i)>0}}const gr=class extends Xi{constructor(){super([],[])}crateGBuffer(t,e,i){let r=this.renderTargets,s=this.rtDescriptors,a=Ut.createRTTexture(t+ht.colorBufferTex_NAME,e,i,le.rgba16float,!1),o=Ut.createRTTexture(t+ht.positionBufferTex_NAME,e,i,le.rgba16float,!1),l=Ut.createRTTexture(t+ht.normalBufferTex_NAME,e,i,le.rgba8unorm,!1),h=Ut.createRTTexture(t+ht.materialBufferTex_NAME,e,i,le.rgba8unorm,!1);gr.bufferTexture&&(r.push(a),r.push(o),r.push(l),r.push(h));let u=new jt;u.loadOp="clear";let c=new Qt(e,i,le.depth24plus,!1);c.name="depthTexture";let d=new jt;d.loadOp="load",this.depthTexture=c,gr.bufferTexture&&(s.push(u),s.push(new jt),s.push(new jt),s.push(new jt))}getColorMap(){return this.renderTargets[0]}getPositionMap(){return this.renderTargets[1]}getNormalMap(){return this.renderTargets[2]}getMaterialMap(){return this.renderTargets[3]}static getGBufferFrame(t){let e;if(gr.gBufferMap.has(t))e=gr.gBufferMap.get(t);else{e=new gr;let i=D.presentationSize;e.crateGBuffer(t,i[0],i[1]),gr.gBufferMap.set(t,e)}return e}clone(){let t=new gr;return this.clone2Frame(t),t}};let $s=gr;n($s,"gBufferMap",new Map),n($s,"bufferTexture",!1);class Gh{constructor(){n(this,"frustumCullingList"),n(this,"zVisibleList"),n(this,"_renderList"),this._renderList=new Map}occlusionRenderNodeTest(e){return I.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[e]:0:1}zDepthRenderNodeTest(e){return this.zVisibleList?this.zVisibleList[e]:0}update(e,i){}collect(e,i){}renderCommitTesting(e,i){return!0}}n(Gh,"enable",!0);class Ln extends Or{constructor(e,i){super(),this.bufferType=Hi.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,e,i,"ComputeGPUBuffer")}}class Ex{constructor(e,i){n(this,"clusterBuffer"),n(this,"lightAssignBuffer"),n(this,"assignTableBuffer"),n(this,"clustersUniformBuffer"),this.clusterBuffer=new Ln(e*2*4),this.clustersUniformBuffer=new an(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new Ln(e*i),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new Ln(e*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e,i,r,s,a,o,l,h,u,c){this.clustersUniformBuffer.setFloat("clusterTileX",s),this.clustersUniformBuffer.setFloat("clusterTileY",a),this.clustersUniformBuffer.setFloat("clusterTileZ",o),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",u),this.clustersUniformBuffer.setFloat("far",c),this.clustersUniformBuffer.setFloat("screenWidth",e),this.clustersUniformBuffer.setFloat("screenHeight",i),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class ft{}n(ft,"clusterTileX",16),n(ft,"clusterTileY",16),n(ft,"clusterTileZ",32);let Tx=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${ft.clusterTileX},${ft.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,Bx=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${ft.clusterTileX},${ft.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;class Dx extends ms{constructor(e){super(),n(this,"maxNumLightsPerCluster",64),n(this,"clusterPix",1),n(this,"clusterLightingBuffer"),n(this,"_currentLightCount",0),n(this,"_clusterGenerateCompute"),n(this,"_clusterLightingCompute"),n(this,"_useCamera"),n(this,"resize",!1),this.passType=xe.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new di(Tx),this._clusterLightingCompute=new di(Bx);let i=D.presentationSize,r=ft.clusterTileX*ft.clusterTileY*ft.clusterTileZ,s=e.camera,a=s.near,o=s.far;this.clusterLightingBuffer=new Ex(r,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(i[0],i[1],this.clusterPix,ft.clusterTileX,ft.clusterTileY,ft.clusterTileZ,0,this.maxNumLightsPerCluster,a,o),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let l=Ze.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",Ze.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",l.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0}render(e,i){let r=e.scene,s=ie.instance.getLights(r);if(this._useCamera!=e.camera){this._useCamera=e.camera;let l=Ze.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}this._currentLightCount!=s.length&&(this._currentLightCount=s.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",s.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=ft.clusterTileZ,this._clusterLightingCompute.workerSizeX=ft.clusterTileZ);let a=D.presentationSize;this.clusterLightingBuffer.update(a[0],a[1],this.clusterPix,ft.clusterTileX,ft.clusterTileY,ft.clusterTileZ,s.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let o=T.beginCommandEncoder();T.computeCommand(o,[this._clusterGenerateCompute,this._clusterLightingCompute]),T.endCommandEncoder(o)}}class Gi extends Lt{constructor(e,i,r=le.rgba8unorm,s=!1,a,o=1,l=0,h=!0){super(e,i,o),n(this,"resolveTarget"),n(this,"sampleCount"),D.device,this.name=bi(),this.useMipmap=s,this.sampleCount=l,this.format=r,this.numberLayer=o,a!=null?this.usage=a:this.usage=a|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,i)}clone(){let e=new Gi(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount);return e.name="clone_"+e.name,e}resize(e,i){let r=D.device;this.gpuTexture&&(Lt.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=i,this.createTextureDescriptor(e,i,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==le.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=r.createSampler({})):this.format==le.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=D.device.createSampler({}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==le.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=D.device.createSampler({}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=ci.clamp_to_edge,this.addressModeV=ci.clamp_to_edge,this.gpuSampler=r.createSampler(this)),this._textureChange=!0}create(e,i,r=!0){let s=D.device;const a=e*4;let o=new Float32Array(e*i*4);const l=s.createBuffer({size:o.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(l,0,o);const h=T.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:i,depthOrArrayLayers:1}),T.endCommandEncoder(h)}readTextureToImage(){let e=D.device,i=D.windowWidth,r=D.windowHeight,s=new Float32Array(i*r*4);const a=e.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return T.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[i,r]),a.getMappedRange(0,s.byteLength)}}class Rx extends me{constructor(e=.001,i=1e4,r=90,s=!1){super(),n(this,"up_camera"),n(this,"down_camera"),n(this,"left_camera"),n(this,"right_camera"),n(this,"front_camera"),n(this,"back_camera"),this.initCubeCamera(e,i,r,s)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,i,r=90,s=!1){this.up_camera=mt.createCamera3DObject(this,"up"),this.down_camera=mt.createCamera3DObject(this,"down"),this.left_camera=mt.createCamera3DObject(this,"left"),this.right_camera=mt.createCamera3DObject(this,"right"),this.front_camera=mt.createCamera3DObject(this,"front"),this.back_camera=mt.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,i),this.up_camera.lookAt(p.ZERO,p.UP,p.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(r,a,e,i),this.down_camera.lookAt(p.ZERO,p.DOWN,p.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(r,a,e,i),this.left_camera.lookAt(p.ZERO,p.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(r,a,e,i),this.right_camera.lookAt(p.ZERO,p.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(r,a,e,i),this.front_camera.lookAt(p.ZERO,p.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(r,a,e,i),this.back_camera.lookAt(p.ZERO,p.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=Je.shadow,this.down_camera.type=Je.shadow,this.left_camera.type=Je.shadow,this.right_camera.type=Je.shadow,this.front_camera.type=Je.shadow,this.back_camera.type=Je.shadow}}class Mx extends Lt{constructor(e,i,r){super(e,i,r),this.format=le.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=D.device.createSampler({minFilter:ar.linear,magFilter:ar.linear}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Px extends ms{constructor(){super(),n(this,"shadowPassCount"),n(this,"_forceUpdate",!1),n(this,"_shadowCameraDic"),n(this,"shadowCamera"),n(this,"cubeArrayTexture"),n(this,"colorTexture"),n(this,"shadowSize",1024),this.passType=xe.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new Mx(this.shadowSize,this.shadowSize,8),this.colorTexture=new Gi(this.shadowSize,this.shadowSize,le.bgra8unorm,!1),Me.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,i){var r;let s;if(this._shadowCameraDic.has(i))s=this._shadowCameraDic.get(i);else{let a=new Rx(e.camera.near,e.camera.far,90,!0);a.label=i.name;let o=[],l=[];for(let h=0;h<6;h++){let u=new Gi(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),c=new Xi([this.colorTexture],[new jt]);u.name="shadowDepthTexture_"+i.name+h+"_face",c.depthTexture=u,c.label="shadowRender",c.customSize=!0;let d=ui.createRendererPassState(c);l[h]=d,o[h]=u,(r=I.getRenderJob(e).postRenderer)==null||r.setDebugTexture([u])}s={cubeCamera:a,depthTexture:o,rendererPassState:l},this._shadowCameraDic.set(i,s)}return s}render(e,i){if(!I.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let r=e.scene,s=Mt.getPointShadowLightWhichScene(r),a=s.length;for(let o=0;o<a;o++){let l=s[o];if(l.lightData.lightType!=dt.DirectionLight&&l.lightData.castShadowIndex>-1&&(l.needUpdateShadow||this._forceUpdate||He.frame<5||l.realTimeShadow)){l.needUpdateShadow=!1;let h=this.getShadowCamera(e,l),u=l.transform.worldPosition;h.cubeCamera.x=u.x,h.cubeCamera.y=u.y,h.cubeCamera.z=u.z;let c;h.cubeCamera.transform.updateWorldMatrix(!0),i.update(h.cubeCamera.right_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.right_camera),this.renderSceneOnce(0,h,e,h.cubeCamera.right_camera,c,i),i.update(h.cubeCamera.left_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.left_camera),this.renderSceneOnce(1,h,e,h.cubeCamera.left_camera,c,i),i.update(h.cubeCamera.up_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.up_camera),this.renderSceneOnce(2,h,e,h.cubeCamera.up_camera,c,i),i.update(h.cubeCamera.down_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.down_camera),this.renderSceneOnce(3,h,e,h.cubeCamera.down_camera,c,i),i.update(h.cubeCamera.front_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.front_camera),this.renderSceneOnce(4,h,e,h.cubeCamera.front_camera,c,i),i.update(h.cubeCamera.back_camera,r),c=ie.instance.getRenderNodes(r,h.cubeCamera.back_camera),this.renderSceneOnce(5,h,e,h.cubeCamera.back_camera,c,i);let d=T.beginCommandEncoder();for(let f=0;f<6;f++)d.copyTextureToTexture({texture:h.depthTexture[f].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:l.shadowIndex*6+f}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});T.endCommandEncoder(d)}}this._forceUpdate=!1}renderSceneOnce(e,i,r,s,a,o){this.rendererPassState=i.rendererPassState[e];let l=T.beginCommandEncoder(),h=T.beginRenderPass(l,this.rendererPassState);h.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.setScissorRect(0,0,this.shadowSize,this.shadowSize),s.onUpdate(),s.transform.updateWorldMatrix(!0);let u=ie.instance.getRenderShaderCollect(r);for(const c of u){let d=c[1];for(const f of d){let g=f[1];if(g.preInit){g.nodeUpdate(r,this._rendererType,this.rendererPassState,null);break}}}this.drawShadowRenderNodes(r,s,h,a.opaqueList,o),this.drawShadowRenderNodes(r,s,h,a.transparentList,o),T.endPass(h),T.endCommandEncoder(l)}drawShadowRenderNodes(e,i,r,s,a){if(T.bindCamera(r,i),s)for(let o=I.setting.render.drawOpMin;o<Math.min(s.length,I.setting.render.drawOpMax);++o){let l=s[o];if(l.transform.worldMatrix.index,!!l.transform.enable&&l.enable){l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState);for(let h of l.materials){let u=h.getPass(this._rendererType);if(!u||u.length==0)continue;T.bindGeometryBuffer(r,l.geometry);let c=l.object3D.transform._worldMatrix;for(let d of u){const f=d;if(f.pipeline){f.setUniformFloat("cameraFar",i.far),f.setUniformVector3("lightWorldPos",i.transform.worldPosition),f.materialDataUniformBuffer.apply(),T.bindPipeline(r,f);let g=l.geometry.subGeometries;for(const m of g){let A=m.lodLevels[l.lodLevel];T.drawIndexed(r,A.indexCount,1,A.indexStart,0,c.index)}}}}}}}}class Ux extends Lt{constructor(e,i,r=le.depth32float,s=4){super(e,i,s),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=D.device.createSampler({}),this.gpuSampler_comparison=D.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Lx extends ms{constructor(){super(),n(this,"shadowPassCount"),n(this,"depth2DArrayTexture"),n(this,"rendererPassStates"),n(this,"_forceUpdate",!1),n(this,"_shadowPos",new p),n(this,"_shadowCameraTarget",new p),this.setShadowMap(I.setting.shadow.shadowSize,Jt.Cascades),this.passType=xe.SHADOW}setShadowMap(e,i){this.rendererPassStates=[],this.depth2DArrayTexture=new Ux(e,e,le.depth32float,8),Me.getInstance().attached(this.depth2DArrayTexture,this);for(let r=0;r<8;r++){let s=new Xi([],[]);const a=new Gi(e,e,le.depth32float,!1);a.name=`shadowDepthTexture_${r}`,s.depthTexture=a,s.label="shadowRender",s.customSize=!0,s.depthCleanValue=1;let o=ui.createRendererPassState(s);this.rendererPassStates[r]=o}}render(e,i){let r=I.setting.shadow;if(!r.enable)return;let s=e.camera,a=e.scene;if(this.shadowPassCount=0,!r.needUpdate||He.frame%r.updateFrameRate!=0)return;let o=Mt.getDirectShadowLightWhichScene(a),l=r.shadowSize;const h=Jt.Cascades;for(let u of o){const c=u;let d=c.shadowIndex;this.rendererPassState=this.rendererPassStates[d];let f=ie.instance.getRenderShaderCollect(e);for(const g of f){let m=g[1];for(const A of m){let _=A[1];if(_.preInit){_.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(c.castShadow&&c.needUpdateShadow||this._forceUpdate||c.castShadow&&r.autoUpdate)if(c.needUpdateShadow=!1,s.enableCSM&&d==0)for(let g=0;g<h;g++){this.rendererPassState=this.rendererPassStates[g];let m=s.csm.children[g],A=s.getCSMShadowWorldExtents(g);this.poseShadowCamera(s,c.direction,m.shadowCamera,A,m.bound.center),this.renderShadow(e,m.shadowCamera,i,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,g,l)}else{s.enableCSM&&(d+=h-1);let g=s.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[d],this.poseShadowCamera(s,c.direction,c.shadowCamera,g,s.lookTarget),this.renderShadow(e,c.shadowCamera,i,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,d,l)}}this._forceUpdate=!1}copyDepthTexture(e,i,r,s){let a=T.beginCommandEncoder();a.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:i.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:s,height:s,depthOrArrayLayers:1}),T.endCommandEncoder(a)}poseShadowCamera(e,i,r,s,a){this._shadowPos.copy(i).normalize(e.far),a.add(this._shadowPos,this._shadowCameraTarget),a.subtract(this._shadowPos,this._shadowPos),r.transform.lookAt(this._shadowPos,this._shadowCameraTarget),r.orthoOffCenter(-s,s,-s,s,e.near,e.far*2)}compute(){}renderShadow(e,i,r,s){let a=ie.instance.getRenderNodes(e.scene,i),o=T.beginCommandEncoder(),l=T.beginRenderPass(o,s);i.transform.updateWorldMatrix(),Gh.enable&&(r.update(i,e.scene),r.collect(a,i)),T.bindCamera(l,i);let h=this.renderShadowBundleOp(e,i,s),u=this.renderShadowBundleTr(e,i,s);h.length>0&&l.executeBundles(h),this.drawShadowRenderNodes(e,i,l,a.opaqueList),u.length>0&&l.executeBundles(u),this.drawShadowRenderNodes(e,i,l,a.transparentList),T.endPass(l),T.endCommandEncoder(o)}renderShadowBundleOp(e,i,r){let s=ie.instance.getOpRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(o=>{if(o.bundleMap.has(this._rendererType))a.push(o.bundleMap.get(this._rendererType));else{let l=T.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,i,l,o.renderNodes);let h=l.finish();o.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}renderShadowBundleTr(e,i,r){let s=ie.instance.getTrRenderGroup(e.scene);if(s){let a=[];return s.renderGroup.forEach(o=>{if(o.bundleMap.has(this._rendererType))a.push(o.bundleMap.get(this._rendererType));else{let l=T.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,i,l,o.renderNodes);let h=l.finish();o.bundleMap.set(this._rendererType,h),a.push(h)}}),a}return[]}recordShadowRenderBundleNode(e,i,r,s,a){if(T.bindCamera(r,i),s){T.bindGeometryBuffer(r,s[0].geometry);for(let o=0;o<s.length;++o){let l=s[o];l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}drawShadowRenderNodes(e,i,r,s,a){if(T.bindCamera(r,i),s)for(let o=I.setting.render.drawOpMin;o<Math.min(s.length,I.setting.render.drawOpMax);++o){let l=s[o];l.transform.enable&&l.enable&&l.renderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}class Ox extends ms{constructor(){super(),n(this,"zBufferTexture"),n(this,"useRenderBundle",!1),n(this,"shadowPassCount"),n(this,"zCullingCompute"),this.passType=xe.DEPTH;let e=D.presentationSize,i=1;this.zBufferTexture=Ut.createRTTexture(ht.zBufferTexture_NAME,Math.floor(e[0]*i),Math.floor(e[1]*i),le.rgba16float,!1);let r=new jt;r.clearValue=[0,0,0,0],r.loadOp="clear";let s=new Xi([],[],Ut.createRTTexture(ht.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),le.depth32float,!1),null,!1);this.setRenderStates(s)}render(e,i){let r=e.camera,s=e.scene;T.cleanCache(),ai.start("DepthPass Renderer");let a=s;this.rendererPassState.camera3D=r;let o=ie.instance.getRenderNodes(a,r);this.compute(e,i);let l=this.renderBundleOp(e,o,i),h=[],u=T.beginCommandEncoder(),c=T.beginRenderPass(u,this.rendererPassState);l.length>0&&c.executeBundles(l);let d=ie.instance.getRenderShaderCollect(e);for(const f of d){let g=f[1];for(const m of g){let A=m[1];if(A.preInit){A.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,c,u,o.opaqueList,i),h.length>0&&c.executeBundles(h),T.endPass(c),T.endCommandEncoder(u),ai.end("DepthPass Renderer")}drawRenderNodes(e,i,r,s,a,o){T.bindCamera(i,e.camera);for(let l=I.setting.render.drawOpMin;l<Math.min(s.length,I.setting.render.drawOpMax);++l){let h=s[l];h.transform.enable&&h.enable&&(h.preInit||h.nodeUpdate(e,this._rendererType,this.rendererPassState),h.renderPass2(e,this._rendererType,this.rendererPassState,o,i))}}}class Nx{constructor(){n(this,"map"),n(this,"passRendererList"),this.map=new Map,this.passRendererList=[]}addRenderer(e){this.map.has(e.passType)?console.error("same renderer pass repeat!"):(this.map.set(e.passType,e),e.passType<=8&&this.addPassRenderer(e))}getRenderer(e){return this.map.get(e)}addPassRenderer(e){this.passRendererList.push(e)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Fx extends ms{constructor(){super(),n(this,"finalQuadView"),n(this,"postList"),this._rendererType=xe.POST,this.postList=[],this.initRenderer()}initRenderer(){W.register("FullQuad_vert_wgsl",$0),this.finalQuadView=new zh("Quad_vert_wgsl","Quad_frag_wgsl",new Xi([],[]),0,!1)}attachPost(e,i){i.postRenderer=this,this.postList.indexOf(i)!=-1||(this.postList.push(i),i.onAttach(e))}detachPost(e,i){let r=this.postList.indexOf(i);return r>=0&&(this.postList.splice(r,1),i.onDetach(e),i.postRenderer=null),r>=0}render(e){let i=T.beginCommandEncoder();for(let s=0;s<this.postList.length;s++){const a=this.postList[s];a.enable&&a.render(e,i)}let r=T.lastRenderPassState.getLastRenderTexture();if(this.finalQuadView.renderToViewQuad(e,this.finalQuadView,i,r),this.debugViewQuads.length){let s=I.setting.render.debugQuad;s>=0&&this.debugViewQuads[s].renderToViewQuad(e,this.debugViewQuads[s],i,this.debugTextures[s])}T.endCommandEncoder(i)}}class Ll{constructor(){n(this,"enable",!0),n(this,"postRenderer"),n(this,"rtViewQuad"),n(this,"virtualTexture"),this.rtViewQuad=new Map,this.virtualTexture=new Map,D.addEventListener(ds.RESIZE,this.onResize,this)}createRTTexture(e,i,r,s,a=!1,o=0){let l=Ut.createRTTexture(e,i,r,s,a,o);return l.name=e,this.virtualTexture.set(e,l),Me.getInstance().attached(l,this),l}createViewQuad(e,i,r,s=0){let a=Ut.createViewQuad(e,"Quad_vert_wgsl",i,r,s);return this.rtViewQuad.set(e,a),a}getOutTexture(){let e,i=T.lastRenderPassState.renderTargets;return i.length>0?e=i[0]:e=Ut.getTexture(ht.colorBufferTex_NAME),e}autoSetColorTexture(e,i){let r=this.getOutTexture();i.setSamplerTexture(e,r)}compute(e){}onAttach(e){}onDetach(e){}onResize(){}render(e,i){this.compute(e),this.rtViewQuad.forEach((r,s)=>{let a=T.lastRenderPassState.getLastRenderTexture();r.renderToViewQuad(e,r,i,a)})}destroy(e){this.postRenderer=null;for(let i=0;i<this.rtViewQuad.size;i++)this.rtViewQuad.values[i].destroy(e);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let i=0;i<this.virtualTexture.size;i++){const r=this.virtualTexture.values[i];Me.getInstance().detached(r,this),r.destroy(e)}}}class kx{constructor(e){n(this,"rendererMap"),n(this,"shadowMapPassRenderer"),n(this,"pointLightShadowRenderer"),n(this,"ddgiProbeRenderer"),n(this,"postRenderer"),n(this,"clusterLightingRender"),n(this,"occlusionSystem"),n(this,"depthPassRenderer"),n(this,"colorPassRenderer"),n(this,"pauseRender",!1),n(this,"pickFire"),n(this,"renderState",!1),n(this,"_view"),this._view=e,this.rendererMap=new Nx,this.occlusionSystem=new Gh,this.clusterLightingRender=this.addRenderer(Dx,e),I.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Ox)),this.shadowMapPassRenderer=new Lx,this.pointLightShadowRenderer=new Px}addRenderer(e,i){let r;return i?r=new e(i):r=new e,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(e){this._view=e}start(){this.renderState=!0}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}enablePost(e){this.postRenderer=this.addRenderer(Fx),this.postRenderer.setRenderStates(e)}addPost(e){return this.postRenderer||($s.bufferTexture=!0,this.enablePost($s.getGBufferFrame("ColorPassGBuffer"))),e instanceof Ll&&this.postRenderer.attachPost(this.view,e),e}removePost(e){if(e instanceof Ll)this.postRenderer.detachPost(this.view,e);else for(let i=0;i<e.length;i++)this.postRenderer.detachPost(this.view,e[i])}renderFrame(){let e=this._view;Ze.getLightEntries(e.scene).update(e),this.occlusionSystem.update(e.camera,e.scene),this.clusterLightingRender.render(e,this.occlusionSystem),this.shadowMapPassRenderer&&(Mt.update(e),this.shadowMapPassRenderer.render(e,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(e,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(e,this.occlusionSystem),this.depthPassRenderer.render(e,this.occlusionSystem)),I.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(e,this.occlusionSystem),this.ddgiProbeRenderer.render(e,this.occlusionSystem));let i=this.rendererMap.getAllPassRenderer();for(let r=0;r<i.length;r++){const s=i[r];s.compute(e,this.occlusionSystem),s.render(e,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer)}this.postRenderer&&this.postRenderer.postList.length>0&&this.postRenderer.render(e)}debug(){}}class Qx extends me{constructor(e=.001,i=1e4,r=90,s=!1){super(),n(this,"up_camera"),n(this,"down_camera"),n(this,"left_camera"),n(this,"right_camera"),n(this,"front_camera"),n(this,"back_camera"),this.initCubeCamera(e,i,r,s)}initCubeCamera(e,i,r=90,s=!1){this.up_camera=mt.createCamera3DObject(this,"up"),this.down_camera=mt.createCamera3DObject(this,"down"),this.left_camera=mt.createCamera3DObject(this,"left"),this.right_camera=mt.createCamera3DObject(this,"right"),this.front_camera=mt.createCamera3DObject(this,"front"),this.back_camera=mt.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=s,this.down_camera.isShadowCamera=s,this.left_camera.isShadowCamera=s,this.right_camera.isShadowCamera=s,this.front_camera.isShadowCamera=s,this.back_camera.isShadowCamera=s;let a=1;this.up_camera.perspective(r,a,e,i),this.up_camera.lookAt(p.ZERO,p.UP,p.DOWN),this.down_camera.perspective(r,a,e,i),this.down_camera.lookAt(p.ZERO,p.DOWN,p.DOWN),this.left_camera.perspective(r,a,e,i),this.left_camera.lookAt(p.ZERO,p.LEFT),this.right_camera.perspective(r,a,e,i),this.right_camera.lookAt(p.ZERO,p.RIGHT),this.front_camera.perspective(r,a,e,i),this.front_camera.lookAt(p.ZERO,p.FORWARD),this.back_camera.perspective(r,a,e,i),this.back_camera.lookAt(p.ZERO,p.BACK),this.up_camera.type=Je.shadow,this.down_camera.type=Je.shadow,this.left_camera.type=Je.shadow,this.right_camera.type=Je.shadow,this.front_camera.type=Je.shadow,this.back_camera.type=Je.shadow}}class zx extends Xi{constructor(e,i,r=!0){super([],[]),this.crateGBuffer(e,i,r)}crateGBuffer(e,i,r){let s=this.renderTargets,a=this.rtDescriptors,o=new Qt(e,i,le.rgba16float,!1,void 0,1,0,!0,r);o.name="positionMap";let l=new jt;l.loadOp="load";let h=new Qt(e,i,le.rgba16float,!1,void 0,1,0,!0,r);h.name="normalMap";let u=new jt;u.loadOp="load";let c=new Qt(e,i,le.rgba16float,!1,void 0,1,0,!0,r);c.name="colorMap";let d=new jt;d.loadOp="load";let f=new Qt(e,i,le.depth24plus,!1,void 0,1,0,!0,r);f.name="depthTexture";let g=new jt;g.loadOp="load",s.push(o),s.push(h),s.push(c),a.push(l),a.push(u),a.push(d),this.depthTexture=f}}let Gx=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //左右
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //上下
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //补角
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Vx{constructor(e){n(this,"irradianceBuffer"),n(this,"depthBuffer"),n(this,"probeIrradianceMap"),n(this,"probeDepthMap"),n(this,"volume"),n(this,"computeShader"),n(this,"depthRaysBuffer"),this.volume=e,this.initPipeline()}initPipeline(){this.computeShader=new di(Gx);let e=I.setting.gi,i=e.octRTMaxSize*e.octRTMaxSize;this.irradianceBuffer=new At(i*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new At(i*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new At(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",Ze.modelMatrixBindGroup.matrixBufferDst)}setTextures(e,i,r){this.probeIrradianceMap=i,this.probeDepthMap=r;let s=e[0],a=e[1],o=e[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",s),this.computeShader.setSamplerTexture("normalMap",a),this.computeShader.setSamplerTexture("colorMap",o)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(e,i){let r=this.volume.setting,s=T.beginCommandEncoder(),a=ie.instance.getProbes(e.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=a.length,T.computeCommand(s,[this.computeShader])}}let Hx=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Yx{constructor(e){n(this,"blendTexture"),n(this,"volume"),n(this,"computerShader"),this.volume=e,this.initPipeline()}initPipeline(){let e=I.setting.gi;this.blendTexture=new Qt(e.probeSourceTextureSize,e.probeSourceTextureSize,le.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new di(Hx),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(e){let i=e[0],r=e[1],s=e[2],a=e[3];this.computerShader.setSamplerTexture("normalMap",i),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",s),this.computerShader.setSamplerTexture("irradianceMap",a)}compute(e,i){let r=T.beginCommandEncoder(),s=this.volume.setting,a=s.probeXCount*s.probeYCount*s.probeZCount,o=s.probeSize;this.computerShader.workerSizeX=o*6/8,this.computerShader.workerSizeY=o/8,this.computerShader.workerSizeZ=a,T.computeCommand(r,[this.computerShader])}}let Xx=`
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(1) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(2) var prefilterMapSampler: sampler;
@group(0) @binding(3) var prefilterMap: texture_cube<f32>;

@group(1) @binding(0) var positionMapSampler : sampler;
@group(1) @binding(1) var positionMap : texture_2d<f32>;

@group(1) @binding(2) var normalMapSampler : sampler;
@group(1) @binding(3) var normalMap : texture_2d<f32>;

@group(1) @binding(4) var colorMapSampler : sampler;
@group(1) @binding(5) var colorMap : texture_2d<f32>;

@group(1) @binding(6) var shadowMapSampler : sampler_comparison;
@group(1) @binding(7) var shadowMap : texture_depth_2d_array;

@group(1) @binding(8) var pointShadowMapSampler: sampler;
@group(1) @binding(9) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${Jt.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
  var shadowIndex = i32(light.castShadow);
  if (shadowIndex >= 0 ) {
    var shadowMatrix:mat4x4<f32>;
    if(enableCSM && csmCount > 1){
      for(var csm:i32 = 0; csm < csmCount; csm ++){
        var csmShadowBias = globalUniform.csmShadowBias[csm];
        shadowMatrix = globalUniform.csmMatrix[csm];
        let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
        if(csmShadowResult.y < 0.5){
          visibility = csmShadowResult.x;
          break;
        }
      }
    }else{
      shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
      visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
    }
  }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`;class Kx{constructor(){n(this,"computeShader"),n(this,"worldPosMap"),n(this,"worldNormalMap"),n(this,"colorMap"),n(this,"shadowMap"),n(this,"pointShadowMap"),n(this,"lightingTexture");let e=I.setting.gi;this.lightingTexture=new Qt(e.probeSourceTextureSize,e.probeSourceTextureSize,le.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(e){let i=Ze.getLightEntries(e.scene);this.computeShader=new di(Xx);let r=Ze.getCameraGroup(e.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",i.storageGPUBuffer),this.computeShader.setStorageBuffer("models",Ze.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",I.res.defaultSky)}setInputs(e){this.worldPosMap=e[0],this.worldNormalMap=e[1],this.colorMap=e[2],this.shadowMap=e[3],this.pointShadowMap=e[4]}compute(e,i){this.computeShader||this.create(e);let r=T.beginCommandEncoder(),s=I.setting.gi;this.computeShader.workerSizeX=s.probeSourceTextureSize/8,this.computeShader.workerSizeY=s.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,T.computeCommand(r,[this.computeShader])}}let Ol=new Tt("GIRenderStartEvent"),Of=new Tt("GIRenderCompleteEvent");class Wx{constructor(){n(this,"count"),n(this,"complete")}}class jx extends ms{constructor(e){super(),n(this,"cubeCamera"),n(this,"volume"),n(this,"probeCountPerFrame",1),n(this,"nextProbeIndex",-1),n(this,"tempProbeList",[]),n(this,"isRenderCloudGI"),n(this,"probeRenderResult"),n(this,"renderStatus","none"),n(this,"positionMap"),n(this,"normalMap"),n(this,"colorMap"),n(this,"probeNext",128),n(this,"sizeW"),n(this,"sizeH"),n(this,"lightingPass"),n(this,"bouncePass"),n(this,"irradianceComputePass"),n(this,"irradianceDepthMap"),n(this,"irradianceColorMap"),this.passType=xe.GI,this.volume=e;let i=e.setting;this.cubeCamera=new Qx(.01,5e3),this.sizeW=i.probeSourceTextureSize,this.sizeH=i.probeSourceTextureSize,this.probeNext=i.probeSourceTextureSize/i.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new Wx;let r=new zx(this.sizeW,this.sizeH,!1);this.positionMap=r.renderTargets[0],this.normalMap=r.renderTargets[1],this.colorMap=r.renderTargets[2],this.setRenderStates(r)}setInputTexture(e){this.lightingPass=new Kx,this.bouncePass=new Yx(this.volume),this.irradianceComputePass=new Vx(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,i,r,s){if(r!=this.irradianceColorMap.width||s!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,r,s),this.writeToTexture(this.irradianceDepthMap,i,r,s)}updateProbe(e,i,r){let s=ie.instance.getLights(e.scene),a=this.volume.setting.probeSize;i.drawCallFrame+=1,this.cubeCamera.x=i.x,this.cubeCamera.y=i.y,this.cubeCamera.z=i.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=i.rotationX,this.cubeCamera.rotationY=i.rotationY,this.cubeCamera.rotationZ=i.rotationZ);let o=this.cubeCamera,l=Math.floor(i.index/this.probeNext)*(a*6),h=Math.floor(i.index%this.probeNext)*a;r.setViewport(0+l,h,a,a,0,1),this.renderSceneOnce(e,o.right_camera,r,s),r.setViewport(a+l,h,a,a,0,1),this.renderSceneOnce(e,o.left_camera,r,s),r.setViewport(a*2+l,h,a,a,0,1),this.renderSceneOnce(e,o.up_camera,r,s),r.setViewport(a*3+l,h,a,a,0,1),this.renderSceneOnce(e,o.down_camera,r,s),r.setViewport(a*4+l,h,a,a,0,1),this.renderSceneOnce(e,o.front_camera,r,s),r.setViewport(a*5+l,h,a,a,0,1),this.renderSceneOnce(e,o.back_camera,r,s)}renderSceneOnce(e,i,r,s){this.volume.uploadBuffer();let a=ie.instance.getRenderNodes(e.scene,i);T.bindCamera(r,i);let o=Math.max(0,I.setting.render.drawOpMin),l=Math.min(I.setting.render.drawOpMax,a.opaqueList.length),h=ie.instance.getRenderShaderCollect(e);for(const u of h){let c=u[1];for(const d of c){let f=d[1];if(f.preInit){f.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let u=o;u<l;++u){let c=a.opaqueList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}ie.instance.sky&&(ie.instance.sky.preInit||ie.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),ie.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,r)),o=Math.max(0,I.setting.render.drawTrMin),l=Math.min(I.setting.render.drawTrMax,a.transparentList.length);for(let u=o;u<l;++u){let c=a.transparentList[u];c.enable&&c.transform.enable&&(c.preInit||c.nodeUpdate(e,this.passType,this.rendererPassState,null),c.renderPass2(e,this.passType,this.rendererPassState,null,r))}}render(e,i){if(!I.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let r=this.probeRenderResult.count>0;(ie.instance.state.giLightingChange||r||I.setting.gi.realTimeGI)&&(ie.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(Of)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(Ol),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(Ol),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let i=I.setting.gi.autoRenderProbe,r=!1;if(i?(this.nextProbeIndex==-1&&this.startRenderGI(),r=!0):r=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,r){let s=ie.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginOpaqueRenderPass(),this.tempProbeList.length=0;let a=Math.min(this.probeCountPerFrame,s.length);for(this.probeRenderResult.count=a;a>0;){const l=s[this.nextProbeIndex];this.updateProbe(e,l,this.renderContext.encoder),a--,this.nextProbeIndex++,l.drawCallFrame<3&&this.tempProbeList.push(l)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let o=this.nextProbeIndex>=s.length;this.nextProbeIndex>=s.length&&this.isRenderCloudGI&&this.updateProbe(e,s[0],this.renderContext.encoder),this.renderContext.endRenderPass(),o&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let i=e.setting,r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new Qt(i.octRTMaxSize,i.octRTMaxSize,le.rgba16float,!1,r),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new Qt(i.octRTMaxSize,i.octRTMaxSize,le.rgba16float,!1,r),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,i,r,s){console.log(e.name);const a=D.device.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});D.device.queue.writeBuffer(a,0,i);const o=T.beginCommandEncoder();o.copyBufferToTexture({buffer:a,bytesPerRow:r*16},{texture:e.getGPUTexture()},{width:r,height:s,depthOrArrayLayers:1}),T.endCommandEncoder(o)}}class yc extends kx{constructor(e){super(e)}start(){super.start();let e=$s.getGBufferFrame("ColorPassGBuffer");{let i=[],r=new Sx;I.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),r.setRenderStates(e);for(let s=0;s<e.renderTargets.length;s++){const a=e.renderTargets[s];i.push(a)}if(I.setting.gi.enable){let s=Ze.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new jx(s.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer),i.push(this.ddgiProbeRenderer.positionMap,this.ddgiProbeRenderer.normalMap,this.ddgiProbeRenderer.colorMap,this.ddgiProbeRenderer.lightingPass.lightingTexture,this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap)}this.postRenderer&&this.postRenderer.setDebugTexture(i),this.rendererMap.addRenderer(r)}I.setting.render.debug&&this.debug()}debug(){}}class qx{constructor(){n(this,"_factor"),n(this,"_doubleFactor"),this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(e){this._factor=e,this._doubleFactor=2*this._factor}getInterpolation(e){return this._factor==1?e*e:Math.pow(e,this._doubleFactor)}}class Jx{constructor(){n(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(e){this._factor=e}getInterpolation(e){let i;return this._factor==1?i=1-(1-e)*(1-e):i=1-Math.pow(1-e,2*this._factor),i}}class Zx{constructor(){n(this,"_factor",1)}getInterpolation(e){return Math.cos((e+1)*Math.PI)/2+.5}}class $x{getInterpolation(e){return e}}class ey{getInterpolation(e){return 4.9*e+4.9*e}}class ii{constructor(){}static bounce(e){return e*e*9.8}getInterpolation(e){return e*=1.1226,e<.3535?ii.bounce(e):e<.7408?ii.bounce(e-.54719)+.7:e<.9644?ii.bounce(e-.8526)+.9:ii.bounce(e-1.0435)+.95}getBounceInterpolation(e){return e<.5?ii.bounce(e):ii.bounce(e-1)}geJumpUp(e,i){return i<.5?(i=i/.5,e*i-ii.bounce(i)):i<.8?(i=(i-.5)/(.8-.5),(e*i-ii.bounce(i))*.3):i<1?(i=(i-.8)/(1-.8),(e*i-ii.bounce(i))*.15):e*i-ii.bounce(i)}}class ty{constructor(){n(this,"_tension"),this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(e){this._tension=e}getInterpolation(e){return e*e*((this._tension+1)*e-this._tension)}}class so{constructor(){n(this,"_tension"),this._tension=1*1.5}anticipateOvershootInterpolator(e){this._tension=e*1.5}anticipateOvershootInterpolator2(e,i){this._tension=e*i}getInterpolation(e){return e<.5?.5*so.a(e*2,this._tension):.5*(so.o(e*2-2,this._tension)+2)}static a(e,i){return e*e*((i+1)*e-i)}static o(e,i){return e*e*((i+1)*e+i)}}class iy{constructor(e){n(this,"_cycles"),this._cycles=e}getInterpolation(e){return Math.sin(2*this._cycles*Math.PI*e)}}class ry{constructor(){n(this,"_tension"),this._tension=2}getInterpolation(e){return e-=1,e*e*((this._tension+1)*e+this._tension)+1}}var Nf=(t=>(t[t.AccelerateInterpolator=0]="AccelerateInterpolator",t[t.DecelerateInterpolator=1]="DecelerateInterpolator",t[t.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",t[t.LinearInterpolator=3]="LinearInterpolator",t[t.BounceInterpolator=4]="BounceInterpolator",t[t.AnticipateInterpolator=5]="AnticipateInterpolator",t[t.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",t[t.CycleInterpolator=7]="CycleInterpolator",t[t.OvershootInterpolator=8]="OvershootInterpolator",t[t.JumperInterpolator=9]="JumperInterpolator",t))(Nf||{});const Ts=class{constructor(){n(this,"complete",!1),n(this,"onComplete"),n(this,"onProgress"),n(this,"target"),n(this,"property"),n(this,"targetProperty"),n(this,"durtion"),n(this,"interpolatorEnum"),n(this,"delayTime",0),n(this,"_interpolator"),n(this,"_ct",0),n(this,"_p",0)}static to(t,e,i,r=0){var s=new Ts;return s.target=t,s.property=e,s.durtion=i,s.interpolatorEnum=r,s.start(),s.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(s.onComplete=e.onComplete),e.onProgress&&(s.onProgress=e.onProgress),this.interpolators.push(s),s}static tick(t){let e=Ts.interpolators;for(let i of e)i.complete?Ts.remove(i,!0):i.tick(t)}static remove(t,e){let i=Ts.interpolators,r=i.indexOf(t);r!=-1&&i.splice(r,1),e&&t.dispose()}static removeList(t,e){t.forEach(i=>{this.remove(i,e)})}start(){window.AccelerateInterpolator=qx,window.DecelerateInterpolator=Jx,window.AccelerateDecelerateInterpolator=Zx,window.LinearInterpolator=$x,window.BounceInterpolator=ii,window.AnticipateInterpolator=ty,window.AnticipateOvershootInterpolator=so,window.CycleInterpolator=iy,window.OvershootInterpolator=ry,window.JumperInterpolator=ey,this._interpolator=new window[Nf[this.interpolatorEnum]],this.targetProperty={};for(let t in this.property)this.targetProperty[t]=this.target[t]}tick(t){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),i=this.property,r=this.target,s=this.targetProperty,a,o;for(let l in i)o=i[l],a=s[l],r[l]=a+(o-a)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=t}else this.delayTime-=t}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,Ts.remove(this)}};let Ff=Ts;n(Ff,"interpolators",[]);class Pt{static hasString(e,i){for(var r=0;r<e.length;++r)if(e[r]==i)return r;return-1}static getEllipsis(e,i=4){let r=e;return r.length>i&&(r=r.slice(0,i)+"..."),r}static getURLName(e){var i;i=e.split("/");let r=i[i.length-1];return r=r.split(".")[0],r}static getFileFormat(e){var i=e.lastIndexOf(".");i++;var r=e.length;e.indexOf("?",i)!==-1&&(r=e.indexOf("?",i));var s=e.substr(i,r-i);return s=s.toLowerCase(),s}static readLineProperty(e,i){e.trim().split(" ").forEach((r,s)=>{let a=r.split("=");if(a.length>1){let o=a[0],l=a[1];Object.prototype.hasOwnProperty.call(i,o)&&(l.indexOf('"')==-1?i[o]=parseFloat(a[1]):i[o]=l.replace('"',"").replace('"',""))}})}static getPath(e){var i=e.lastIndexOf("/");return i++,e.substring(0,i)}static normalizePath(e){var i=e.replaceAll("//","/");return i=i.replaceAll("\\","/"),i}static getStringList(e,i=";"){return e.split(i)}static formatTime(e){let i=e/1e3/60,r=Math.floor(i),s=Math.floor(i-r);return[r.toString(),s.toString()]}static trim(e){return e.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(e){return!e||typeof e>"u"||e==null||typeof e=="string"&&this.trim(e)===""||e==="null"}static strCut(e,i){if(e.length*2<=i)return e;for(var r=0,s="",a=0;a<e.length;a++)if(s=s+e.charAt(a),e.charCodeAt(a)>128){if(r=r+2,r>=i)return s.substring(0,s.length-1)+"..."}else if(r=r+1,r>=i)return s.substring(0,s.length-2)+"...";return s}static toQueryPair(e,i,r=!1){return e+"="+(r?encodeURIComponent(i):i)}static stringFormat(e,...i){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let s=new RegExp("({"+r+"})","g");e=e.replace(s,arguments[1][r])}else for(let r=0;r<i.length;r++){if(i[r]==null)return e;{let s=new RegExp("({["+r+"]})","g");e=e.replace(s,i[r])}}return e}static parseJson2String(e,i){let r=null,s="",a=0,o="    ";return i=i||{},i.newlineAfterColonIfBeforeBraceOrBracket=i.newlineAfterColonIfBeforeBraceOrBracket===!0,i.spaceAfterColon=i.spaceAfterColon!==!1,typeof e!="string"||(e=JSON.parse(e)),e=JSON.stringify(e),r=/([\{\}])/g,e=e.replace(r,`\r
$1\r
`),r=/([\[\]])/g,e=e.replace(r,`\r
$1\r
`),r=/(\,)/g,e=e.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,e=e.replace(r,`\r
`),r=/\r\n\,/g,e=e.replace(r,","),i.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,e=e.replace(r,":{"),r=/\:\r\n\[/g,e=e.replace(r,":[")),i.spaceAfterColon&&(r=/\:/g,e=e.replace(r,":")),e.split(`\r
`).forEach(function(l,h){let u=0,c=0,d="";for(l.match(/\{$/)||l.match(/\[$/)?c=1:l.match(/\}/)||l.match(/\]/)?a!==0&&(a-=1):c=0,u=0;u<a;u++)d+=o;s+=d+l+`\r
`,a+=c}),s}static compareVersion(e,i){e=e.split("."),i=i.split(".");let r=Math.max(e.length,i.length);for(;e.length<r;)e.push("0");for(;i.length<r;)i.push("0");for(let s=0;s<r;s++){let a=parseInt(e[s]),o=parseInt(i[s]);if(a>o)return 1;if(a<o)return-1}return 0}static buildRandomCode(){let e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",i=e.length,r="";for(let s=0;s<26;s++){let a=Math.floor(Math.random()*i);r+=e.charAt(a)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var i=Math.random()*16|0,r=e=="x"?i:i&3|8;return r.toString(16)})}static stringToHash(e){let i=0;if(e.length==0)return i;for(let r=0;r<e.length;r++){const s=e.charCodeAt(r);i=(i<<5)-i+s,i=i&i}return i}static parseUrl(e,i){return i.match(/^(blob|http|https):/)?i:e+i}}n(Pt,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class Mr extends Lt{constructor(e=!0){super(),n(this,"_source"),n(this,"premultiplyAlpha","none"),n(this,"imageData"),this.useMipmap=e,this.lodMinClamp=0,this.lodMaxClamp=4}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const i=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.generate(i)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,i){if(this.name=Pt.getURLName(e),e.indexOf(";base64")!=-1){const r=document.createElement("img");let s=e.indexOf("data:image"),a=e.substring(s,e.length);r.src=a,await r.decode(),r.width=Math.max(r.width,32),r.height=Math.max(r.height,32);const o=await createImageBitmap(r,{resizeWidth:r.width,resizeHeight:r.height,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.format=le.rgba8unorm,this.generate(o)}else return new Promise((r,s)=>{fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},i==null?void 0:i.headers)}).then(a=>{ks.read(e,a,i).then(o=>{let l=new Blob([o],{type:"image/jpeg"});o=null,this.loadFromBlob(l).then(()=>{r(!0)})})})});return!0}async loadFromBlob(e){this.imageData=e;let i=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});if(i.width<32||i.height<32){let r=Math.max(i.width,32),s=Math.max(i.height,32);i=await createImageBitmap(i,{resizeWidth:r,resizeHeight:s,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"})}return this.format=le.rgba8unorm,this.generate(i),!0}}class ks{constructor(){n(this,"baseUrl",""),n(this,"initUrl"),n(this,"_progress",0)}async loadBinData(e,i){return this.baseUrl=Pt.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:i==null?void 0:i.headers}).then(async a=>{if(a.ok){let o=await ks.read(e,a,i),l=o.buffer;o=null,r(l)}else throw Error("request rejected with status "+a.status)}).catch(a=>{i.onError&&i.onError(a),s(a)})})}async loadAsyncBitmapTexture(e,i){this.baseUrl=Pt.getPath(e),this.initUrl=e;let r=new Mr;return r.url=e,r.name=Pt.getURLName(e),await r.load(e,i),I.res.addTexture(e,r),r}async loadJson(e,i){return this.baseUrl=Pt.getPath(e),this.initUrl=e,new Promise(async(r,s)=>{fetch(e,{headers:i==null?void 0:i.headers}).then(async a=>{if(a.ok){let o=await ks.read(e,a,i);const l=new TextDecoder("utf-8").decode(o);o=null,r(JSON.parse(l))}else throw Error("request rejected with status"+a.status)}).catch(a=>{i.onError&&i.onError(a),s(a)})})}async loadTxt(e,i){return this.baseUrl=Pt.getPath(e),new Promise(async(r,s)=>{fetch(e).then(async a=>{if(a.ok){let o=await ks.read(e,a,i);const l=new TextDecoder("utf-8").decode(o);o=null,r({data:l})}else throw Error("request rejected with status"+a.status)}).catch(a=>{i.onError&&i.onError(a),s(a)})})}static async read(e,i,r){const s=i.body.getReader(),a=+i.headers.get("Content-Length");let o=0,l=[],h=[];for(;;){const{done:d,value:f}=await s.read();if(d){a>0&&r&&r.onComplete&&r.onComplete.call(this,e);break}l.push(f),o+=f.length,a>0?r&&r.onProgress&&r.onProgress.call(this,o,a,e):h.push(f.length)}if(h.length>0)for(let d=0;d<l.length;d++)console.log(h[d]),r&&r.onProgress&&r.onProgress.call(this,h[d],o,e),h[d]==o&&r&&r.onComplete&&r.onComplete.call(this,e);let u=new Uint8Array(o),c=0;for(let d of l)u.set(d,c),c+=d.length;return u}}var xt=(t=>(t[t.TEXT=0]="TEXT",t[t.BIN=1]="BIN",t[t.JSON=2]="JSON",t))(xt||{});class Ft extends ks{async load(e,i,r,s){switch(i.format){case xt.BIN:return new Promise(async(a,o)=>{this.loadBinData(e,r).then(async l=>{let h=new i;if(h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,await h.parseBuffer(l),h.verification())a(h);else throw new Error("parser error")}).catch(l=>{o(l)})});case xt.JSON:return new Promise((a,o)=>{this.loadJson(e,r).then(async l=>{let h=new i;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,await h.parseJson(l),a(h)}).catch(l=>{o(l)})});case xt.TEXT:return new Promise((a,o)=>{this.loadTxt(e,r).then(async l=>{let h=new i;h.userData=s,h.baseUrl=this.baseUrl,h.initUrl=e,h.loaderFunctions=r,l.data?(await h.parseString(l.data),a(h)):o("text load is empty!")}).catch(l=>{o(l)})})}}}class Vt{constructor(){n(this,"baseUrl"),n(this,"initUrl"),n(this,"loaderFunctions"),n(this,"userData"),n(this,"data")}parseString(e){}parseJson(e){}parseBuffer(e){}parseTexture(e){throw this.parserError("Method not implemented.",-1)}parse(e){}verification(e){throw this.parserError("Method not implemented.",-1)}parserError(e,i){console.error(`error id:${i} ${e}`)}}n(Vt,"format",xt.BIN);class Nl{constructor(){n(this,"asset"),n(this,"accessors"),n(this,"buffers"),n(this,"bufferViews"),n(this,"materials"),n(this,"meshes"),n(this,"nodes"),n(this,"scene",0),n(this,"scenes"),n(this,"textures"),n(this,"cameras"),n(this,"skins"),n(this,"resources"),n(this,"images"),n(this,"samplers"),n(this,"animations"),n(this,"extensions")}}const sy=5120,ay=5121,ny=5122,oy=5123,ly=5124,hy=5125,uy=5126,cy=32819,dy=32820,fy=33635,gy=5131,py=33640,my=35899,Ay=35902,_y=36269,vy=34042,kf={};{const t=kf;t[sy]=Int8Array,t[ay]=Uint8Array,t[ny]=Int16Array,t[oy]=Uint16Array,t[ly]=Int32Array,t[hy]=Uint32Array,t[uy]=Float32Array,t[cy]=Uint16Array,t[dy]=Uint16Array,t[fy]=Uint16Array,t[gy]=Uint16Array,t[py]=Uint32Array,t[my]=Uint32Array,t[Ay]=Uint32Array,t[_y]=Uint32Array,t[vy]=Uint32Array}function Cc(t){const e=kf[t];if(!e)throw new Error("unkonw gl type");return e}class ao{static async apply(e,i){if(!i.extensions)return;const r=i.extensions.KHR_draco_mesh_compression;if(!r)return;let s=this._workers.get(e.gltf);s||(s=new Worker(await this.initDecoder()),this._workers.set(e.gltf,s)),s.postMessage({type:"init",decoderConfig:{}});let a=e.parseBufferView(r.bufferView);if(!a.result){let o=await new Promise((l,h)=>{s.onmessage=u=>{const c=u.data;c.type=="decode"?l(c.result):c.type=="error"&&h(c.error)},s.postMessage({type:"decoder",buffer:a,attributes:r.attributes},[a])});a.result=o}return a.result}static unload(e){let i=this._workers.get(e);i&&(i.terminate(),this._workers.delete(e))}static async initDecoder(){if(!this._workerCode){let e=await new Ft().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const i=new Blob([e.data,"",`(${xy})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(i)}return this._workerCode}}n(ao,"_workerCode"),n(ao,"_workers",new Map);function xy(){let t,e;onmessage=i=>{const r=i.data;switch(r.type){case"init":t=r.decoderConfig,e=new Promise((o,l)=>{t.onModuleLoaded=h=>{o({draco:h})},DracoDecoderModule(t)});break;case"decoder":const s=r.buffer,a=r.attributes;e.then(o=>{const l=o.draco;let h=new l.Decoder,u=new l.DecoderBuffer;u.Init(new Int8Array(s),s.byteLength);let c,d;try{const f=h.GetEncodedGeometryType(u);f==l.TRIANGULAR_MESH?(d=new l.Mesh,c=h.DecodeBufferToMesh(u,d)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+f)),c.ok()||self.postMessage(new Error("DracoDecode:"+c.error_msg()));let g={};for(const m in a){let A=h.GetAttributeByUniqueId(d,a[m]);const _=A.num_components(),x=d.num_points()*_,b=x*Float32Array.BYTES_PER_ELEMENT,R=l.DT_FLOAT32,E=l._malloc(b);h.GetAttributeDataArrayForAllPoints(d,A,R,b,E);const M=new Float32Array(l.HEAPF32.buffer,E,x).slice();l._free(E),g[m]={data:M,numComponents:_,normalize:!1}}{const m=d.num_faces()*3,A=m*4,_=l._malloc(A);h.GetTrianglesUInt32Array(d,A,_);const x=new Uint32Array(l.HEAPF32.buffer,_,m).slice();l._free(_),g.indices={data:x,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:g})}catch(f){self.postMessage({type:"error",error:f.message})}finally{l.destroy(d),l.destroy(h),l.destroy(u)}});break}}}class yy{constructor(e){n(this,"gltf"),this.gltf=e}parse(e){const i=this.gltf.cameras[e];if(!i)return this.errorMiss("camera",e);if(i.isParsed)return i.dcamera;i.isParsed=!0,i.dcamera=!1;const{name:r,type:s,perspective:a,orthographic:o}=i;if(s==="perspective"&&a){const{aspectRatio:l,yfov:h,zfar:u,znear:c}=a;i.dcamera=Object.assign({},{name:r,type:s,yfov:h,znear:c,aspectRatio:l,zfar:u})}else if(s==="orthographic"&&o){const{xmag:l,ymag:h,zfar:u,znear:c}=o;i.dcamera=Object.assign({},{name:r,type:s,xmag:l,ymag:h,zfar:u,znear:c})}return i.dcamera}errorMiss(e,i){throw new Error(e+i)}}const Qf=class extends Vt{constructor(){super(...arguments),n(this,"_gltf")}async parseJson(t){this._gltf=new Nl,this._gltf={...this._gltf,...t},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let e=new kl,i=await e.parse(this.initUrl,this._gltf,this._gltf.scene);return e.destory(),e=null,i?(this.data=i.rootNode,i.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Qf._counter++}`}}static getModelNameCounter(){let t=0;return function(){return`GLTF_NO_NAME_MESH_${t++}`}}static getTexCoordDefine(t){return`UV_NUM ${t}`}static getVertexColorDefine(t){return`HAS_VERTEXCOLOR ${t}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(t){return`MORPH_TARGET_NUM ${t}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(t){return`JOINTS_NUM ${t}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}async load_gltf_bin(){var t;if(this._gltf.buffers&&this._gltf.buffers.length>0){let e=[];for(let i=0;i<this._gltf.buffers.length;i++){const r=this._gltf.buffers[i];if(r.uri.substring(0,5)!=="data:"){let s=Pt.parseUrl(this.baseUrl,r.uri);(t=this.loaderFunctions)!=null&&t.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new Ft().loadBinData(s,this.loaderFunctions).then(o=>{this._gltf.resources[r.uri]=o});e.push(a)}}await Promise.all(e)}}async load_gltf_textures(){var t;if(this._gltf,this._gltf.images){let e=[];for(let i=0;i<this._gltf.images.length;i++){const r=this._gltf.images[i];if(r.uri){let s=Pt.parseUrl(this.baseUrl,r.uri);(t=this.loaderFunctions)!=null&&t.onUrl&&(s=await this.loaderFunctions.onUrl(s));let a=new Ft().loadAsyncBitmapTexture(s,this.loaderFunctions).then(o=>{o.name=Pt.getURLName(r.uri),this._gltf.resources[o.name]=o});e.push(a)}}await Promise.all(e)}}};let It=Qf;n(It,"format",xt.JSON),n(It,"_counter",0),n(It,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});class Cy{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){const i=this.gltf.meshes[e];if(!i)return this.errorMiss("mesh",e);if(i.isParsed)return i.dprimitives;const r=i.primitives,s=i.extras,a=[];for(let o=0;o<r.length;o++){const l=r[o],{attributes:h,indices:u,material:c,mode:d,name:f,targets:g,morphTargetsRelative:m,extensions:A}=l;let _=i.name;for(let V in h)_+=V;_+=`indices:${u}`,_+=`material:${c}`;const x={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:s?s.targetNames:null};let b=!1,R=0,E=!1,M;A&&A.KHR_draco_mesh_compression&&(M=await ao.apply(this.subParser,l));for(const V in h){const k=M?M[V]:this.parseAccessor(h[V]);if(k){let O;switch(V){case"POSITION":O=z.position;break;case"NORMAL":O=z.normal,b=!0;break;case"TEXCOORD_0":O=z.uv,R++;break;case"JOINTS_0":O=z.joints0;break;case"JOINTS_1":O=z.joints1,E=!0;break;case"WEIGHTS_0":O=z.weights0;break;case"WEIGHTS_1":O=z.weights1;break;default:O=V}x.attribArrays[O]=k}}if(b&&x.defines.push(It.getHasNormalDefine()),R&&x.defines.push(It.getTexCoordDefine(R)),E&&x.defines.push(It.getJointVec8Define()),u!==void 0){const V=M?M.indices:this.parseAccessor(u);V&&(x.attribArrays.indices=V)}const G=await this.parseMaterial(c);if(G&&(x.material=G,x.defines=x.defines.concat(G.defines)),x.drawMode=d===void 0?4:d,x.meshName=()=>_,x.modelName=i.name||It.getModelNameCounter(),g){x.defines.push(It.getMorphTargetsDefine(g.length)),x.morphTargetsRelative=!0;let V=!1,k=!1,O=!1;for(let ce=0;ce<g.length;ce++){const we=g[ce];Object.keys(we).forEach(Ce=>{const be=this.parseAccessor(we[Ce]);if(be){let De;switch(Ce){case"POSITION":De=Fe.MORPH_POSITION_PREFIX+ce,V=!0;break;case"NORMAL":De=Fe.MORPH_NORMAL_PREFIX+ce,k=!0;break;case"TANGENT":De=Fe.MORPH_TANGENT_PREFIX+ce,O=!0;break;default:De=!1}De?x.attribArrays[De]=be:console.error(`glTF has unsupported morph target attribute ${Ce}`)}})}V&&x.defines.push(It.getMorphtargetPositionDefine()),k&&x.defines.push(It.getMorphtargetNormalDefine()),O&&x.defines.push(It.getMorphtargetTangentDefine()),x.weights=i.weights||new Array(g.length).fill(0)}a.push(x)}return i.dprimitives=a,i.isParsed=!0,i.dprimitives}parseAccessor(e){return this.subParser.parseAccessor(e)}parseMaterial(e){return this.subParser.parseMaterial(e)}errorMiss(e,i){throw new Error(e+i)}}class by{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}async parse(e){let i;if(e==null?i=It.defaultMaterial:i=this.gltf.materials[e],!i)return this.errorMiss("material",e);if(i.isParsed)return i.dmaterial;let{name:r,pbrMetallicRoughness:s,normalTexture:a,occlusionTexture:o,emissiveTexture:l,emissiveFactor:h,alphaMode:u,alphaCutoff:c,doubleSided:d,extensions:f}=i;const g={name:r,defines:[],doubleSided:!!d,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,transformUV1:null,transformUV2:null,extensions:null};if(s){const{baseColorFactor:m,metallicFactor:A,roughnessFactor:_,baseColorTexture:x,metallicRoughnessTexture:b}=s;if(Object.assign(g,{baseColorFactor:m||[1,1,1,1],metallicFactor:A===void 0?1:A,roughnessFactor:_===void 0?.5:_}),x){let R=x.extensions;if(R){let M=R.KHR_texture_transform;M&&(g.transformUV1=new oe(M.offset?M.offset[0]:0,M.offset?M.offset[1]:0,M.scale?M.scale[0]:1,M.scale?M.scale[1]:1))}const E=await this.parseTexture(x.index);E?g.baseColorTexture=E:g.baseColorTexture=I.res.redTexture}if(b){const R=await this.parseTexture(b.index);R?g.metallicRoughnessTexture=R:g.metallicRoughnessTexture=I.res.blackTexture}}else Object.assign(g,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(g.baseColorFactor&&g.baseColorFactor[3]<1&&(u=u==="MASK"?"MASK":"BLEND"),u&&u!=="OPAQUE"&&(u==="MASK"&&(g.defines.push(It.getAlphaMaskDefine()),g.alphaCutoff=c===void 0?.5:c),u==="BLEND"&&(g.defines.push(It.getAlphaBlendDefine()),g.enableBlend=!0)),a){const m=await this.parseTexture(a.index);m?g.normalTexture=m:g.normalTexture=I.res.normalTexture}if(o){const m=await this.parseTexture(o.index);m&&(g.occlusionTexture=m)}if(h&&(g.emissiveFactor=h),l){const m=await this.parseTexture(l.index);m?g.emissiveTexture=m:g.emissiveTexture=I.res.blackTexture}return f&&(g.extensions=f),i.isParsed=!0,i.dmaterial=g,g}async parseTexture(e){return this.subParser.parseTexture(e)}errorMiss(e,i){throw new Error(e+i)}}class Iy{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){const i=this.gltf.skins[e];if(!i)return this.errorMiss("skin",e);if(i.isParsed)return i.dskin;const{name:r,joints:s,inverseBindMatrices:a,skeleton:o}=i;if(!s)return this.errorMiss("skin.joints",e);i.isParsed=!0,i.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:s,defines:[It.getJointsNumDefine(s.length)]};if(o)l.skeleton=o;else{var h=-1;for(let u=0;u<this.gltf.nodes.length;u++)if(this.gltf.nodes[u].name=="root"){h=u;break}if(h==-1){let u=this.gltf.scenes[this.gltf.scene];h=u.nodes[u.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=Fe.IDENTITY_INVERSE_BIND_MATRICES,a!==void 0){const u=this.parseAccessor(a);if(u){const c=u.data,d=[];for(let f=0;f<c.length;f+=16)d.push(c.slice(f,f+16));l.inverseBindMatrices=d}else l=null}return i.dskin=l,i.dskin}parseAccessor(e){return this.subParser.parseAccessor(e)}errorMiss(e,i){throw new Error(e+i)}}class wy{constructor(e=""){n(this,"name",""),n(this,"index",0),n(this,"instanceID",""),n(this,"parent",null),n(this,"scale",new p),n(this,"rotation",new ye),n(this,"translation",new p),this.name=e}}class Sy{constructor(e=[]){n(this,"joints"),this.joints=e}get numJoint(){return this.joints.length}addJoint(e){e.index=this.joints.push(e)-1}getJointName(e){return this.joints[e].name}getJointParentIndex(e){let i=this.joints[e];return i.parent?i.parent.index:-1}getJointByName(e){for(let i of this.joints)if(i.name==e)return i;return null}}class bc{constructor(e,i=!1){n(this,"index"),n(this,"worldMatrix"),this.index=e,this.worldMatrix=new te(!i)}}class no{constructor(e,i=!1){n(this,"time"),n(this,"_skeleton"),n(this,"_jointsPose"),n(this,"mJointMatrixIndexTable"),this._skeleton=e,this._jointsPose=new Array(e.numJoint),this.mJointMatrixIndexTable=new Array(e.numJoint);for(let r=0;r<e.numJoint;r++){let s=new bc(r,i);this._jointsPose[r]=s,this.mJointMatrixIndexTable[r]=s.worldMatrix.index}}buildSkeletonPose(e){let i=new p,r=new ye,s=new p,a=new Array(this._skeleton.numJoint);this.time=e[11]>0?e[11]:e[24];for(let o=0;o<this._skeleton.numJoint;o++){let l=12*o*4,h=new Float32Array(e.buffer,e.byteOffset+l,12),u=new te;i.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),s.set(h[8],h[9],h[10]),Dl(r.getEulerAngles(),s,i,u),a[o]=u;let c=new bc(o);const d=this._skeleton.getJointParentIndex(o);if(d<0)c.worldMatrix.copyFrom(u);else{let f=this._jointsPose[d];Cv(f.worldMatrix,u,c.worldMatrix)}this._jointsPose[o]=c}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(e,i,r){if(e&&i)for(let s=0;s<this._jointsPose.length;s++){let a=e._jointsPose[s],o=i._jointsPose[s];this._jointsPose[s].worldMatrix.lerp(a.worldMatrix,o.worldMatrix,r)}else for(let s=0;s<this._jointsPose.length;s++){let a=e._jointsPose[s];this._jointsPose[s].worldMatrix.copyFrom(a.worldMatrix)}}copyFrom(e){for(let i=0;i<this._jointsPose.length;i++)this._jointsPose[i].worldMatrix.copyFrom(e._jointsPose[i].worldMatrix)}reset(){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.identity()}}class Ey extends Tt{constructor(e,i){super(),n(this,"skeletonAnimation"),this.type=e,this.time=i}}class Vh{constructor(e,i,r,s){if(n(this,"name",""),n(this,"_skeleton"),n(this,"_skeletonPoses"),n(this,"_animationClipData"),n(this,"_events"),this.name=e,this._skeleton=i,this._animationClipData=s,r>0&&s){this._skeletonPoses=new Array(r);let a=12*i.numJoint;for(let o=0;o<r;o++){let l=a*o*4,h=new Float32Array(s.buffer,l,a),u=new no(i);u.buildSkeletonPose(h),this._skeletonPoses[o]=u}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(e){return this._skeletonPoses[e]}getLerpSkeletonPose(e,i,r,s){let a=this.getSkeletonPose(e),o=this.getSkeletonPose(i);return s.lerp(a,o,r),s}createSubClip(e,i,r){var s=new Vh(e,this._skeleton,0,null);const a=Math.max(Math.floor(i/this.frameRate),0),o=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);s._skeletonPoses=this._skeletonPoses.slice(a,o);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,a*l,(o-a)*l),s}addEvent(e,i){this._events||(this._events=new Array),this._events.push(new Ey(e,i))}removeEvent(e){this._events&&(this._events=this._events.filter(i=>i.type!=e))}getEvents(){return this._events}}class Ic{constructor(e){n(this,"gltf"),n(this,"subParser"),this.gltf=e.gltf,this.subParser=e}parse(e){let i=new Sy;return this.buildSkeleton(i,void 0,e),i}parseSkeletonAnimation(e,i){let r=this.subParser.parseAccessor(i.samplers[0].input).data.length,s=12*e.numJoint,a=new Float32Array(s*r);for(var o=0;o<e.numJoint;o++)for(var l=0;l<r;l++){var h=s*l+12*o;a[h+0]=1,a[h+1]=1,a[h+2]=1,a[h+3]=1}for(let c of i.channels){let d=i.samplers[c.sampler];const f=this.subParser.parseAccessor(d.input),g=this.subParser.parseAccessor(d.output);let m=c.target.node,A=c.target.path,_=this.gltf.nodes[m];if(!_)continue;let x=e.getJointByName(_.name);if(x)switch(A){case"scale":for(var l=0;l<r;l++){var u=l*g.numComponents,h=s*l+12*x.index;a[h+0]=g.data[u+0],a[h+1]=g.data[u+1],a[h+2]=g.data[u+2],a[h+3]=1}break;case"rotation":for(var l=0;l<r;l++){var u=l*g.numComponents,h=s*l+12*x.index+4;a[h+0]=g.data[u+0],a[h+1]=g.data[u+1],a[h+2]=g.data[u+2],a[h+3]=g.data[u+3]}break;case"translation":for(var l=0;l<r;l++){var u=l*g.numComponents,h=s*l+12*x.index+8;a[h+0]=g.data[u+0],a[h+1]=g.data[u+1],a[h+2]=g.data[u+2],a[h+3]=f.data[l*f.numComponents]}break}}return new Vh(i.name,e,r,a)}buildSkeleton(e,i,r,s=0){let a=this.gltf.nodes[r];a.name||(a.name="Node_"+r);let o=new wy(a.name);if(o.parent=i,a.scale&&o.scale.set(a.scale[0],a.scale[1],a.scale[2]),a.rotation&&o.rotation.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),a.translation&&o.translation.set(a.translation[0],a.translation[1],a.translation[2]),e.addJoint(o),a.children)for(let l of a.children)this.buildSkeleton(e,o,l,s+1)}}class Ty{constructor(e){n(this,"loop",!0),n(this,"speed",1),n(this,"t",0),n(this,"time",0),n(this,"weight",0),n(this,"currFrame",0),n(this,"lastFrame",-1),n(this,"nextFrame",0),n(this,"clip"),n(this,"animation"),n(this,"_isEnd",!1),n(this,"_currSkeletonPose"),this.clip=e,this._currSkeletonPose=new no(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(e){this.time=(this.time+e*this.speed)%this.clip.totalTime;let i=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(i),this.t=i-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let a=this.speed<0?0:this.clip.numFrame;this.currFrame==a&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let o of r){var s=Math.floor(o.time/this.clip.frameRate);if(s=Math.min(s,this.clip.numFrame),s=Math.max(s,0),s==this.currFrame){o.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(o);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}var By=Object.defineProperty,Dy=Object.getOwnPropertyDescriptor,Ry=(t,e,i,r)=>{for(var s=r>1?void 0:r?Dy(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&By(e,i,s),s};let or=class extends Zt{constructor(){super(),n(this,"isPlaying",!0),n(this,"timeScale",1),n(this,"_skeleton"),n(this,"_clips",[]),n(this,"_clipStates",new Map),n(this,"_mixSkeletonPose"),n(this,"_mixTempSkeletonPose"),n(this,"_currentClipState"),n(this,"_bindList",[]),n(this,"_jointMatrixIndexTableBuffer"),n(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(t){this._skeleton=t,this._mixSkeletonPose=new no(this._skeleton,!0),this._mixTempSkeletonPose=new no(this._skeleton);const e=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new At(this._skeleton.numJoint*4,0,e)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(t){let e=new Array;for(let i=0;i<t.length;i++){const r=t[i];let s=this._skeleton.getJointByName(r);e[i]=s?s.index:-1}return e}addAnimationClip(t){if(!this._clipStates.has(t.name)){this._clips.push(t);let e=new Ty(t);e.animation=this,this._clipStates.set(t.name,e),this._currentClipState||this.setCurrentClipState(e)}}getAnimationClip(t){var e=this.getAnimationClipState(t);return e?e.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(t){return this._clipStates.has(t)?this._clipStates.get(t):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(t,e=1,i=!1){if(this._currentClipState&&this._currentClipState.name==t)return i&&this._currentClipState.reset(),!1;let r=this.getAnimationClipState(t);return r?(r.speed=e,r.reset(),this._clipStates.forEach((s,a)=>{s.weight=0}),this.setCurrentClipState(r),!0):!1}crossFade(t,e){if(e<.01){this.play(t);return}if(this._currentClipState.name==t)return;let i=this.getAnimationClipState(t);i&&(i.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(i,this._currentClipState,e)):this._crossFadeState=new My(i,this._currentClipState,e),this._currentClipState=i)}setAnimIsLoop(t,e){this._clipStates.has(t)&&(this._clipStates.get(t).loop=e)}addJointBind(t,e){this._bindList.push({jointName:t,obj:e})}removeJointBind(t){for(let e=0;e<this._bindList.length;e++)if(this._bindList[e].obj==t){this._bindList.splice(e,1);break}}onUpdate(){if(!this.isPlaying)return;let t=He.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(t);var e=0,i=[];if(this._clipStates.forEach((s,a)=>{s.weight>0&&(s.update(t),e+=s.weight,i.push(s))}),i.length>0){this._mixSkeletonPose.copyFrom(i[0].currSkeletonPose);for(var r=1;r<i.length;++r){const s=i[r];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,s.currSkeletonPose,s.weight/e),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(t){let e=t.addComponent(or);e.skeleton=this.skeleton;for(var i=0;i<this._clips.length;++i)e.addAnimationClip(this._clips[i])}setCurrentClipState(t){this._currentClipState!=t&&(this._currentClipState=t,this._currentClipState.weight=1)}};or=Ry([Ci(or,"SkeletonAnimationComponent")],or);class My{constructor(e,i,r){n(this,"inClip"),n(this,"outClip"),n(this,"currentTime"),n(this,"crossFadeTime"),this.reset(e,i,r)}reset(e,i,r){this.inClip=e,this.outClip=i,this.currentTime=0,this.crossFadeTime=r}update(e){!this.inClip||!this.outClip||(this.currentTime+=e,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class Fl{static add(e){this.list.indexOf(e)==-1&&this.list.push(e)}static remove(e){let i=this.list.indexOf(e);i!=-1&&this.list.splice(i,1)}}n(Fl,"list",[]);class Mo extends Zt{constructor(){super(),n(this,"name"),n(this,"size",1),n(this,"lightData"),n(this,"dirFix",1),n(this,"bindOnChange"),n(this,"needUpdateShadow",!0),n(this,"realTimeShadow",!0),n(this,"_castGI",!1),n(this,"_castShadow",!1),n(this,"_iesProfiles")}init(){this.transform.object3D.bound=new _t(new p,new p),this.lightData=new $n,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new p(this.size,this.size,this.size)),this._castGI&&(ie.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,Mt.addShadowLight(this)):Mt.removeShadowLight(this)}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onScaleChange=()=>this.onScaleChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange(),this.onScaleChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition)}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),ie.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),ie.instance.removeLight(this.transform.scene3D,this),Mt.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Fs.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get color(){return this.lightData.lightColor}set color(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?Fl.add(this):Fl.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,ie.instance.removeLight(this.transform.scene3D,this),Mt.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(pt.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(pt.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}var Py=Object.defineProperty,Uy=Object.getOwnPropertyDescriptor,Ly=(t,e,i,r)=>{for(var s=r>1?void 0:r?Uy(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Py(e,i,s),s};let Qa=class extends Mo{constructor(){super(),n(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+bi()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=dt.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(t){this.lightData.range=t,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(t){this.lightData.quadratic=t,this.onChange()}debug(){}};Qa=Ly([Ci(Qa,"DirectLight")],Qa);var Oy=Object.defineProperty,Ny=Object.getOwnPropertyDescriptor,Fy=(t,e,i,r)=>{for(var s=r>1?void 0:r?Ny(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Oy(e,i,s),s};let On=class extends Mo{constructor(){super()}init(){super.init(),this.lightData.lightType=dt.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+bi())}get range(){return this.lightData.range}set range(t){this.lightData.range=t,this.onChange()}get at(){return this.lightData.linear}set at(t){this.lightData.linear=t,this.onChange()}get radius(){return this.lightData.radius}set radius(t){this.lightData.radius=t,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(t){this.lightData.quadratic=t,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(t){}debug(){}debugDraw(t){}};On=Fy([Ci(On,"PointLight")],On);var ky=Object.defineProperty,Qy=Object.getOwnPropertyDescriptor,zy=(t,e,i,r)=>{for(var s=r>1?void 0:r?Qy(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&ky(e,i,s),s};let Nn=class extends Mo{constructor(){super()}init(){super.init(),this.lightData.lightType=dt.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+bi())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(t){this.lightData.innerAngle=ni(t,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*nn*2}set outerAngle(t){this.lightData.outerAngle=ni(t,1,179)*We*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(t){this.lightData.radius=t,this.onChange()}get range(){return this.lightData.range}set range(t){this.lightData.range=t,this.onChange()}get at(){return this.lightData.linear}set at(t){this.lightData.linear=t,this.onChange()}start(){super.start(),this.lightData.lightType=dt.SpotLight}onUpdate(){}onGraphic(t){}debug(){}debugDraw(t){}};Nn=zy([Ci(Nn,"SpotLight")],Nn);var Gy=Object.defineProperty,Vy=Object.getOwnPropertyDescriptor,Hy=(t,e,i,r)=>{for(var s=r>1?void 0:r?Vy(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Gy(e,i,s),s};let za=class extends Pe{constructor(){super(),n(this,"skinJointsName"),n(this,"mInverseBindMatrixData"),n(this,"mInverseBindMatrixBuffer"),n(this,"mSkeletonAnimation"),n(this,"mJointIndexTableBuffer"),this.addRendererMask(vt.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(or),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(or);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(or),e.parent&&(e=e.parent.object3D)}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new At(e.length*4,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let i=0;i<t.length;i++){let r=i*16,s=t[i];e.set(s,r)}this.mInverseBindMatrixBuffer=new At(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(za);e.geometry=this.geometry,e.material=this.material.clone(),e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,i,r){for(let s=0;s<this.materials.length;s++){let a=this.materials[s].getPass(e);if(a)for(let o=0;o<a.length;o++){const l=a[o];!l.pipeline&&this.mSkeletonAnimation&&(l.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),l.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),l.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,i,r)}};za=Hy([Ci(za,"SkinnedMeshRenderer")],za);class Yy{static apply(e,i,r){let s=i.extensions;if(s&&s.KHR_materials_clearcoat){r.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0);let a=s.KHR_materials_clearcoat;"clearcoatFactor"in a&&(i.clearcoatFactor=a.clearcoatFactor,r.clearcoatFactor=i.clearcoatFactor),"clearcoatRoughnessFactor"in a&&(i.clearcoatRoughnessFactor=a.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=i.clearcoatRoughnessFactor)}}}class Xy{static apply(e,i,r){let s=i.extensions;s&&s.KHR_materials_emissive_strength?(r.emissiveIntensity=s.KHR_materials_emissive_strength.emissiveStrength*.5,r.emissiveMap==I.res.blackTexture&&(r.emissiveMap=I.res.whiteTexture)):r.emissiveIntensity=1}}class Ky{static apply(e,i,r){let s=i.extensions;s&&s.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class Wy{constructor(e){n(this,"gltf"),n(this,"subParser"),n(this,"_testCount",8),n(this,"_hasCastShadow",!1),this.gltf=e.gltf,this.subParser=e}async convertNodeToObject3D(e,i){const r=new me;if(r.name=e.name,r[Fe.GLTF_NODE_INDEX_PROPERTY]=e.nodeId,e.nodeObj=r,e.matrix&&(e.translation=[0,0,0],e.rotation=[0,0,0,1],e.scale=[1,1,1]),e.translation&&(r.transform.x=e.translation[0],r.transform.y=e.translation[1],r.transform.z=e.translation[2]),e.rotation){let s=new ye;s.setFromArray(e.rotation),r.transform.localRotQuat=s}if(e.scale&&(r.transform.scaleX=e.scale[0],r.transform.scaleY=e.scale[1],r.transform.scaleZ=e.scale[2]),i.addChild(r),e.light&&this.convertLight(e,r),e.primitives&&this.convertprimitives(e,r),e.skeleton){let s=r.addComponent(or);if(s){s.skeleton=this.subParser.parseSkeleton(e.skeleton.skeleton);for(let a=0;a<this.gltf.animations.length;a++){let o=this.gltf.animations[a];o.name||(o.name=a.toString());let l=this.subParser.parseSkeletonAnimation(s.skeleton,o);s.addAnimationClip(l)}}}return r}convertLight(e,i){switch(e.light.type){case"directional":let r=i.addComponent(Qa);i.name=e.light.name,r.intensity=e.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=e.light.color?new Y(e.light.color[0],e.light.color[1],e.light.color[2]):new Y(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let a=i.addComponent(On);a.name=e.light.name,a.intensity=e.light.intensity?e.light.intensity*8*2:1,a.radius=8,a.at=2,a.range=e.light.range?e.light.range:8,a.lightColor=e.light.color?new Y(e.light.color[0],e.light.color[1],e.light.color[2]):new Y(1,1,1,1)}this._testCount--;break;case"spot":let s=i.addComponent(Nn);s.name=e.light.name,s.intensity=e.light.intensity*5,s.radius=1,s.dirFix=-1,s.at=2,s.range=e.light.range?e.light.range:8,s.outerAngle=e.light.spot.outerConeAngle*nn,s.lightColor=e.light.color?new Y(e.light.color[0],e.light.color[1],e.light.color[2]):new Y(1,1,1,1);break}}convertprimitives(e,i){for(let r=0;r<e.primitives.length;r++){const s=e.primitives[r];s.modelName;let a=s.material;a.name==null&&(a.name=bi());let o,l=`matkey_${a.name}`;if(a&&this.gltf.resources[l])o=this.gltf.resources[l];else{let f=o=new lr;if(this.gltf.resources[l]=f,f.name=a.name,s.material){const{baseColorTexture:g,baseColorFactor:m,metallicFactor:A,roughnessFactor:_,doubleSided:x,metallicRoughnessTexture:b,normalTexture:R,occlusionTexture:E,emissiveTexture:M,emissiveFactor:G,enableBlend:V,alphaCutoff:k}=s.material;let O=f=this.applyMaterialExtensions(s.material,f);"enableBlend"in s.material&&(s.material.enableBlend?O.blendMode=Te.SOFT_ADD:O.blendMode=Te.NONE),"alphaCutoff"in s.material&&k>0&&k<1&&(O.setUniformFloat("alphaCutoff",k),O.blendMode=Te.NORMAL,O.transparent=!0),s.material.transformUV1&&O.setUniformVector4("uvTransform_1",s.material.transformUV1),s.material.transformUV2&&O.setUniformVector4("uvTransform_2",s.material.transformUV2),O.setUniformColor("baseColor",new Y(m[0],m[1],m[2],m[3])),O.setUniformFloat("roughness",_),O.setUniformFloat("metallic",A),O.setUniformFloat("ao",1),O.doubleSide=x,g&&O.setTexture("baseMap",g),R&&O.setTexture("normalMap",R),b&&O.setTexture("maskMap",b),E&&b!=E&&O.setTexture("aoMap",E),M&&O.setTexture("emissiveMap",M),G&&(G[0]>0||G[1]>0||G[2]>0)&&(O.shader.getTexture("emissiveMap")||O.shader.setTexture("emissiveMap",I.res.whiteTexture),O.setUniformColor("emissiveColor",new Y(G[0],G[1],G[2],G[3])))}}const{attribArrays:h,modelName:u,drawMode:c}=s;let d;if(!h.indices.data){let f=[],g=h.position.data.length/3/3;for(let m=0;m<g;m++){let A=m*3;f.push(A+2),f.push(A+0),f.push(A+1)}h.indices={data:new Uint8Array(f),normalize:!1,numComponents:1}}if(!h.normal){let f=[],g=h.position.data.length/3;for(let m=0;m<g;m++)f.push(0),f.push(0),f.push(0);h.normal={data:new Float32Array(f),normalize:!1,numComponents:3}}if(h.indices.data&&h.indices.data.length>3){let f=s.meshName();this.gltf.resources[f]?d=this.gltf.resources[f]:(d||(d=this.createGeometryBase(f,h,s)),this.gltf.resources[f]=d);const g=new me;if(g.name=u+r,this.gltf.animations&&h[z.joints0]!=null){d||(d=this.createGeometryBase(u,h,s)),this.gltf.resources[f]=d;let m=this.gltf.nodes[e.skin.skeleton];if(m.dnode&&m.dnode.nodeObj){let _=m.dnode.nodeObj.addComponent(or);if(_){_.skeleton=this.subParser.parseSkeleton(e.skin.skeleton);for(let x=0;x<this.gltf.animations.length;x++){let b=this.gltf.animations[x];b.name||(b.name=x.toString());let R=this.subParser.parseSkeletonAnimation(_.skeleton,b);_.addAnimationClip(R)}}}else m.dnode.skeleton=e.skin;let A=g.addComponent(za);A.castShadow=!0,A.castGI=!0,A.geometry=d,A.material=o,A.skinJointsName=this.parseSkinJoints(e.skin),A.skinInverseBindMatrices=e.skin.inverseBindMatrices}else{d||(d=this.createGeometryBase(u,h,s)),this.gltf.resources[f]=d,d.hasAttribute(z.joints0)&&d.vertexAttributeMap.delete(z.joints0);let m=g.addComponent(Pe);m.castShadow=!0,m.castGI=!0,m.geometry=d,m.material=o}e.skin&&e.skin.defines,i.addChild(g)}}}createGeometryBase(e,i,r){let s=new wt;s.name=e,s.morphTargetsRelative=r.morphTargetsRelative;let a=r.targetNames;if(a&&a.length>0){let l=s.morphTargetDictionary={};for(let h=0;h<a.length;h++)l[a[h]]=h}if(s.morphTargetDictionary){let l=i.position.data.length/3,h=new Float32Array(l);for(let u=0;u<l;u++)h[u]=u;i.vIndex={data:h,normalize:!1,numComponents:1}}for(const l in i){let h=i[l];s.setAttribute(l,h.data)}let o=s.getAttribute(z.indices);return s.addSubGeometry({indexStart:0,indexCount:o.data.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),s}applyMaterialExtensions(e,i){return Yy.apply(this.gltf,e,i),Ky.apply(this.gltf,e,i),Xy.apply(this.gltf,e,i),i}parseSkinJoints(e){let i=[];for(let r of e.joints){let s=this.gltf.nodes[r];i.push(s.name)}return i}}class kl{constructor(){n(this,"currentSceneName"),n(this,"gltf"),n(this,"initUrl"),n(this,"_generator"),n(this,"_version"),n(this,"_BASE64_MARKER",";base64,"),n(this,"_cameraParser",null),n(this,"_meshParser",null),n(this,"_materialParser",null),n(this,"_skinParser",null),n(this,"_skeletonParser",null),n(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(e,i,r){this.gltf=i,this.initUrl=e;const{version:s,generator:a}=this.gltf.asset;if(this._generator=a,s!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const o={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(o)}destory(){ao.unload(this.gltf),this.gltf=null}async parseScene(e){const i=e||this.gltf.scene||0,r=this.gltf.scenes[i];if(typeof r>"u")return this.errorMiss("scene",i);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const s=[],a=r.nodes;for(let o=0;o<a.length;o++){const l=await this.parseNode(a[o]);l&&s.push(l)}return s}async parseNode(e){const i=this.gltf.nodes[e];if(!i)return this.errorMiss("node",e);if(i.isParsed)return i.dnode;const{name:r,matrix:s,translation:a,rotation:o,scale:l}=i,h={name:r,matrix:s,translation:a,rotation:o,scale:l,nodeId:e,camera:null,primitives:null,skin:null,children:null,light:null};if(i.camera!==void 0&&(h.camera=this.parseCamera(i.camera)),i.mesh!==void 0&&(h.primitives=await this.parseMesh(i.mesh)),i.extensions!==void 0&&this.applyNodeExtensions(i,h),i.skin!==void 0){const u=this.parseSkin(i.skin);u&&(h.skin=u)}if(h.children=[],i.children)for(let u=0;u<i.children.length;u++)h.children.push(await this.parseNode(i.children[u]));return i.dnode=h,i.isParsed=!0,i.dnode}errorMiss(e,i){throw new Error(e+i)}parseCamera(e){return this._cameraParser||(this._cameraParser=new yy(this.gltf)),this._cameraParser.parse(e)}async parseMesh(e){return this._meshParser||(this._meshParser=new Cy(this)),this._meshParser.parse(e)}async parseTexture(e){let i=this.gltf.textures[e];if(i&&!i.dtexture){if(i&&i.source!=null){let r=this.gltf.images[i.source];if(r.uri){let s=r.uri;s=Pt.getURLName(s),i.dtexture=this.gltf.resources[s]}else if(r.bufferView){let s=this.parseBufferView(r.bufferView),a=new Mr,o=new Blob([s],{type:r.mimeType});await a.loadFromBlob(o),i.dtexture=a}else i.dtexture=this.gltf.resources[r.name]}else if(i.name){let r=Pt.getURLName(i.name);i.dtexture=this.gltf.resources[r]}}return i.dtexture||console.log("miss texture , please check texture!",e,i),i.dtexture}async parseMaterial(e){return this._materialParser||(this._materialParser=new by(this)),this._materialParser.parse(e)}parseAnimations(){return[]}async parseObject3D(e,i){return this._converter||(this._converter=new Wy(this)),this._converter.convertNodeToObject3D(e,i)}parseSkeleton(e){return this._skeletonParser||(this._skeletonParser=new Ic(this)),this._skeletonParser.parse(e)}parseSkeletonAnimation(e,i){return this._skeletonParser||(this._skeletonParser=new Ic(this)),this._skeletonParser.parseSkeletonAnimation(e,i)}async traverse(e,i){for(let r=0;r<i.length;r++){const s=await this.parseObject3D(i[r],e);await this.traverse(s,i[r].children)}}async convertToNode(e){const i=new me;i.name=e.name;const r=e.nodes;e.animations;const s=[],a=[];await this.traverse(i,r);let o;return{rootNode:i,textures:s,animations:o,cameras:a}}parseSkin(e){return this._skinParser||(this._skinParser=new Iy(this)),this._skinParser.parse(e)}parseAccessor(e){const i=this.gltf.accessors[e];if(!i)return this.errorMiss("accessor",e);if(i.isParsed)return i.daccessor;i.isParsed=!0,i.daccessor=!1;const r=!!i.normalized,s=this.gltf.bufferViews[i.bufferView],a=s&&s.byteStride,o=Cc(i.componentType);let l=1;switch(i.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${i.type}`),!1;const h=l*o.BYTES_PER_ELEMENT;let u;if(s!==void 0){if(u=this.parseBufferView(i.bufferView),!u)return i.daccessor}else u=new Uint8Array(h*i.count).buffer;let c=this.getTypedArrayFromArrayBuffer(u,a,i.byteOffset||0,o,l,i.count);if(i.sparse){const{count:d,indices:f,values:g}=i.sparse;c=new o(c);const m=f.byteOffset||0,A=this.gltf.bufferViews[f.bufferView],_=Cc(f.componentType),x=this.parseBufferView(f.bufferView),b=this.getTypedArrayFromArrayBuffer(x,A.byteStride,m,_,1,d),R=g.byteOffset||0,E=this.gltf.bufferViews[g.bufferView],M=this.parseBufferView(g.bufferView),G=this.getTypedArrayFromArrayBuffer(M,E.byteStride,R,o,l,d);for(let V=0;V<b.length;V++)c.set(G.slice(V*l,V*l+l),b[V]*l)}return i.computeResult={typedArray:c,arrayType:o,numComponents:l},i.daccessor={data:c,numComponents:l,normalize:r},i.daccessor}getTypedArrayFromArrayBuffer(e,i,r,s,a,o){let l;const h=a*s.BYTES_PER_ELEMENT;if(i&&h!==i){const u=a*o;l=new s(u);for(let c=0;c<o;c++){const d=new s(e,r+c*i,a);for(let f=0;f<a;f++)l[c*a+f]=d[f]}}else l=new s(e,r,o*a);return l}parseBufferView(e){const i=this.gltf.bufferViews[e];if(!i)return this.errorMiss("bufferView",e);if(i.isParsed)return i.dbufferView;i.isParsed=!0,i.dbufferView=!1;const r=this.parseBuffer(i.buffer);if(r){const{byteOffset:s,byteLength:a}=i,o=new Uint8Array(r,s||0,a);i.dbufferView=new Uint8Array(o).buffer}return i.dbufferView}parseBuffer(e){const i=this.gltf.buffers[e];if(!i)return this.errorMiss("buffer",e);if(i.isParsed)return i.dbuffer;if(i.isParsed=!0,i.dbuffer=!1,i.uri.substring(0,5)!=="data:"){const r=i.uri,s=this.gltf.resources[r];s?s.byteLength===i.byteLength?i.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${e}] failed`)}else{const r=i.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,s=window.atob(i.uri.substring(r)),a=new Uint8Array(s.length);for(let o=0;o<s.length;o++)a[o]=s.charCodeAt(o);i.dbuffer=a.buffer}return i.dbuffer}getLight(e){return this.gltf.extensions.KHR_lights_punctual.lights[e]}applyNodeExtensions(e,i){let r=e.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(i.light=this.getLight(r.KHR_lights_punctual.light))}}class jy{constructor(){n(this,"magic"),n(this,"version"),n(this,"length")}}class qy{constructor(){n(this,"chunkLength"),n(this,"chunkType"),n(this,"chunkData")}}class Hh extends Vt{constructor(){super(...arguments),n(this,"_gltf")}async parseBuffer(e){let i=new Uint8Array(e);i.pos=0;const r=this.parseHeader(i);if(r.magic!=1179937895)return console.error("invalid GLB file"),!1;if(r.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`),!1;let s=[];for(;i.pos<i.length;){let c=this.parseChunk(i);s.push(c)}if(s[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let a="",o=65535,l=s[0].chunkData;for(let c=0;c<l.length;c+=o){let d=l.length-c;d=Math.min(d,o);let f=l.subarray(c,c+d);a+=String.fromCharCode(...f)}let h=JSON.parse(a);this._gltf=new Nl,this._gltf={...this._gltf,...h},this._gltf.resources={};for(let c=0;c<this._gltf.buffers.length;c++){let d=this._gltf.buffers[c];d.isParsed=!0,d.dbuffer=s[c+1].chunkData.buffer}if(this._gltf.images)for(let c=0;c<this._gltf.images.length;c++){let d=this._gltf.images[c];d.name=d.name||"bufferView_"+d.bufferView.toString();const f=this._gltf.bufferViews[d.bufferView],g=this._gltf.buffers[f.buffer];let m=new Uint8Array(g.dbuffer,f.byteOffset,f.byteLength),A=new Blob([m],{type:d.mimeType}),_=new Mr;await _.loadFromBlob(A),_.name=d.name,this._gltf.resources[d.name]=_}let u=await new kl().parse(this.initUrl,this._gltf,this._gltf.scene);return u?(this.data=u.rootNode,u.rootNode):null}async parseJsonAndBuffer(e,i){this._gltf=new Nl,this._gltf={...this._gltf,...e},this._gltf.resources={};let r=this._gltf.buffers[0];if(r.isParsed=!0,r.dbuffer=i,this._gltf.images)for(let a=0;a<this._gltf.images.length;a++){let o=this._gltf.images[a];o.name=o.name||"bufferView_"+o.bufferView.toString();const l=this._gltf.bufferViews[o.bufferView],h=this._gltf.buffers[l.buffer];let u=new Uint8Array(h.dbuffer,l.byteOffset,l.byteLength),c=new Blob([u],{type:o.mimeType}),d=new Mr;await d.loadFromBlob(c),d.name=o.name,this._gltf.resources[o.name]=d}let s=await new kl().parse(this.initUrl,this._gltf,this._gltf.scene);return s?(this.data=s.rootNode,s.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let i=e.pos,r=new jy,s=new Uint32Array(e.buffer,i,3);return e.pos+=s.byteLength,r.magic=s[0],r.version=s[1],r.length=s[2],r}parseChunk(e){let i=e.pos,r=new qy,s=new Uint32Array(e.buffer,i,2);i=e.pos+=s.byteLength,r.chunkLength=s[0],r.chunkType=s[1],r.chunkData=new Uint8Array(e.buffer,i,r.chunkLength);const a=new Uint8Array(r.chunkLength);for(let o=0;o<r.chunkLength;o++)a[o]=r.chunkData[o];return r.chunkData=a,e.pos+=r.chunkLength,r}}n(Hh,"format",xt.BIN);var Jy=Object.defineProperty,Zy=Object.getOwnPropertyDescriptor,$y=(t,e,i,r)=>{for(var s=r>1?void 0:r?Zy(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Jy(e,i,s),s};let Ql=class extends $t{constructor(){super();let t=new ct("PBRLItShader","PBRLItShader");t.setShaderEntry("VertMain","FragMain"),t.passType=xe.COLOR,this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor",new Y(.75,.75,.75,1)),this.setUniformColor("emissiveColor",new Y(0,0,0)),this.setUniformVector4("materialF0",new oe(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",1),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.baseMap=I.res.whiteTexture,this.normalMap=I.res.normalTexture,this.maskMap=I.res.maskTexture}get baseMap(){return this.getDefaultColorShader().getTexture("baseMap")}set baseMap(t){this.getDefaultColorShader().setTexture("baseMap",t)}get baseColor(){return this.getDefaultColorShader().getUniform("baseColor")}set baseColor(t){this.getDefaultColorShader().setUniformColor("baseColor",t)}get normalMap(){return this.getDefaultColorShader().getTexture("normalMap")}set normalMap(t){this.getDefaultColorShader().setTexture("normalMap",t)}get doubleSide(){return this.getDefaultColorShader().doubleSide}set doubleSide(t){this.getDefaultColorShader().doubleSide=t}get alphaCutoff(){return this.getDefaultColorShader().shaderState.alphaCutoff}set alphaCutoff(t){this.getDefaultColorShader().setDefine("USE_ALPHACUT",!0),this.getDefaultColorShader().shaderState.alphaCutoff=t,this.getDefaultColorShader().setUniform("alphaCutoff",t)}get emissiveColor(){return this.getDefaultColorShader().getUniform("emissiveColor")}set emissiveColor(t){this.getDefaultColorShader().setUniform("emissiveColor",t)}get emissiveIntensity(){return this.getDefaultColorShader().getUniform("emissiveIntensity")}set emissiveIntensity(t){this.getDefaultColorShader().setUniform("emissiveIntensity",t)}get uvTransform_1(){return this.getDefaultColorShader().uniforms.transformUV1.vector4}set uvTransform_1(t){this.getDefaultColorShader().setUniform("transformUV1",t)}get uvTransform_2(){return this.getDefaultColorShader().uniforms.transformUV2.vector4}set uvTransform_2(t){this.getDefaultColorShader().setUniform("transformUV2",t)}get depthWriteEnabled(){return this.getDefaultColorShader().shaderState.depthWriteEnabled}set depthWriteEnabled(t){this.getDefaultColorShader().shaderState.depthWriteEnabled=t}get materialF0(){return this.getDefaultColorShader().uniforms.materialF0.vector4}set materialF0(t){this.getDefaultColorShader().setUniform("materialF0",t)}get specularColor(){return this.getDefaultColorShader().uniforms.specularColor.color}set specularColor(t){this.getDefaultColorShader().setUniform("specularColor",t)}get roughness(){return this.getDefaultColorShader().uniforms.roughness.value}set roughness(t){this.getDefaultColorShader().setUniform("roughness",t)}get metallic(){return this.getDefaultColorShader().uniforms.metallic.value}set metallic(t){this.getDefaultColorShader().setUniform("metallic",t)}get ao(){return this.getDefaultColorShader().uniforms.ao.value}set ao(t){this.getDefaultColorShader().setUniform("ao",t)}get metallic_min(){return this.getDefaultColorShader().uniforms.metallic_min.value}set metallic_min(t){this.getDefaultColorShader().setUniform("metallic_min",t)}get metallic_max(){return this.getDefaultColorShader().uniforms.metallic_max.value}set metallic_max(t){this.getDefaultColorShader().setUniform("metallic_max",t)}get roughness_min(){return this.getDefaultColorShader().uniforms.roughness_min.value}set roughness_min(t){this.getDefaultColorShader().setUniform("roughness_min",t)}get roughness_max(){return this.getDefaultColorShader().uniforms.roughness_max.value}set roughness_max(t){this.getDefaultColorShader().setUniform("roughness_max",t)}get normalScale(){return this.getDefaultColorShader().uniforms.normalScale.value}set normalScale(t){this.getDefaultColorShader().setUniform("normalScale",t)}get maskMap(){return this.getDefaultColorShader().textures.maskMap}set maskMap(t){this.getDefaultColorShader().setDefine("USE_MR",!0),this.getDefaultColorShader().setTexture("maskMap",t)}set aoMap(t){t&&(this.getDefaultColorShader().setTexture("aoMap",t),t!=I.res.whiteTexture&&this.getDefaultColorShader().setDefine("USE_AOTEX",!0))}get aoMap(){return this.getDefaultColorShader().textures.aoMap}set clearCoatRoughnessMap(t){t&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.getDefaultColorShader().setTexture("clearCoatRoughnessMap",t),this.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.getDefaultColorShader().textures.clearCoatRoughnessMap}get brdfLUT(){return this.getDefaultColorShader().textures.brdfLUT}set brdfLUT(t){this.getDefaultColorShader().setTexture("brdfLUT",t),this.getDefaultColorShader().setTexture("brdflutMap",t)}get emissiveMap(){return this.getDefaultColorShader().textures.emissiveMap}set emissiveMap(t){this.getDefaultColorShader().setTexture("emissiveMap",t)}set envIntensity(t){this.getDefaultColorShader().setUniformFloat("envIntensity",t)}get envIntensity(){return this.getDefaultColorShader().uniforms.envIntensity.value}set ior(t){this.getDefaultColorShader().setUniformFloat("ior",t)}get ior(){return this.getDefaultColorShader().uniforms.ior.value}useCleanCoat(){this.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatFactor",t),this.useCleanCoat()}get clearcoatFactor(){return this.getDefaultColorShader().uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor",t),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(t){this.getDefaultColorShader().setUniformFloat("clearcoatWeight",t),this.useCleanCoat()}get clearcoatWeight(){return this.getDefaultColorShader().uniforms.clearcoatWeight.value}set clearcoatColor(t){this.getDefaultColorShader().setUniformColor("clearcoatColor",t),this.useCleanCoat()}get clearcoatColor(){return this.getDefaultColorShader().uniforms.clearcoatColor.color}};Ql=$y([Lr],Ql);class lr extends Yi{constructor(){super();let e=new Ql;this.shader=e}clone(){let e=new lr,i=e.shader.getDefaultColorShader(),r=this.shader.getDefaultColorShader();return i.defineValue={...r.defineValue},i.setUniform("shadowBias",r.getUniform("shadowBias")),i.setUniform("transformUV1",r.getUniform("transformUV1")),i.setUniform("transformUV2",r.getUniform("transformUV2")),i.setUniform("baseColor",r.getUniform("baseColor")),i.setUniform("specularColor",r.getUniform("specularColor")),i.setUniform("emissiveColor",r.getUniform("emissiveColor")),i.setUniform("materialF0",r.getUniform("materialF0")),i.setUniform("envIntensity",r.getUniform("envIntensity")),i.setUniform("normalScale",r.getUniform("normalScale")),i.setUniform("roughness",r.getUniform("roughness")),i.setUniform("metallic",r.getUniform("metallic")),i.setUniform("ao",r.getUniform("ao")),i.setUniform("roughness_min",r.getUniform("roughness_min")),i.setUniform("roughness_max",r.getUniform("roughness_max")),i.setUniform("metallic_min",r.getUniform("metallic_min")),i.setUniform("metallic_max",r.getUniform("metallic_max")),i.setUniform("emissiveIntensity",r.getUniform("emissiveIntensity")),i.setUniform("alphaCutoff",r.getUniform("alphaCutoff")),i.setUniform("ior",r.getUniform("ior")),i.setUniform("clearcoatFactor",r.getUniform("clearcoatFactor")),i.setUniform("clearcoatRoughnessFactor",r.getUniform("clearcoatRoughnessFactor")),i.setUniform("clearcoatColor",r.getUniform("clearcoatColor")),i.setUniform("clearcoatWeight",r.getUniform("clearcoatWeight")),i.setTexture("baseMap",r.getTexture("baseMap")),i.setTexture("normalMap",r.getTexture("normalMap")),i.setTexture("emissiveMap",r.getTexture("emissiveMap")),i.setTexture("aoMap",r.getTexture("aoMap")),i.setTexture("maskMap",r.getTexture("maskMap")),e}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set maskMap(e){this.shader.setTexture("maskMap",e)}get maskMap(){return this.shader.getTexture("maskMap")}set normalMap(e){this.shader.setTexture("normalMap",e)}get normalMap(){return this.shader.getTexture("normalMap")}set emissiveMap(e){this.shader.setTexture("emissiveMap",e)}get emissiveMap(){return this.shader.getTexture("emissiveMap")}set aoMap(e){this.shader.setTexture("aoMap",e)}get aoMap(){return this.shader.getTexture("aoMap")}set clearCoatRoughnessMap(e){this.shader.setTexture("clearCoatRoughnessMap",e),this.shader.setDefine("USE_CLEARCOAT",!0),this.shader.setDefine("USE_CLEARCOAT_ROUGHNESS",!0)}get clearCoatRoughnessMap(){return this.shader.getTexture("clearCoatRoughnessMap")}set clearcoatColor(e){this.shader.setUniformColor("clearcoatColor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatColor(){return this.shader.getUniformColor("clearcoatColor")}set clearcoatWeight(e){this.shader.setUniformFloat("clearcoatWeight",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatWeight(){return this.shader.getUniformFloat("clearcoatWeight")}set clearcoatFactor(e){this.shader.setUniformFloat("clearcoatFactor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatFactor(){return this.shader.getUniformFloat("clearcoatFactor")}set clearcoatRoughnessFactor(e){this.shader.setUniformFloat("clearcoatRoughnessFactor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatRoughnessFactor(){return this.shader.getUniformFloat("clearcoatRoughnessFactor")}set alphaCutoff(e){this.shader.setUniform("alphaCutoff",e)}get alphaCutoff(){return this.shader.getUniform("alphaCutoff")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}get roughness(){return this.shader.getUniformFloat("roughness")}set roughness(e){this.shader.setUniformFloat("roughness",e)}get metallic(){return this.shader.getUniformFloat("metallic")}set metallic(e){this.shader.setUniformFloat("metallic",e)}get emissiveColor(){return this.shader.getUniformColor("emissiveColor")}set emissiveColor(e){this.shader.setUniformColor("emissiveColor",e)}get emissiveIntensity(){return this.shader.getUniformFloat("emissiveIntensity")}set emissiveIntensity(e){this.shader.setUniformFloat("emissiveIntensity",e)}get ao(){return this.shader.getUniform("ao")}set ao(e){this.shader.setUniform("ao",e)}}class zf extends Vt{constructor(){super(...arguments),n(this,"textData",""),n(this,"source_vertices"),n(this,"source_normals"),n(this,"source_tangents"),n(this,"source_textureCoords"),n(this,"matLibs"),n(this,"geometrys"),n(this,"activeGeo"),n(this,"facesMaterialsIndex"),n(this,"mtl"),n(this,"mtlUrl")}async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,i,r){i[e]&&i[e].length>0?(r.push(i[e][0]),r.push(i[e][1])):(r.push(0),r.push(0))}applyVector3(e,i,r){r.push(i[e][0]),r.push(i[e][1]),r.push(i[e][2])}applyVector4(e,i,r){r.push(i[e][0]),r.push(i[e][1]),r.push(i[e][2]),r.push(i[e][3])}async loadMTL(){let e=await new Ft().loadTxt(this.baseUrl+this.mtlUrl),i=e.data,r,s=i.split(`\r
`);for(let l=0;l<s.length;l++){let h=s[l];var a=h.indexOf("#");a!=-1&&(h=h.substring(0,a)),h=h.trim();var o=h.split(/\s+/);o[0]==="newmtl"?(r={name:o[1]},this.matLibs[o[1]]=r):o[0].indexOf("map_")!=-1?(r[o[0]]=o[1],r.textures||(r.textures=[o[o.length-1]]),r.textures.push(o[o.length-1])):o.length==2?r[o[0]]=Number(o[1]):o.length==3?r[o[0]]=[Number(o[1]),Number(o[2])]:o.length==4&&(r[o[0]]=[Number(o[1]),Number(o[2]),Number(o[3])])}for(const l in this.matLibs){const h=this.matLibs[l];if(h.textures&&h.textures.length>0)for(let u=0;u<h.textures.length;u++){const c=Pt.normalizePath(this.baseUrl+h.textures[u]);await I.res.loadTexture(c)}}return e=null,!0}async load_textures(){}parserLine(e){var i=e.indexOf("#");if(i!=-1){if(e.indexOf("# object")!=-1){var r=e.split(/\s+/);let f=r[1],g=r[2];this.activeGeo={type:f,name:g[1],source_mat:"",source_faces:[]},this.geometrys[g]=this.activeGeo}e=e.substring(0,i)}e=e.trim();var r=e.split(/\s+/);if(r[0]==="v"){var s=[Number(r[1]),Number(r[2]),Number(r[3]),r[4]?1:Number(r[4])];this.source_vertices.push(s)}else if(r[0]==="vt"){var a=[Number(r[1]),Number(r[2]),r[3]?1:Number(r[3])];this.source_textureCoords.push(a)}else if(r[0]==="vn"){var o=[Number(r[1]),Number(r[2]),Number(r[3])];this.source_normals.push(o)}else if(r[0]==="f"){for(var l={indices:[],texture:[],normal:[]},h=1;h<r.length;++h){var u=r[h].indexOf("//"),c=r[h].split(/\W+/);u>0?(l.indices.push(c[0]),l.normal.push(c[1])):c.length===1?l.indices.push(c[0]):c.length===2?(l.indices.push(c[0]),l.texture.push(c[1])):c.length===3&&(l.indices.push(c[0]),l.texture.push(c[1]),l.normal.push(c[2]))}this.activeGeo.source_faces.push(l)}else r[0]==="usemtl"?this.activeGeo.source_mat=r[1]:r[0]==="mtllib"&&(this.mtlUrl=r[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let i=0;i<e.length;i++){const r=e[i];this.parserLine(r)}return this.textData="",!0}async parser_mesh(){for(const e in this.geometrys){const i=this.geometrys[e];i.vertex_arr=[],i.normal_arr=[],i.uv_arr=[],i.indeice_arr=[];let r=0;for(let a=0;a<i.source_faces.length;a++){const o=i.source_faces[a];let l=parseInt(o.indices[0])-1,h=parseInt(o.indices[1])-1,u=parseInt(o.indices[2])-1,c=parseInt(o.normal[0])-1,d=parseInt(o.normal[1])-1,f=parseInt(o.normal[2])-1,g=parseInt(o.texture[0])-1,m=parseInt(o.texture[1])-1,A=parseInt(o.texture[2])-1;if(this.applyVector3(l,this.source_vertices,i.vertex_arr),this.applyVector3(c,this.source_normals,i.normal_arr),this.applyVector2(g,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,i.vertex_arr),this.applyVector3(d,this.source_normals,i.normal_arr),this.applyVector2(m,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,i.vertex_arr),this.applyVector3(f,this.source_normals,i.normal_arr),this.applyVector2(A,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++,o.indices.length>3){let _=parseInt(o.indices[3])-1,x=parseInt(o.normal[3])-1,b=parseInt(o.texture[3])-1;this.applyVector3(l,this.source_vertices,i.vertex_arr),this.applyVector3(c,this.source_normals,i.normal_arr),this.applyVector2(g,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++,this.applyVector3(u,this.source_vertices,i.vertex_arr),this.applyVector3(f,this.source_normals,i.normal_arr),this.applyVector2(A,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++,this.applyVector3(_,this.source_vertices,i.vertex_arr),this.applyVector3(x,this.source_normals,i.normal_arr),this.applyVector2(b,this.source_textureCoords,i.uv_arr),i.indeice_arr[r]=r++}}let s=new me;for(const a in this.geometrys){const o=this.geometrys[a];let l=new wt;l.setIndices(new Uint32Array(o.indeice_arr)),l.setAttribute(z.position,new Float32Array(o.vertex_arr)),l.setAttribute(z.normal,new Float32Array(o.normal_arr)),l.setAttribute(z.uv,new Float32Array(o.uv_arr)),l.setAttribute(z.TEXCOORD_1,new Float32Array(o.uv_arr)),l.addSubGeometry({indexStart:0,indexCount:o.indeice_arr.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});let h=new lr,u=this.matLibs[o.source_mat];h.baseMap=I.res.getTexture(Pt.normalizePath(this.baseUrl+u.map_Kd));let c=new me,d=c.addComponent(Pe);d.geometry=l,d.material=h,s.addChild(c)}this.data=s}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n(zf,"format",xt.TEXT);let eC=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,tC=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class iC{static blurImageFromTexture(e,i,r,s){const a=D.device;let o=s?tC:eC;const l=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:o}),entryPoint:"main"}}),h=4*4,u=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(u,0,new Uint32Array([e.width,e.height,i,r]));const c=a.createTexture({size:[i,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let d=[{binding:0,resource:{buffer:u,size:4*4}},{binding:1,resource:e.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:c.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const f=a.createBindGroup({layout:l.getBindGroupLayout(0),entries:d}),g=T.beginCommandEncoder(),m=g.beginComputePass();return m.setPipeline(l),m.setBindGroup(0,f),m.dispatchWorkgroups(Math.floor(i/8),Math.floor(r/8)),m.end(),T.endCommandEncoder(g),u.destroy(),c}}class Yh extends Lt{constructor(){super(4,4),n(this,"width",4),n(this,"height",4),n(this,"depthOrArrayLayers",6),n(this,"visibility",GPUShaderStage.FRAGMENT),n(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1}),n(this,"samplerBindingLayout",{type:"filtering"}),this.addressModeU=ci.clamp_to_edge,this.addressModeV=ci.clamp_to_edge,this.addressModeW=ci.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,i,r,s,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,o=1){this.width=e,this.height=i,this.format=s,this.usage=a,this.textureDescriptor={size:{width:e,height:i,depthOrArrayLayers:6},mipLevelCount:r,format:s,usage:a,dimension:"2d"},o>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const Gf=class{static createFace(t,e,i,r){const s=D.device;this.pipeline==null&&(this.pipeline=s.createComputePipeline({layout:"auto",compute:{module:s.createShaderModule({code:Gf.createCube}),entryPoint:"main"}}));const a=this.pipeline,o=4*4;this.configBuffer||(this.configBuffer=s.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.configBuffer,0,new Uint32Array([t,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=s.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),s.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let l=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:i.getGPUView()},{binding:2,resource:r.getGPUView()}];const h=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),u=T.beginCommandEncoder(),c=u.beginComputePass();c.setPipeline(a),c.setBindGroup(0,h),c.dispatchWorkgroups(e/8,e/8),c.end(),T.endCommandEncoder(u)}};let Ia=Gf;n(Ia,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),n(Ia,"configBuffer",null),n(Ia,"blurSettingBuffer",null),n(Ia,"pipeline");class wc extends Yh{constructor(){super(),n(this,"_images"),n(this,"_url"),this.useMipmap=!0}generateImages(e){let i=D.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let r=Math.min(this.width,this.height);for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=this.getGPUTexture();let s=[],a=s,o=this.width,l=this.height;if(e[0]instanceof Lt){for(let h=0;h<6;h++){let u=e[h];s[h]=u.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,s)}else{this.uploadBaseImages(this.width,e);for(let h=0;h<6;h++){let u=new Mr(!1);u.format=this.format,u.source=e[h],s[h]=u.getGPUTexture()}}for(let h=1;h<this.mipmapCount;h++){a=s,s=[];let u={width:o,height:l,gpuTexture:null};o=o/2,l=l/2;for(let c=0;c<6;c++)u.gpuTexture=a[c],s[c]=iC.blurImageFromTexture(u,o,l,!1);this.uploadMipmapGPUTexture(h,o,l,s)}this.gpuSampler=i.createSampler(this)}uploadBaseImages(e,i){let r=D.device;const s=T.beginCommandEncoder();for(let a=0;a<6;a++)r.queue.copyExternalImageToTexture({source:i[a]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:a}},{width:e,height:e,depthOrArrayLayers:1});T.endCommandEncoder(s)}uploadMipmapGPUTexture(e,i,r,s){const a=T.beginCommandEncoder();for(let o=0;o<6;o++)a.copyTextureToTexture({texture:s[o],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:o}},{width:i,height:r,depthOrArrayLayers:1});T.endCommandEncoder(a)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let i=function(o,l){l.decode().then(async()=>{r[o]=await createImageBitmap(l),s--,s==0&&a.generateImages(r)})},r=[],s=6,a=this;for(let o=0;o<6;o++)i(o,this._images[o])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let i=6,r=[];this.format=le.rgba8unorm;let s=this;async function a(o,l){const h=document.createElement("img");if(h.src=l,h.setAttribute("crossOrigin",""),await h.decode(),r[o]=await createImageBitmap(h),i--,i==0)return s.generateImages(r),!0}for(let o=0;o<6;o++)await a(o,e[o]);return!0}async loadStd(e){this._url=e,this.format=le.rgba8unorm;const i=document.createElement("img");i.src=e,i.setAttribute("crossOrigin",""),await i.decode();let r=new Mr(!1);r.name=Pt.getURLName(e),r.format="rgba8unorm",r.source=await createImageBitmap(i);let s=Math.round(Math.log2(r.width/4));s=Math.pow(2,s),this.width=this.height=s;let a=[];for(let o=0;o<6;o++){let l=new Gi(s,s,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);l.name="face "+o,a.push(l),Ia.createFace(o,this.width,r,l)}return this.generateImages(a),!0}}var rC=(t=>(t[t.Left=0]="Left",t[t.Right=1]="Right",t[t.Bottom=2]="Bottom",t[t.Top=3]="Top",t[t.Back=4]="Back",t[t.Front=5]="Front",t))(rC||{});class Vf{static getRotationToFace(e){let i=ye.identity().clone(),r=new p,s=new te().identity(),a=new p;switch(e){case 3:r.set(0,-1,0),a.set(0,0,-1);break;case 2:r.set(0,1,0),a.set(0,0,1);break;case 1:r.set(1,0,0),a.set(0,1,0);break;case 0:r.set(-1,0,0),a.set(0,1,0);break;case 4:r.set(0,0,-1),a.set(0,1,0);break;case 5:return ye.identity()}return s.lookAt(new p,r,a),i.setFromRotationMatrix(s),i}}let sC=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,aC=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const ti=class{static convertRGBE2RGBA(t,e){const i=D.device,r=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:aC}),entryPoint:"main"}}),s=i.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(s,0,new Uint32Array([t.width,t.height,t.width,t.height]));const a=i.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(a,0,e);let o=[{binding:0,resource:{buffer:s,size:4*4}},{binding:1,resource:{buffer:a,size:e.byteLength}},{binding:2,resource:t.getGPUView()}];const l=i.createBindGroup({layout:r.getBindGroupLayout(0),entries:o}),h=T.beginCommandEncoder(),u=h.beginComputePass();u.setPipeline(r),u.setBindGroup(0,l),u.dispatchWorkgroups(Math.floor(t.width/8),Math.floor(t.height/8)),u.end(),T.endCommandEncoder(h),s.destroy()}static makeTextureCube(t,e,i){const r=D.device;ti.makeFaceTexturePipeline||(ti.makeFaceTexturePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:sC}),entryPoint:"main"}}));const s=ti.makeFaceTexturePipeline,a=4*4;ti.configBuffer||(ti.configBuffer=r.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),r.queue.writeBuffer(ti.configBuffer,0,new Uint32Array([t.width,t.height,e,e]));const o=4*6;if(!ti.quaternionBuffer){ti.quaternionBuffer=r.createBuffer({size:o*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let g=new Float32Array(4*6);for(let m=0;m<6;m++){let A=Vf.getRotationToFace(m);g[m*4+0]=A.x,g[m*4+1]=A.y,g[m*4+2]=A.z,g[m*4+3]=A.w}r.queue.writeBuffer(ti.quaternionBuffer,0,g)}let l=[{binding:0,resource:{buffer:ti.configBuffer,size:4*4}},{binding:1,resource:{buffer:ti.quaternionBuffer,size:o*4}},{binding:2,resource:t.gpuSampler},{binding:3,resource:t.getGPUView()}],h=[{binding:0,resource:i}];const u=r.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),c=r.createBindGroup({layout:s.getBindGroupLayout(1),entries:h}),d=T.beginCommandEncoder(),f=d.beginComputePass();f.setPipeline(s),f.setBindGroup(0,u),f.setBindGroup(1,c),f.dispatchWorkgroups(e/8,e/8,6),f.end(),T.endCommandEncoder(d)}};let Qs=ti;n(Qs,"makeFaceTexturePipeline"),n(Qs,"configBuffer"),n(Qs,"quaternionBuffer");class Hf extends Lt{constructor(){super(32,32,null),this.isHDRTexture=!0}create(e=32,i=32,r=null,s=!0){this.width=e,this.height=i;let a=D.device;const o=2,l=e*4*o;let h=r;this.format=le.rgba16float,this.useMipmap=s,this.updateTextureDescription(),this.updateGPUTexture();const u=a.createBuffer({size:h.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(u,0,h);const c=T.beginCommandEncoder();return c.copyBufferToTexture({buffer:u,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:i,depthOrArrayLayers:1}),T.endCommandEncoder(c),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=a.createSampler(this),this}async load(e,i){return(await new Ft().load(e,Xf,i)).getHDRTexture()}}const Yf=new Float32Array(1),nC=new Int32Array(Yf.buffer);let _n=function(t){Yf[0]=t;const e=nC[0];let i=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?i:s>142?(i|=31744,i|=(s==255?1:0)&&e&8388607,i):s<114?(r|=2048,i|=(r>>114-s)+(r>>113-s&1),i):(i|=s-112<<10|r>>1,i+=r&1,i)};var oC=(t=>(t[t.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",t[t.rgbe_read_error=1]="rgbe_read_error",t[t.rgbe_write_error=2]="rgbe_write_error",t[t.rgbe_format_error=3]="rgbe_format_error",t[t.rgbe_memory_error=4]="rgbe_memory_error",t))(oC||{});class Sc{constructor(){n(this,"valid"),n(this,"string"),n(this,"comments"),n(this,"programtype"),n(this,"format"),n(this,"gamma"),n(this,"exposure"),n(this,"width"),n(this,"height")}}class Xf extends Vt{constructor(){super(...arguments),n(this,"_rgbeArray"),n(this,"_width"),n(this,"_height"),n(this,"_RGBE_RETURN_FAILURE",-1),n(this,"_parserType",le.rgba8uint)}parseBuffer(e){let i,r=new Uint8Array(e);r.pos=0;const s=this.paserHeader(r);if(s instanceof Sc){const a=this._width=s.width,o=this._height=s.height;let l=this.parserPixel(r.subarray(r.pos),a,o);if(l instanceof Uint8Array){switch(this._rgbeArray=l,this._parserType){}return this.data=i,i}}return null}verification(){if(this.data&&this.data instanceof Lt||this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new zl().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new Hf().create(this._width,this._height,this._rgbeArray)}parseError(e,i){switch(e){case 1:console.error("Read Error: "+(i||""));break;case 2:console.error("Write Error: "+(i||""));break;case 3:console.error("Bad File Format: "+(i||""));break;default:case 4:console.error("Error: "+(i||""))}return-1}parserBlock(e,i,r){i=i||1024;let s=e.pos,a=-1,o=0,l="",h=String.fromCharCode.apply(null,new Uint16Array(e.subarray(s,s+128)));const u=`
`;for(;0>(a=h.indexOf(u))&&o<i&&s<e.byteLength;)l+=h,o+=h.length,s+=128,h+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(s,s+128)));return-1<a?(r!==!1&&(e.pos+=o+a+1),l+h.slice(0,a)):!1}paserHeader(e){const i=/^#\?(\S+)/,r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l=new Sc;let h,u;if(e.pos>=e.byteLength||!(h=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(u=h.match(i)))return this.parseError(3,"bad initial token");const c=1,d=2,f=4;for(l.valid|=c,l.programtype=u[1],l.string+=h+`
`;h=this.parserBlock(e),h!==!1;){if(l.string+=h+`
`,h.charAt(0)==="#"){l.comments+=h+`
`;continue}if((u=h.match(r))&&(l.gamma=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(s))&&(l.exposure=Math.floor(parseFloat(u[1])*10)/10),(u=h.match(a))&&(l.valid|=d,l.format=u[1]),(u=h.match(o))&&(l.valid|=f,l.height=parseInt(u[1],10),l.width=parseInt(u[2],10)),l.valid&d&&l.valid&f)break}return l.valid&d?l.valid&f?l:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,i,r){const s=i;if(s<8||s>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(s!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const a=new Uint8Array(4*i*r);if(!a.length)return this.parseError(4,"unable to allocate buffer space");let o=0,l=0;const h=4*s,u=new Uint8Array(4),c=new Uint8Array(h);let d=r;for(;d>0&&l<e.byteLength;){if(l+4>e.byteLength)return this.parseError(1,"");if(u[0]=e[l++],u[1]=e[l++],u[2]=e[l++],u[3]=e[l++],u[0]!=2||u[1]!=2||(u[2]<<8|u[3])!=s)return this.parseError(3,"bad rgbe scanline format");let f=0,g;for(;f<h&&l<e.byteLength;){g=e[l++];const A=g>128;if(A&&(g-=128),g===0||f+g>h)return this.parseError(3,"bad scanline data");if(A){const _=e[l++];for(let x=0;x<g;x++)c[f++]=_}else c.set(e.subarray(l,l+g),f),f+=g,l+=g}const m=s;for(let A=0;A<m;A++){let _=0;a[o]=c[A+_],_+=s,a[o+1]=c[A+_],_+=s,a[o+2]=c[A+_],_+=s,a[o+3]=c[A+_],o+=4}d--}return a}rbgeToFloat(e,i,r,s){const a=e[i+3],o=Math.pow(2,a-128)/255;r[s+0]=e[i+0]*o,r[s+1]=e[i+1]*o,r[s+2]=e[i+2]*o,r[s+3]=1}rbgeToHalfFloat(e,i,r,s){const a=e[i+3],o=Math.pow(2,a-128)/255;r[s+0]=_n(e[i+0]*o),r[s+1]=_n(e[i+1]*o),r[s+2]=_n(e[i+2]*o),r[s+3]=_n(1)}}let lC=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class wa{static importantSample(e,i,r,s){const a=D.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:lC}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e.width,e.height,i,i]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=a.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let _=new Float32Array(4*6);for(let x=0;x<6;x++){let b=Vf.getRotationToFace(x);_[x*4+0]=b.x,_[x*4+1]=b.y,_[x*4+2]=b.z,_[x*4+3]=b.w}a.queue.writeBuffer(this.quaternionBuffer,0,_)}this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const u=e.erpTexture;let c=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:u.gpuSampler},{binding:3,resource:u.getGPUView()}],d=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:s}];const f=a.createBindGroup({layout:o.getBindGroupLayout(0),entries:c}),g=a.createBindGroup({layout:o.getBindGroupLayout(1),entries:d}),m=T.beginCommandEncoder(),A=m.beginComputePass();A.setPipeline(o),A.setBindGroup(0,f),A.setBindGroup(1,g),A.dispatchWorkgroups(i/8,i/8,6),A.end(),T.endCommandEncoder(m)}}n(wa,"configBuffer",null),n(wa,"quaternionBuffer",null),n(wa,"blurSettingBuffer",null),n(wa,"pipeline");class Kf{constructor(e){n(this,"faceTextureRef"),n(this,"_texture"),this._texture=e,this.faceTextureRef={}}uploadTexture(e,i){let r=this.getGpuSource(e);return Qs.makeTextureCube(i,this._texture.width,r.v),this}uploadErpTexture(e){let i=this.getGpuSource(0);return Qs.makeTextureCube(e,this._texture.width,i.v),this.generateMipmap(e),this}getGpuSource(e){let i=this.faceTextureRef[e];return i||(i={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[e]=i),i}generateMipmap(e){let i=1;for(;i<this._texture.mipmapCount;)this.generateMipmapAtLevel(i,e),i++}generateMipmapAtLevel(e,i,r=3){let s=this._texture.width/Math.pow(2,e),a={width:s,height:s,erpTexture:i},o=(e+1)/this._texture.mipmapCount;o=Math.pow(o,r);let l=this.getGpuSource(e);wa.importantSample(a,s,o,l.v)}}class zl extends Yh{constructor(){super(),n(this,"_url"),n(this,"_faceData"),this.useMipmap=!0,this.format=le.rgba16float,this.isHDRTexture=!0,this._faceData=new Kf(this)}createFromHDRData(e,i){let r=new Gi(i.width,i.height,le.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),s=new Float32Array(i.array);return Qs.convertRGBE2RGBA(r,s),this.createFromTexture(e,r),this}createFromTexture(e,i){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=D.device.createSampler(this),this._faceData.uploadErpTexture(i),this}async load(e,i){return this._url=e,(await new Ft().load(e,Xf,i)).getCubeTexture()}}function hC(t){return new TextDecoder().decode(t)}class Xh{constructor(e,i,r,s){n(this,"buffer"),n(this,"binOffset"),n(this,"binLength"),n(this,"header"),this.buffer=e,this.binOffset=i+r,this.binLength=s;let a=null;if(r!==0){const o=new Uint8Array(e,i,r);a=JSON.parse(hC(o))}else a={};this.header=a}getKeys(){return Object.keys(this.header)}getData(e,i,r=null,s=null){const a=this.header;if(!(e in a))return null;const o=a[e];if(o instanceof Object){if(Array.isArray(o))return o;{const{buffer:l,binOffset:h,binLength:u}=this,c=o.byteOffset||0,d=o.type||s,f=o.componentType||r;if("type"in o&&s&&o.type!==s)throw new Error("FeatureTable: Specified type does not match expected type.");let g;switch(d){case"SCALAR":g=1;break;case"VEC2":g=2;break;case"VEC3":g=3;break;case"VEC4":g=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${e}".`)}let m;const A=h+c,_=i*g;switch(f){case"BYTE":m=new Int8Array(l,A,_);break;case"UNSIGNED_BYTE":m=new Uint8Array(l,A,_);break;case"SHORT":m=new Int16Array(l,A,_);break;case"UNSIGNED_SHORT":m=new Uint16Array(l,A,_);break;case"INT":m=new Int32Array(l,A,_);break;case"UNSIGNED_INT":m=new Uint32Array(l,A,_);break;case"FLOAT":m=new Float32Array(l,A,_);break;case"DOUBLE":m=new Float64Array(l,A,_);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${e}".`)}if(A+_*m.BYTES_PER_ELEMENT>h+u)throw new Error("FeatureTable: Feature data read outside binary body length.");return m}}else return o}}class Wf extends Xh{constructor(e,i,r,s,a){super(e,r,s,a),n(this,"batchSize"),this.batchSize=i}getData(e,i=null,r=null){return super.getData(e,this.batchSize,i,r)}}function jf(t){let e;if(t instanceof DataView?e=t:e=new DataView(t),String.fromCharCode(e.getUint8(0))==="{")return null;let i="";for(let r=0;r<4;r++)i+=String.fromCharCode(e.getUint8(r));return i}class uC{async parse(e){const i=new DataView(e),r=jf(i);console.assert(r==="b3dm");const s=i.getUint32(4,!0);console.assert(s===1);const a=i.getUint32(8,!0);console.assert(a===e.byteLength);const o=i.getUint32(12,!0),l=i.getUint32(16,!0),h=i.getUint32(20,!0),u=i.getUint32(24,!0),c=28,d=new Xh(e,c,o,l),f=c+o+l,g=new Wf(e,d.getData("BATCH_LENGTH"),f,h,u),m=f+h+u,A=new Uint8Array(e,m,a-m);return{version:s,featureTable:d,batchTable:g,glbBytes:A}}}const Fn=class extends uC{constructor(){super(),n(this,"adjustmentTransform"),n(this,"gltfBuffer"),this.adjustmentTransform=new te().identity(),Fn.tempMatrix||(Fn.tempMatrix=new te().identity())}async parse(t){const e=await super.parse(t);this.gltfBuffer=e.glbBytes.slice().buffer;let i=await new Zf().parseBinary(this.gltfBuffer),{batchTable:r,featureTable:s}=e;const a=s.getData("RTC_CENTER");a&&(i.x+=a[0],i.y+=a[1],i.z+=a[2]);let o=i.getComponent(pt);o.updateWorldMatrix();let l=Fn.tempMatrix;l.compose(o.localPosition,o.localRotQuat,o.localScale),l.multiply(this.adjustmentTransform);let h=l.decompose(ki.QUATERNION);return o.localRotQuat.copyFrom(h[1]),o.localRotQuat=o.localRotQuat,o.localPosition.copyFrom(h[0]),o.localPosition=o.localPosition,o.localScale.copyFrom(h[2]),o.localScale=o.localScale,o.updateWorldMatrix(),i.batchTable=r,i.featureTable=s,i}static decodeText(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,r=t.length;i<r;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}};let ea=Fn;n(ea,"tempMatrix");class qf extends Vt{async parseBuffer(e){let i=new ea;i.adjustmentTransform=this.userData,this.data=await i.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n(qf,"format",xt.JSON);const Jf="glTF",ca=12,Ec={JSON:1313821514,BIN:5130562},Gl={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class cC{constructor(e){n(this,"name"),n(this,"content"),n(this,"body"),n(this,"header"),this.name=Gl.KHR_BINARY_GLTF,this.content=null,this.body=null;const i=new DataView(e,0,ca);if(this.header={magic:ea.decodeText(new Uint8Array(e.slice(0,4))),version:i.getUint32(4,!0),length:i.getUint32(8,!0)},this.header.magic!==Jf)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-ca,s=new DataView(e,ca);let a=0;for(;a<r;){const o=s.getUint32(a,!0);a+=4;const l=s.getUint32(a,!0);if(a+=4,l===Ec.JSON){const h=new Uint8Array(e,ca+a,o);this.content=ea.decodeText(h)}else if(l===Ec.BIN){const h=ca+a;this.body=e.slice(h,h+o)}a+=o}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class Zf{constructor(){n(this,"_binary")}async parseBinary(e){this._binary=e;const i=ea.decodeText(new Uint8Array(this._binary,0,4)),r={};let s,a;if(i===Jf){try{a=r[Gl.KHR_BINARY_GLTF]=new cC(this._binary)}catch{return}s=r[Gl.KHR_BINARY_GLTF].content}else s=ea.decodeText(new Uint8Array(this._binary));const o=JSON.parse(s);return await this.parseGLB(o,a.body)}async parseGLB(e,i){return await new Hh().parseJsonAndBuffer(e,i)}}class dC{async parse(e){const i=new DataView(e),r=jf(i);console.assert(r==="i3dm");const s=i.getUint32(4,!0);console.assert(s===1);const a=i.getUint32(8,!0);console.assert(a===e.byteLength);const o=i.getUint32(12,!0),l=i.getUint32(16,!0),h=i.getUint32(20,!0),u=i.getUint32(24,!0);i.getUint32(28,!0);const c=32,d=new Xh(e,c,o,l),f=c+o+l,g=new Wf(e,d.getData("INSTANCES_LENGTH"),f,h,u),m=f+h+u,A=new Uint8Array(e,m,a-m);return{version:s,featureTable:d,batchTable:g,glbBytes:A}}}class fC extends me{constructor(e,i,r){super(),n(this,"_geometry"),n(this,"_material"),n(this,"_instanceList"),this._geometry=e,this._material=i,this._instanceList=[];for(let s=0;s<r;s++){let a,o=new me;a=o.addComponent(Pe),a.geometry=this._geometry,a.material=this._material,this.addChild(o),this._instanceList.push(o)}}setMatrixAt(e,i){let r=this._instanceList[e],s=i.decompose(ki.QUATERNION),a=r.transform;return a.localRotQuat.copyFrom(s[1]),a.localRotQuat=a.localRotQuat,a.localPosition.copyFrom(s[0]),a.localPosition=a.localPosition,a.localScale.copyFrom(s[2]),a.localScale=a.localScale,this}}const bt=class extends dC{constructor(){super(),n(this,"adjustmentTransform"),n(this,"_gltfBuffer"),bt.tempFwd||(bt.tempFwd=new p),bt.tempUp||(bt.tempUp=new p),bt.tempRight||(bt.tempRight=new p),bt.tempPos||(bt.tempPos=new p),bt.tempQuat||(bt.tempQuat=new ye),bt.tempSca||(bt.tempSca=new p),bt.tempMat||(bt.tempMat=new te),this.adjustmentTransform=new te().identity()}async parse(t){const e=await super.parse(t);this._gltfBuffer=e.glbBytes.slice().buffer;let i=await new Zf().parseBinary(this._gltfBuffer),{batchTable:r,featureTable:s}=e;const a=this.adjustmentTransform,o=s.getData("INSTANCES_LENGTH"),l=s.getData("POSITION",o,"FLOAT","VEC3"),h=s.getData("NORMAL_UP",o,"FLOAT","VEC3"),u=s.getData("NORMAL_RIGHT",o,"FLOAT","VEC3"),c=s.getData("SCALE_NON_UNIFORM",o,"FLOAT","VEC3"),d=s.getData("SCALE",o,"FLOAT","SCALAR"),f=new Map,g=[];i.traverse(_=>{let x;if(x=_?_.getComponent(Pe):null,x){const{geometry:b,material:R}=x,E=new fC(b,R,o);E.localPosition=E.localPosition.copy(_.localPosition),E.localRotation=E.localRotation.copy(_.localRotation),E.localScale=E.localScale.copy(_.localScale),g.push(E),f.set(_,E)}});const m=new p;for(let _=0;_<o;_++)m.x+=l[_*3+0]/o,m.y+=l[_*3+1]/o,m.z+=l[_*3+2]/o;f.forEach((_,x)=>{const b=x.parent?x.parentObject:null;b&&(b.removeChild(x),b.addChild(_),_.transform.updateWorldMatrix(),_.transform.worldMatrix.transformVector4(m,_.localPosition))});const A=bt;for(let _=0;_<o;_++){A.tempMat.identity(),A.tempPos.set(l[_*3+0]-m.x,l[_*3+1]-m.y,l[_*3+2]-m.z),h?(A.tempUp.set(h[_*3+0],h[_*3+1],h[_*3+2]),A.tempRight.set(u[_*3+0],u[_*3+1],u[_*3+2]),A.tempRight.crossProduct(A.tempUp,A.tempFwd).normalize(),A.tempMat.makeBasis(A.tempRight,A.tempUp,A.tempFwd),A.tempQuat.setFromRotationMatrix(A.tempMat)):A.tempQuat.set(0,0,0,1),d?A.tempSca.setScalar(d[_]):c?A.tempSca.set(c[_*3+0],c[_*3+1],c[_*3+2]):A.tempSca.set(1,1,1),A.tempMat.compose(A.tempPos,A.tempQuat,A.tempSca),A.tempMat.multiplyMatrices(A.tempMat,a);for(let x=0,b=g.length;x<b;x++)g[x].setMatrixAt(_,A.tempMat)}return i.batchTable=r,i.featureTable=s,i}};let pr=bt;n(pr,"tempFwd"),n(pr,"tempUp"),n(pr,"tempRight"),n(pr,"tempPos"),n(pr,"tempQuat"),n(pr,"tempSca"),n(pr,"tempMat");class $f extends Vt{async parseBuffer(e){let i=new pr;i.adjustmentTransform=this.userData,this.data=await i.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}n($f,"format",xt.BIN);class eg extends Yh{constructor(){super(),n(this,"_faceData"),n(this,"_url"),this.useMipmap=!0,this.format=le.rgba16float,this._faceData=new Kf(this)}get ldrImageUrl(){return this._url}async load(e,i){this._url=e;let r=new Mr(!1);return await r.load(e,i),this.createFromLDRTexture(r),this}createFromLDRTexture(e){let i=Math.log2(e.width/4);return i=Math.pow(2,Math.round(i)),this.createFromTexture(i,e),this}createFromTexture(e,i){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=D.device.createSampler(this),this._faceData.uploadErpTexture(i),this}}let gC=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class pC{constructor(){n(this,"compute"),this.compute=new di(gC)}generateBRDFLUTTexture(){let e=new Gi(256,256,le.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",e),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let i=T.beginCommandEncoder();return T.computeCommand(i,[this.compute]),T.endCommandEncoder(i),e}}class mC extends Lt{constructor(){super(...arguments),n(this,"_dataBuffer")}create(e,i,r,s=!1){let a=D.device;const o=Math.ceil(e*4/256)*256;this.format=le.rgba8unorm,this.mipmapCount=Math.floor(s?Math.log2(e):1),this.createTextureDescriptor(e,i,this.mipmapCount,this.format);const l=this._dataBuffer=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=T.beginCommandEncoder();return h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:i,depthOrArrayLayers:1}),T.endCommandEncoder(h),s&&ls.webGPUGenerateMipmap(this),this}updateTexture(e,i,r){let s=D.device;const a=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const o=this._dataBuffer=s.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s.queue.writeBuffer(o,0,r);const l=T.beginCommandEncoder();l.copyBufferToTexture({buffer:o,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:i,depthOrArrayLayers:1}),T.endCommandEncoder(l),this.gpuSampler=s.createSampler(this),this.mipmapCount>1&&ls.webGPUGenerateMipmap(this)}}class oo{constructor(e){n(this,"id"),n(this,"guiTexture"),n(this,"uvRec",new oe(0,0,1,1)),n(this,"uvBorder",new oe(0,0,0,0)),n(this,"offsetSize",new oe(0,0,4,4)),n(this,"borderSize",new oe(0,0,0,0)),n(this,"trimSize",new Ne),n(this,"isSliced",!1),n(this,"height",4),n(this,"width",4),n(this,"xadvance",0),n(this,"xoffset",0),n(this,"yoffset",0),this.guiTexture=e||I.res.defaultGUITexture}}const Vl=class{constructor(t){n(this,"_staticId",-1),n(this,"dynamicId",-1),n(this,"texture"),n(this,"width",1),n(this,"height",1),t||(t=I.res.whiteTexture),this.texture=t,Vl._maxUid++,this._staticId=Vl._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};let Po=Vl;n(Po,"_maxUid",-1);class AC{constructor(){n(this,"fntCache",{}),n(this,"fntData",{})}addFontData(e,i,r){this.fntData[`${e}${i}`]=r}getFontData(e,i){return this.fntData[`${e}${i}`]}addFnt(e,i,r,s){let a=`${e}${i}`;this.fntCache[a]||(this.fntCache[a]={}),this.fntCache[a][r]=s}getFnt(e,i,r){let s=`${e}${i}`,a=this.fntCache[s];return a?a[r]:this.fntCache[" "]}}let Hl=new AC;class _C{constructor(){n(this,"face",""),n(this,"size",0),n(this,"bold",!1),n(this,"italic",!1),n(this,"stretchH",0),n(this,"spacing",""),n(this,"outline",0),n(this,"lineHeight",0),n(this,"base",0),n(this,"scaleW",0),n(this,"scaleH",0),n(this,"pages",0),n(this,"packed",0),n(this,"alphaChnl",0),n(this,"redChnl",0),n(this,"greenChnl",0),n(this,"blueChnl",0),n(this,"count",0),n(this,"fontPage",[]),n(this,"fontChar",{})}}class vC{constructor(){n(this,"id",0),n(this,"file","")}}class xC{constructor(){n(this,"id",-1),n(this,"x",0),n(this,"y",0),n(this,"width",0),n(this,"height",0),n(this,"xoffset",0),n(this,"yoffset",0),n(this,"xadvance",0),n(this,"page",0),n(this,"chnl",0)}}const Wr=class extends Vt{static parseSprite(t,e){for(const i in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,i)){const r=e.fontChar[i];let s=new oo;s.id=r.id.toString(),s.offsetSize.set(0,0,r.width,r.height),s.trimSize.set(r.width,r.height),s.width=r.width,s.height=r.height,s.xadvance=r.xadvance,s.xoffset=r.xoffset,s.yoffset=r.yoffset,s.guiTexture=t[r.page],s.uvRec.set(r.x/e.scaleW,(e.scaleH-(r.y+r.height))/e.scaleH,r.width/e.scaleW,r.height/e.scaleH),Hl.addFnt(e.face,e.size,s.id,s)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(t){let e=this.getNewLine(t),i=t,r=new _C;i.trim().split(e).forEach((s,a)=>{if(a<2)Wr.readLineProperty(s,r);else if(a<r.pages+2){let o=new vC;Wr.readLineProperty(s,o),r.fontPage.push(o)}else if(a<r.pages+3)Wr.readLineProperty(s,r);else if(r.count>0){let o=new xC;Wr.readLineProperty(s,o),r.fontChar[o.id]=o,r.count--}}),i="",this.data=r,await this.loadFontTextures()}getNewLine(t){return t.indexOf(`\r
`)!=-1?`\r
`:t.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let t=[],e=this.data;for(const i of e.fontPage){let r=this.baseUrl+i.file;await I.res.loadTexture(r,null,!0);let s=I.res.getTexture(r),a=new Po(s);t.push(a)}Wr.parseSprite(t,e),e.fontChar[" "]||Wr.insertSpaceChar(e,t[0])}static insertSpaceChar(t,e){let i=new oo,r=t.size*.5,s=t.lineHeight*.5;i.id=" ",i.offsetSize.set(0,0,t.size,t.size),i.trimSize.set(r,s),i.width=r,i.height=s,i.xadvance=0,i.xoffset=0,i.yoffset=0,i.guiTexture=e,i.uvRec.set(0,0,1e-6,1e-6),Hl.addFnt(t.face,t.size,i.id,i)}static readLineProperty(t,e){t.trim().split(" ").forEach((i,r)=>{let s=i.split("=");if(s.length>1){let a=s[0],o=s[1];Object.prototype.hasOwnProperty.call(e,a)&&(o.indexOf('"')==-1?e[a]=parseFloat(s[1]):e[a]=o.replace('"',"").replace('"',""))}})}};let tg=Wr;n(tg,"format",xt.TEXT);function yC(t,e,i){let r=new oo;r.guiTexture=t,r.id=e,r.uvRec.copyFrom(i.textureRect),r.trimSize.x=i.textureRect.z,r.trimSize.y=i.textureRect.w,r.offsetSize.x=i.textureRectOffset.x,r.offsetSize.y=i.textureRectOffset.y,r.offsetSize.z=i.size.x,r.offsetSize.w=i.size.y,r.width=i.size.x,r.height=i.size.y;let s=1/t.width,a=1/t.height;r.uvRec.set(r.uvRec.x*s,r.uvRec.y*a,r.uvRec.z*s,r.uvRec.w*a);let o=.1;return i.border.x<=o&&i.border.y<=o&&i.border.z<=o&&i.border.x<=o?r.isSliced=!1:(r.borderSize.copyFrom(i.border),r.uvBorder.copyFrom(i.border),r.uvBorder.x-=i.textureRectOffset.x,r.uvBorder.y-=i.textureRectOffset.y,r.uvBorder.z=i.border.z-(i.size.x-i.textureRect.z-i.textureRectOffset.x),r.uvBorder.w=i.border.w-(i.size.y-i.textureRect.w-i.textureRectOffset.y),r.uvBorder.x/=i.textureRect.z,r.uvBorder.z/=i.textureRect.z,r.uvBorder.y/=i.textureRect.w,r.uvBorder.w/=i.textureRect.w,r.isSliced=!0),r}class CC{constructor(e){n(this,"_spriteMap",new Map),n(this,"_spriteList",[]),n(this,"textureSize",new Ne),n(this,"name"),this.textureSize.set(e.x,e.y)}setTexture(e,i,r){let s=yC(e,i,r);return this._spriteMap.set(s.id,s),this._spriteList.push(s),s}getSprite(e){return this._spriteMap.get(e)}get spriteList(){return this._spriteList}}class ig extends Vt{constructor(){super(...arguments),n(this,"_json"),n(this,"_texture")}async parseString(e){this._json=JSON.parse(e);let i=this.userData.replace(".json",".png");this._texture=await I.res.loadTexture(i,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new CC(this._json.size),i=new Po(this._texture),r=this._json.atlas;for(const s in r)e.setTexture(i,s,r[s]);I.res.addAtlas(this.baseUrl,e),this.data=e}}n(ig,"format",xt.TEXT);class bC{constructor(){n(this,"_texturePool"),n(this,"_materialPool"),n(this,"_prefabPool"),n(this,"_gltfPool"),n(this,"_geometryPool"),n(this,"_atlasList"),n(this,"_obj"),n(this,"normalTexture"),n(this,"maskTexture"),n(this,"whiteTexture"),n(this,"blackTexture"),n(this,"redTexture"),n(this,"blueTexture"),n(this,"greenTexture"),n(this,"yellowTexture"),n(this,"grayTexture"),n(this,"defaultSky"),n(this,"defaultGUITexture"),n(this,"defaultGUISprite"),n(this,"defaultMaterial"),this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._geometryPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this._obj=new Map}getGltf(e){return this._gltfPool.get(e)}addObj(e,i){this._obj.set(e,i)}getObj(e){return this._obj.get(e)}addTexture(e,i){this._texturePool.set(e,i)}getTexture(e){return this._texturePool.get(e)}addGeometry(e,i){this._geometryPool.set(e,i)}getGeometry(e){return this._geometryPool.get(e)}addMat(e,i){return this._materialPool.set(e,i)}getMat(e){return this._materialPool.get(e)}addPrefab(e,i){this._prefabPool.set(e,i)}getPrefab(e){return this._prefabPool.get(e).instantiate()}addAtlas(e,i){i.name=e,this._atlasList.set(e,i)}getAtlas(e){return this._atlasList.get(e)}getGUISprite(e){for(let i of this._atlasList.values()){let r=i.getSprite(e);if(r)return r}return null}async load(e,i,r){return(await new Ft().load(e,i,r)).data}async loadGltf(e,i){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new Ft;s==".gltf"?r=await a.load(e,It,i):r=await a.load(e,Hh,i);let o=r.data;return this._prefabPool.set(e,o),this._gltfPool.set(e,r.gltf),o}async loadObj(e,i){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,s=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new Ft;s==".obj"&&(r=await a.load(e,zf,i));let o=r.data;return this._prefabPool.set(e,o),o}async loadB3DM(e,i,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let s=(await new Ft().load(e,qf,i,r)).data;return this._prefabPool.set(e,s),s}async loadI3DM(e,i,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let s=(await new Ft().load(e,$f,i,r)).data;return this._prefabPool.set(e,s),s}async loadTexture(e,i,r){if(this._texturePool.has(e))return this._texturePool.get(e);let s=new Mr;return s.flipY=r,await s.load(e,i),this._texturePool.set(e,s),s}async loadTextureCount(e,i,r,s){return new Promise(async(a,o)=>{let l=0,h=[];i==0&&a(h);for(let u=0;u<i;u++){const c=e.shift();this.loadTexture(c,r,s).then(d=>{h.push(d),l++,l==i&&a(h)})}})}async loadBitmapTextures(e,i=5,r,s){let a=[],o=Math.floor(e.length/i)+1,l=Math.floor(e.length%i);for(let h=0;h<o;h++){let u=await this.loadTextureCount(e,h==o-1?l:i,r,s);a.push(...u)}return a}async loadHDRTexture(e,i){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Hf;return r=await r.load(e,i),this._texturePool.set(e,r),r}async loadHDRTextureCube(e,i){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new zl;return r=await r.load(e,i),this._texturePool.set(e,r),r}async loadLDRTextureCube(e,i){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new eg;return r=await r.load(e,i),this._texturePool.set(e,r),r}async loadTextureCubeMaps(e){let i=e[0];if(this._texturePool.has(i))return this._texturePool.get(i);let r=new wc;return await r.load(e),this._texturePool.set(e[0],r),r}async loadTextureCubeStd(e,i){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new wc;return await r.loadStd(e),r}async loadJSON(e,i){return await new Ft().loadJson(e,i).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(e,i,r){let s=await new Ft().load(e,tg,i,r),a=s.data;return Hl.addFontData(a.face,a.size,a),s.data}async loadAtlas(e,i){return(await new Ft().load(e,ig,i,e)).data}createTexture(e,i,r,s,a,o,l){let h=32,u=32,c=new Uint8Array(h*u*4);this.fillColor(c,e,i,r,s,a,o);let d=new mC;return d.name=l,d.create(16,16,c,!0),l&&this.addTexture(l,d),d}fillColor(e,i,r,s,a,o,l){for(let h=0;h<i;h++)for(let u=0;u<r;u++){let c=u*i+h;e[c*4+0]=s,e[c*4+1]=a,e[c*4+2]=o,e[c*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,255,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let e=new pC().generateBRDFLUTTexture(),i=e.name="BRDFLUT";this.addTexture(i,e),this.defaultSky=new zl,this.defaultSky.createFromTexture(128,this.blackTexture),Me.getInstance().attached(this.defaultSky,this),Me.getInstance().attached(e,this),Me.getInstance().attached(this.normalTexture,this),Me.getInstance().attached(this.maskTexture,this),Me.getInstance().attached(this.whiteTexture,this),Me.getInstance().attached(this.blackTexture,this),Me.getInstance().attached(this.redTexture,this),Me.getInstance().attached(this.blueTexture,this),Me.getInstance().attached(this.greenTexture,this),Me.getInstance().attached(this.yellowTexture,this),Me.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new Po(this.whiteTexture),this.defaultGUISprite=new oo(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4),this.defaultMaterial=new lr}}class Ye{}n(Ye,"pixelRatio",1),n(Ye,"solution",new Ne(1600,1280)),n(Ye,"quadMaxCountForWorld",256),n(Ye,"quadMaxCountForView",2048),n(Ye,"SortOrderStartWorld",7e3),n(Ye,"SortOrderStartView",8e3),n(Ye,"SortOrderCanvasSpan",1e4);var Ni=(t=>(t[t.View=0]="View",t[t.World=2]="World",t))(Ni||{}),lo=(t=>(t[t.Simple=0]="Simple",t[t.Sliced=1]="Sliced",t[t.Tiled=2]="Tiled",t[t.Filled=3]="Filled",t))(lo||{}),is=(t=>(t[t.None=0]="None",t[t.BillboardY=9]="BillboardY",t[t.BillboardXYZ=10]="BillboardXYZ",t))(is||{});class Ga extends Ll{constructor(){super();let e=D.presentationSize;W.register("FXAA_Shader",LC);let i=this.createRTTexture("FXAAPost",e[0],e[1],le.rgba16float),r=this.createViewQuad("fxaa","FXAA_Shader",i);r.quadShader.setUniform("u_texel",new Ne(1/e[0],1/e[1])),r.quadShader.setUniform("u_strength",4)}onAttach(e){I.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){I.setting.render.postProcessing.fxaa.enable=!1}}class Tc extends Zt{constructor(){super(...arguments),n(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,i=I.getRenderJob(e);this._postList.forEach(r=>{i.addPost(r)})}unActivePost(){let e=this.transform.view3D,i=I.getRenderJob(e);this._postList.forEach(r=>{i.removePost(r)})}addPost(e){if(this._postList.has(e.name))return;if(!this._postList.has(Ga.name)){let r=new Ga;if(this._postList.set(r.constructor.name,r),this._enable&&this.activePost(),e.name===Ga.name)return r}let i=new e;return this._postList.set(e.name,i),this._enable&&this.activePost(),i}removePost(e){if(!this._postList.has(e.name))return;let i=this._postList.get(e.name);this._postList.delete(e.name);let r=this.transform.view3D;I.getRenderJob(r).removePost(i)}getPost(e){return this._postList.has(e.name)?this._postList.get(e.name):null}}class I{static get frameRate(){return this._frameRate}static set frameRate(e){this._frameRate=e,this._frameRateValue=1/e,e>=360&&(this._frameRateValue=0)}static get size(){return D.presentationSize}static get aspect(){return D.aspect}static get width(){return D.windowWidth}static get height(){return D.windowHeight}static async init(e={}){console.log("Engine Version",m0),this.setting={...this.setting,...e.engineSetting},await ve.init(te.allocCount),await D.init(e.canvasConfig),W.init(),Ri.init(),Ze.init(),Ut.init(),Mt.init(),this.res=new bC,this.res.initDefault(),this._beforeRender=e.beforeRender,this._renderLoop=e.renderLoop,this._lateRender=e.lateRender,this.inputSystem=new p0,this.inputSystem.initCanvas(D.canvas)}static startRenderView(e){this.renderJobs||(this.renderJobs=new Map),this.views=[e];let i=new yc(e);return this.renderJobs.set(e,i),D.presentationSize,this.setting.pick.mode=="pixel"&&e.scene.getOrAddComponent(Tc).addPost(Ga),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(e.enablePick=!0),this.resume(),i}static startRenderViews(e){this.renderJobs||(this.renderJobs=new Map),this.views=e;for(let i=0;i<e.length;i++){const r=e[i];let s=new yc(r);this.renderJobs.set(r,s);let a=D.presentationSize;this.setting.pick.mode=="pixel"?r.scene.addComponent(Tc).addPost(Ga):Ut.createRTTexture(ht.colorBufferTex_NAME,a[0],a[1],le.rgba16float,!1),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(r.enablePick=!0)}this.resume()}static getRenderJob(e){return this.renderJobs.get(e)}static pause(){this._requestAnimationFrameID!=0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID=requestAnimationFrame(e=>this.render(e))}static render(e){this._deltaTime=e-this._time,this._time=e,this._frameRateValue>0?(this._frameTimeCount+=this._deltaTime*.001,this._frameTimeCount>=this._frameRateValue*.95&&(this._frameTimeCount=0,this.updateFrame(e))):this.updateFrame(e),this.resume()}static updateGUIPixelRatio(e,i){let r=Ye.solution.x/Ye.solution.y,s=e/i;r<s?Ye.pixelRatio=i/Ye.solution.y:Ye.pixelRatio=e/Ye.solution.x}static updateFrame(e){He.delta=e-He.time,He.time=e,He.frame+=1,Ff.tick(He.delta);let i=this.views,r=0;for(r=0;r<i.length;r++){const a=i[r];a.scene.waitUpdate(),a.camera.resetPerspective(D.aspect)}this.updateGUIPixelRatio(D.canvas.clientWidth,D.canvas.clientHeight),this._beforeRender&&this._beforeRender();for(const a of Oe.componentsBeforeUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}let s=D.device.createCommandEncoder();for(const a of Oe.componentsComputeList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o,s)}}D.device.queue.submit([s.finish()]);for(const a of Oe.componentsUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}for(const a of Oe.graphicComponent){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];o&&u.enable&&c(o)}}this._renderLoop&&this._renderLoop(),ve.updateAllContinueTransform(0,te.useCount,16),Ze.modelMatrixBindGroup.writeBuffer(te.useCount*16),this.renderJobs.forEach((a,o)=>{a.renderState||a.start(),a.renderFrame()});for(const a of Oe.componentsLateUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}this._lateRender&&this._lateRender()}}n(I,"res"),n(I,"inputSystem"),n(I,"views"),n(I,"_frameRateValue",0),n(I,"_frameRate",360),n(I,"_frameTimeCount",0),n(I,"_deltaTime",0),n(I,"_time",0),n(I,"_beforeRender"),n(I,"_renderLoop"),n(I,"_lateRender"),n(I,"_requestAnimationFrameID",0),n(I,"Engine3D"),n(I,"divB"),n(I,"setting",{occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,gi:!1,postProcessing:{bloom:{downSampleStep:5,downSampleBlurSize:5,downSampleBlurSigma:1,upSampleBlurSize:5,upSampleBlurSigma:1,luminanceThreshole:1,bloomIntensity:1},globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new Y(96/255,117/255,133/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},godRay:{blendColor:!0,rayMarchCount:16,scatteringExponent:5,intensity:.5},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:.7,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:.002,shadowSize:1024,pointShadowSize:1024,shadowSoft:.005,shadowBias:1e-4,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1},loader:{numConcurrent:20}}),n(I,"renderJobs");`${Jt.Cascades}`;let IC=`

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`,wC=`
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`,SC=`
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) TEXCOORD_1: vec2<f32>,
        @location(4) vIndex: f32,
        @location(5) index2: f32,
        
    }

    struct VertexOutput {
        @location(0) index: f32,
        @location(1) varying_UV0: vec2<f32>,
        @location(2) varying_UV1: vec2<f32>,
        @location(3) varying_ViewPos: vec4<f32>,
        @location(4) varying_Clip: vec4<f32>,
        @location(5) varying_WPos: vec4<f32>,
        @location(6) varying_WNormal: vec3<f32>,
        @location(7) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(8) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,
        baseColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`,EC=t=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${t}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }else if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else{
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                let l3 = segi + 2u;
                drawLineBody(l0,l1,l2,l3,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(l0:u32,l1:u32,l2:u32,l3:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 
        let p3 = shapeInfo.paths[l3].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;
        let right1 = cross(d2 , d1) ;

        let dir0 = normalize(d1 - d0) ;
        let dir1 = normalize(d2 - d1) ;

        // let lOr0 = dot(d0 , d3);
        // let lOr1 = dot(d1 , d4);

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(d1,dir1)) ;

        if(angle0<0.0){
            angle0 *= -1.0 ;
        }
        if(angle1<0.0){
            angle1 *= -1.0 ;
        }

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;

        let d1Right = cross(d1,up);
        let d2Right = cross(d2,up);

        newP0 = dir0 * lc0 + p1 ;
        newP1 = -dir0 * lc0 + p1 ;
        newP2 = dir1 * lc1 + p2 ;
        newP3 = -dir1 * lc1 + p2 ;

        newP4 = -d2Right * shapeInfo.width + p2 ;
        newP5 = -lc1 * dir1 + p2 ;

        let uScale = 1.0 ;
        let lVScale = length(newP2 - newP0);
        let rVScale = length(newP3 - newP1);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 4u + 0u,newP0,newP1,newP2,u0,u1,u3);
        // drawFace(l1 * 4u + 1u,newP0,newP2,newP3,u0,u1,u3);

        // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u1,u2,u3);
        // drawFace(l1 * 4u + 3u,newP3,newP4,newP5,u1,u2,u3);
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let nextRight = cross( normalize(d1) , up );
        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
        var next:vec3f;
        var outer:vec3f = p1 - lc * dc;
    
        if(lOr < 0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
            next = -nextRight * shapeInfo.width + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
            next = nextRight * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 4u + 0u,end_l,end_r,next,u0,u1,u3);

        if(lOr < 0.0){
            drawFace(l0 * 4u + 1u,outer,end_l,next,u0,u1,u3);
        }else{
            drawFace(l0 * 4u + 1u,next,end_r,outer,u0,u1,u3);
        }

        drawFace(l0 * 4u + 2u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 4u + 3u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        // drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 4u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 4u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `,TC=t=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        // px:f32,
        // py:f32,
        // pz:f32,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct TrailInfo{
        index : f32 ,
        segment : f32 ,
        visible : f32 ,
        width: f32,

        uv: vec4f,

        uvSpeed: vec2f,
        smoothLine: f32,
        faceMode: f32,
        up: vec4f,
        ids:array<f32,${t}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read> trailBuffer : array<TrailInfo>;
    @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;

    var<private> time:f32;
    var<private> viewDir:vec3f;

    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        let rID = workgroup_id.x ;
        let trailInfo = trailBuffer[rID];
        let vLen = u32(trailInfo.segment+1.0) ;
        let vID = global_invocation_id.x ;

        // if(vID < vLen ){
            time = globalUniform.time * 0.001;
            var right:vec3f ;
            
            switch (u32(trailInfo.faceMode)) {
                case 0u:{
                    right = getRightByMode(vID,vLen,viewDir,trailInfo) ;
                    break;
                }
                case 1u:{
                    right = vec3f(0.0,0.0,1.0) ;
                    break;
                }
                case 2u:{
                    right = getRightByMode(vID,vLen,trailInfo.up.xyz,trailInfo) ;
                    break;
                }
                default:{
                    break;
                }
            }
            writeTOBuffer(rID,vID,vLen,right,trailInfo);
        // }
    }

 

    fn writeTOBuffer(rID:u32, vID:u32 , vLen:u32, right:vec3f , trailInfo:TrailInfo ){
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;

        let worldPos = models[i32(trailInfo.ids[vID])][3].xyz ;
        let leftPos = worldPos - right.xyz * trailInfo.width ;
        let rightPos = worldPos + right.xyz * trailInfo.width ;

        vertexBuffer[li].position = leftPos ;
        vertexBuffer[ri].position = rightPos ;

        let uvS = time * trailInfo.uvSpeed ;

        vertexBuffer[li].uv_x = (trailInfo.uv.x) + uvS.x ;
        vertexBuffer[ri].uv_x = (trailInfo.uv.z + trailInfo.uv.x) + uvS.x ;

        // var ld = 0.0 ;
        // var rd = 0.0 ;
        // if(vID>0u){
        //     let vid0 = getVID(vID,vLen,rID);
        //     let vid1 = getVID(vID-1u,vLen,rID);
        
        //     ld = distance( vertexBuffer[li].position , vertexBuffer[vid1.x].position ) ;
        //     rd = distance( vertexBuffer[ri].position , vertexBuffer[vid1.y].position ) ;

        //     vertexBuffer[li].uv_y = vertexBuffer[vid1.x].uv_y + 1.0 / ld * 100.0 ;//+ uvS.y ;
        //     vertexBuffer[ri].uv_y = vertexBuffer[vid1.y].uv_y + 1.0 / rd * 100.0 ;//+ uvS.y ;
        // }else{
            let v = (1.0 - f32(vID) / trailInfo.segment) * trailInfo.uv.w + trailInfo.uv.y;
            vertexBuffer[li].uv_y = v + uvS.y ;
            vertexBuffer[ri].uv_y = v + uvS.y ;
        // }
    }

    fn getRight(p0:vec3f,p1:vec3f,p2:vec3f,up:vec3f) -> vec3f {
        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        // var a = dot(d0,d1) ;
        // var ep = 0.0 ;
        // if(a<0.0){
        //     a = -a ;
        //     ep = 1.0/sin(a*0.25) ;
        // }else if(a == 0.0){
        //     ep = 1.414 ;
        // }else{
        //     ep = 1.0 ;
        // }
        let forward = normalize((d0 + d1)+ vec3f(0.000001,0.000001,0.000001)) ;
        return normalize(cross(forward,up)) ;//* ep ;
    }

    fn getVID(vID:u32,vLen:u32,rID:u32) -> vec2<u32> {
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;
        return vec2<u32>(li,ri);
    }

    fn getRightByMode( vID:u32 , vLen:u32, up:vec3f, trailInfo:TrailInfo ) -> vec3f{
        var right:vec3f;
        if(vID==0u){
            // first
            let sp0 = models[i32(trailInfo.ids[ 0 ])][3].xyz ;
            let sp1 = models[i32(trailInfo.ids[ 1 ])][3].xyz ;
            let firstFront = normalize(sp1 - sp0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - sp0) ;
            right = normalize(cross(firstFront,viewDir));
        }else if( vID < (vLen-1) ){
            // body
            let bp0 = models[i32(trailInfo.ids[vID-1])][3].xyz ;
            let bp1 = models[i32(trailInfo.ids[vID])][3].xyz ;
            let bp2 = models[i32(trailInfo.ids[vID+1])][3].xyz ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - bp1) ;
            right = getRight(bp0,bp1,bp2,viewDir) ;
        }else{
            // last
            let ep0 = models[i32(trailInfo.ids[u32(trailInfo.segment)-1u])][3].xyz ;
            let ep1 = models[i32(trailInfo.ids[u32(trailInfo.segment)])][3].xyz ;
            let endFront = normalize(ep1 - ep0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - ep1) ;
            right = normalize(cross(endFront,viewDir));
        }
        return normalize(right) ; 
    }
    `,BC=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = 1.0 ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            #if USE_SHADOWMAPING
                useShadow();
            #endif

            BxDFShading();
        }
    `,DC=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `,RC=`
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`,MC=`
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`,PC=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        #if USE_SHADOWMAPING
            useShadow();
        #endif

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity / LUMEN)  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`,UC=`
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy; 
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicNode.texIndex)) ) * graphicNode.baseColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < 0.5){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`,LC=`
    struct FragmentOutput {
        @location(0) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(0) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`;class rg{}n(rg,"cs",`
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class OC{constructor(){n(this,"sunRadius",500),n(this,"sunRadiance",11),n(this,"mieG",.76),n(this,"mieHeight",1200),n(this,"eyePos",1500),n(this,"sunX",.71),n(this,"sunY",.56),n(this,"sunBrightness",1),n(this,"displaySun",!0),n(this,"defaultTextureCubeSize",512),n(this,"defaultTexture2DSize",1024),n(this,"skyColor",new Y(1,1,1,1))}}class NC extends eg{constructor(e){return super(),n(this,"_internalTexture"),n(this,"_cubeSize"),n(this,"setting"),this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new FC(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class FC extends Gi{constructor(e,i){super(e,i,le.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),n(this,"_computeShader"),n(this,"_uniformBuffer"),this.initCompute(e,i)}initCompute(e,i){this._uniformBuffer=new an(16*4),this._uniformBuffer.apply(),this._computeShader=new di(rg.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=i/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let i=T.beginCommandEncoder();return T.computeCommand(i,[this._computeShader]),T.endCommandEncoder(i),this}}var kC=Object.defineProperty,QC=Object.getOwnPropertyDescriptor,zC=(t,e,i,r)=>{for(var s=r>1?void 0:r?QC(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&kC(e,i,s),s};let Yl=class extends $t{constructor(){super();let t=new ct("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.addRenderPass(t),t.setUniformVector3("eyesPos",new p),t.setUniformFloat("exposure",1),t.setUniformFloat("roughness",0);let e=t.shaderState;e.frontFace="cw",e.cullMode=zt.back,e.depthWriteEnabled=!1,e.depthCompare=zi.less}};Yl=zC([Lr],Yl);class GC extends Yi{constructor(){super(),this.shader=new Yl,this.shader.setUniformVector3("eyesPos",new p),this.shader.setUniformFloat("exposure",1),this.shader.setUniformFloat("roughness",0)}set baseMap(e){this.setTexture("baseMap",e);const i="IS_HDR_SKY";this._shader.getDefaultShaders()[0].defineValue[i]!=(e==null?void 0:e.isHDRTexture)&&this._shader.setDefine(i,!!(e!=null&&e.isHDRTexture))}get baseMap(){return this._shader.getDefaultColorShader().getTexture("baseMap")}set envMap(e){}set shadowMap(e){}get exposure(){return I.setting.sky.skyExposure}set exposure(e){I.setting.sky.skyExposure=e}get roughness(){return this._shader.getDefaultColorShader().uniforms.roughness.value}set roughness(e){let i=this._shader.getDefaultColorShader();"roughness"in i.uniforms&&(i.uniforms.roughness.value=e)}}class Xl extends wt{constructor(e,i,r,s,a,o,l){super(),n(this,"shape_vertices",[]),n(this,"shape_indices",[]),n(this,"radius"),n(this,"widthSegments"),n(this,"heightSegments"),n(this,"phiStart"),n(this,"phiLength"),n(this,"thetaStart"),n(this,"thetaLength"),this.radius=e,this.widthSegments=i,this.heightSegments=r,this.phiStart=s,this.phiLength=a,this.thetaStart=o,this.thetaLength=l,this.buildGeometry()}buildGeometry(){var e,i,r=0;let s=this.heightSegments,a=this.widthSegments,o=this.radius;var l=(s+1)*(a+1);let h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),d=new Uint16Array(a*s*2*3),f=0,g=0,m=0;for(i=0;i<=s;++i){var A=Math.PI*i/s,_=-o*Math.cos(A),x=o*Math.sin(A);for(e=0;e<=a;++e){var b=2*Math.PI*e/a,R=x*Math.cos(b),E=x*Math.sin(b),M=1/Math.sqrt(R*R+E*E+_*_);if(h[f++]=R,h[f++]=E,h[f++]=_,u[g++]=R*M,u[g++]=E*M,u[g++]=_*M,c[m++]=e/a,c[m++]=1-i/s,e>0&&i>0){var G=(a+1)*i+e,V=(a+1)*i+e-1,k=(a+1)*(i-1)+e-1,O=(a+1)*(i-1)+e;i==s?(d[r++]=G,d[r++]=k,d[r++]=O):i==1?(d[r++]=G,d[r++]=V,d[r++]=k):(d[r++]=G,d[r++]=V,d[r++]=k,d[r++]=G,d[r++]=k,d[r++]=O)}}}this.setIndices(d),this.setAttribute(z.position,h),this.setAttribute(z.normal,u),this.setAttribute(z.uv,c),this.setAttribute(z.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.bounds=new _t(p.ZERO,new p(this.radius*2,this.radius*2,this.radius*2))}}class VC extends Pe{constructor(){super(...arguments),n(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(vt.Sky),this.alwaysRender=!0,this.object3D.bound=new _t(p.ZERO.clone(),p.MAX),this.geometry=new Xl(I.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new GC)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(ie.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,ie.instance.sky=null)}renderPass2(e,i,r,s,a,o=!1){super.renderPass2(e,i,r,s,a,o)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}}class HC{constructor(){n(this,"rotateX"),n(this,"rotateY"),n(this,"sunX"),n(this,"sunY"),this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(e,i){return Math.abs(this.rotateX-e)>=.001||Math.abs(this.rotateY-i)>=.001}isSkyChange(e,i){return Math.abs(this.sunX-e)>=.001||Math.abs(this.sunY-i)>=.001}save(e,i,r,s){return this.sunX=e,this.sunY=i,this.rotateX=r,this.rotateY=s,this}}class YC extends VC{constructor(){super(...arguments),n(this,"_atmosphericScatteringSky"),n(this,"_onChange",!0),n(this,"_relatedTransform"),n(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new HC,this._atmosphericScatteringSky=new NC(new OC);let e=this.transform.view3D,i=this.transform.scene3D;this.map=this._atmosphericScatteringSky,i.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let i=this.transform.scene3D;this.map=this._atmosphericScatteringSky,i.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class ho extends Zt{constructor(){super(),n(this,"type"),n(this,"camera"),n(this,"_cameraPosition"),this._cameraPosition=new p}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==is.BillboardXYZ||this.type==is.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let i=e.addComponent(ho);i.type=this.type}}var sg=(t=>(t[t.None=0]="None",t[t.Box=1]="Box",t[t.Capsule=2]="Capsule",t[t.Sphere=3]="Sphere",t[t.Mesh=4]="Mesh",t))(sg||{});const jr=class{constructor(){n(this,"_center"),n(this,"_size"),n(this,"_halfSize"),n(this,"_shapeType",0),jr.v3_help_0||(jr.v3_help_0=new p),jr.helpMatrix||(jr.helpMatrix=new te),jr.helpRay||(jr.helpRay=new fs),this._center=new p,this._size=new p,this._halfSize=new p}get shapeType(){return this._shapeType}setFromCenterAndSize(t,e){return t&&this._center.copy(t),e&&this._size.copy(e),this}get center(){return this._center}set center(t){this._center.copy(t)}get size(){return this._size}set size(t){this._size.copy(t),this._halfSize.copy(t).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(t,e){return null}};let rs=jr;n(rs,"v3_help_0"),n(rs,"helpMatrix"),n(rs,"helpRay");var XC=Object.defineProperty,KC=Object.getOwnPropertyDescriptor,WC=(t,e,i,r)=>{for(var s=r>1?void 0:r?KC(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&XC(e,i,s),s};let us=class extends Zt{constructor(){super(...arguments),n(this,"jointMatrixIndexTableBuffer"),n(this,"playBlendShapeLoop",!1),n(this,"inverseBindMatrices"),n(this,"_avatar"),n(this,"_rendererList"),n(this,"propertyCache"),n(this,"_clips"),n(this,"_clipsMap"),n(this,"_currentSkeletonClip"),n(this,"_currentBlendAnimClip"),n(this,"_skeletonTime",0),n(this,"_blendShapeTime",0),n(this,"_skeletonSpeed",1),n(this,"_blendShapeSpeed",1),n(this,"_skeletonStart",!0),n(this,"_blendShapeStart",!0),n(this,"root"),n(this,"_avatarName"),n(this,"skeltonPoseObject3D",{}),n(this,"skeltonTPoseObject3D",{})}init(t){this.propertyCache=new Map,this._clipsMap=new Map,this._clips=[]}start(){this._rendererList=this.object3D.getComponentsInChild(Va)}debug(){}playAnim(t,e=0,i=1){this._clipsMap.has(t)?(this._currentSkeletonClip=this._clipsMap.get(t),this._skeletonTime=e,this._skeletonSpeed=i,this._skeletonStart=!0):console.warn(`not has anim ${t}`)}playBlendShape(t,e=0,i=1){this._clipsMap.has(t)?(this._currentBlendAnimClip=this._clipsMap.get(t),this._blendShapeTime=e,this._blendShapeSpeed=i,this._blendShapeStart=!0):console.warn(`not has blendShape ${t}`)}set avatar(t){this._avatarName=t,this.inverseBindMatrices=[],this._avatar=I.res.getObj(t);let e=this.buildSkeletonPose();const i=new Float32Array(e);this.jointMatrixIndexTableBuffer=new At(this._avatar.count,0,i)}getJointIndexTable(t){let e=new Array;for(let i=0;i<t.length;i++){let r=this._avatar.boneMap.get(t[i]);e[i]=r?r.boneID:-1}return e}buildSkeletonPose(){let t=[];for(const e of this._avatar.boneData){let i=new me;te.getEuler(p.HELP_6,e.q,!0,"ZYX"),i.localPosition=e.t.clone(),i.localRotation=p.HELP_6.clone(),i.localScale=p.ONE,e.s.clone(),this.skeltonPoseObject3D[e.boneName]=i,this.skeltonTPoseObject3D[e.bonePath]=i.clone(),e.parentBoneName&&e.parentBoneName!=""?this.skeltonPoseObject3D[e.parentBoneName].addChild(i):(this.object3D.transform.scene3D&&this.object3D.transform.scene3D.addChild(i),this.root=i),t.push(i.transform.worldMatrix.index);let r=new te;r.copyFrom(i.transform.worldMatrix),r.invert(),this.inverseBindMatrices.push(r.rawData)}return t}set clips(t){this._clips=t;for(const e of t)this._clipsMap.set(e.clipName,e)}get clips(){return this._clips}cloneTo(t){let e=t.addComponent(us);e.avatar=this._avatarName,e.clips=this._clips}updateTime(){this._skeletonStart&&(this._skeletonTime+=He.delta*.001*this._skeletonSpeed,this._currentSkeletonClip&&this._currentSkeletonClip.loopTime&&(this._skeletonTime=this._skeletonTime%this._currentSkeletonClip.stopTime)),this._blendShapeStart&&(this._blendShapeTime+=He.delta*.001*this._blendShapeSpeed,this._currentBlendAnimClip&&(this._currentBlendAnimClip.loopTime&&this.playBlendShapeLoop?this._blendShapeTime=this._blendShapeTime%this._currentBlendAnimClip.stopTime:this._blendShapeTime=Math.min(this._blendShapeTime,this._currentBlendAnimClip.stopTime)-1e-4))}onUpdate(t){this.transform.worldMatrix,this.updateTime(),this.updateSkeletonAnim(),this.updateMorphAnim()}updateSkeletonAnim(){if(this._currentSkeletonClip){let t=this._avatar.boneData,e=0,i=t.length;for(e=0;e<i;e++){const r=t[e];let s=this.skeltonPoseObject3D[r.boneName];if(this._currentSkeletonClip.useSkeletonPos){let o=this.getPosition(r.bonePath,this._skeletonTime);s.transform.localPosition=o}let a=this.getRotation(r.bonePath,this._skeletonTime);if(s.transform.localRotation=a,this._currentSkeletonClip.useSkeletonScale){let o=this.getScale(r.bonePath,this._skeletonTime);s.transform.localScale=o}}}}updateMorphAnim(){if(this._currentBlendAnimClip&&this._currentBlendAnimClip.floatCurves&&this._currentBlendAnimClip.floatCurves.size>0&&this._rendererList)for(const t of this._currentBlendAnimClip.floatCurves){let e=t[0],i=t[1].propertys,r=this._currentBlendAnimClip.floatCurves.get(e).getValue(this._blendShapeTime)/100;for(const s of this._rendererList)if(s.blendShape){let a=this.propertyCache.get(s);if(a&&e in a)a[e](r);else{a=s;for(const o of i){if(!a[o])break;a=a[o]}if(!a||a==s)break;this.propertyCache.get(s)||this.propertyCache.set(s,{}),this.propertyCache.get(s)[e]=a,a(r)}}}}updateBlendShape(t,e,i){for(const r of this._rendererList)if(r.blendShape){let s=this.propertyCache.get(r);if(s&&e in s)s[e](i);else{s=r;for(const a of t){if(!s[a])break;s=s[a]}if(!s||s==r)break;this.propertyCache.get(r)||this.propertyCache.set(r,{}),this.propertyCache.get(r)[e]=s,s(i)}}}getPosition(t,e){return this._currentSkeletonClip.positionCurves.has(t)?this._currentSkeletonClip.positionCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localPosition}getRotation(t,e){if(this._currentSkeletonClip.rotationCurves.has(t)){let i=this._currentSkeletonClip.rotationCurves.get(t).getValue(e);return ye.HELP_2.set(i.x,i.y,i.z,i.w),te.getEuler(p.HELP_6,ye.HELP_2,!0,"ZYX"),p.HELP_6}return this.skeltonTPoseObject3D[t].localRotation}getScale(t,e){return this._currentSkeletonClip.scaleCurves.has(t)?this._currentSkeletonClip.scaleCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localScale}getFloat(t,e){return this._currentSkeletonClip.floatCurves.get(t).getValue(e)}};us=WC([Ci(us,"AnimatorComponent")],us);class jC{constructor(){n(this,"index"),n(this,"time"),n(this,"timeEnd"),n(this,"coeff",[])}}var qr=(t=>(t[t.PingPong=0]="PingPong",t[t.Repeat=1]="Repeat",t[t.Clamp=2]="Clamp",t))(qr||{});class Kl{constructor(e=0,i=0){n(this,"serializedVersion","2"),n(this,"time"),n(this,"value"),n(this,"inSlope",0),n(this,"outSlope",0),n(this,"tangentMode",0),n(this,"weightedMode",0),n(this,"inWeight"),n(this,"outWeight"),this.time=e,this.value=i}unSerialized(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inSlope=="Infinity"?NaN:e.inSlope,this.outSlope=e.outSlope=="Infinity"?NaN:e.outSlope}unSerialized2(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inTangent=="Infinity"?NaN:e.inTangent,this.outSlope=e.outTangent=="Infinity"?NaN:e.outTangent}}class qC{constructor(e,i=qr.Repeat,r=qr.Repeat){if(n(this,"_totalTime",1),n(this,"_cache",new jC),n(this,"_cacheOut",{lhsIndex:0,rhsIndex:0}),n(this,"_InvalidateCache",!1),n(this,"curve",[]),n(this,"serializedVersion"),n(this,"preWarpMode"),n(this,"postWarpMode"),n(this,"rotationOrder"),e)for(let s=0;s<e.length;s++){const a=e[s];this.addKeyFrame(a)}this.preWarpMode=i,this.postWarpMode=r}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(e){this.curve.indexOf(e)==-1&&this.curve.push(e),this.calcTotalTime()}removeKeyFrame(e){let i=this.curve.indexOf(e);i!=-1&&this.curve.splice(i,1),this.calcTotalTime()}calculateCacheData(e,i,r,s=0){let a=this.curve,o=a[i],l=a[r];e.index=i,e.time=o.time+s,e.timeEnd=l.time+s,e.index=i;let h,u,c,d,f,g,m;h=l.time-o.time,h=Math.max(h,1e-4),c=l.value-o.value,u=1/(h*h),d=o.outSlope,f=l.inSlope,g=d*h,m=f*h,e.coeff[0]=(g+m-c-c)*u/h,e.coeff[1]=(c+c+c-g-g-m)*u,e.coeff[2]=d,e.coeff[3]=o.value,this.setupStepped(e.coeff,o,l)}getValue(e){return e=this.wrapTime(e),this.findCurve(e,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,e)}getKeyCount(){return this.curve.length}getKey(e){return this.curve[e]}unSerialized(e){this.preWarpMode=e.m_PreInfinity,this.postWarpMode=e.m_PostInfinity,this.rotationOrder=e.m_RotationOrder;let i=e.m_Curve.length;for(let r=0;r<i;r++)this.curve[r]=new Kl,this.curve[r].unSerialized(e.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(e){this.preWarpMode=e.preWrapMode,this.postWarpMode=e.postWrapMode;let i=e.keyFrames||e.keys,r=i.length;for(let s=0;s<r;s++)this.curve[s]=new Kl,this.curve[s].unSerialized2(i[s.toString()]);return this.calcTotalTime(),this}wrapTime(e){let i=this.curve,r=i[0].time,s=i[i.length-1].time;return e<r?this.preWarpMode==qr.Clamp?e=r:this.preWarpMode==qr.PingPong?e=fc(e,r,s):e=gc(e,r,s):e>s&&(this.postWarpMode==qr.Clamp?e=s:this.postWarpMode==qr.PingPong?e=fc(e,r,s):e=gc(e,r,s)),e}evaluateCache(e,i){let r=i-e.time;return r*(r*(r*e.coeff[0]+e.coeff[1])+e.coeff[2])+e.coeff[3]}findCurve(e,i){let r=this.curve;for(let s=1;s<r.length;s++){let a=r[s-1],o=r[s];a.time<=e&&o.time>e&&(i.lhsIndex=s-1,i.rhsIndex=s)}}setupStepped(e,i,r){(isNaN(i.outSlope)||isNaN(r.inSlope))&&(e[0]=0,e[1]=0,e[2]=0,e[3]=i.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let e=0;for(let i of this.curve)i?e=Math.max(e,i.time):console.error(i);this._totalTime=e}static scaleCurveValue(e,i){if(!e._InvalidateCache)for(let r=0;r<e.curve.length;r++){let s=e.curve[r];s.value*=i,s.inSlope*=i,s.outSlope*=i}e.invalidateCache()}}var Sa=(t=>(t[t.Default=0]="Default",t[t.Clamp=1]="Clamp",t[t.Once=1]="Once",t[t.Loop=2]="Loop",t[t.PingPong=4]="PingPong",t[t.ClampForever=8]="ClampForever",t))(Sa||{});class JC{constructor(){n(this,"transform"),n(this,"quaternion"),n(this,"materialColor")}}class tr{static updatePropertyTag(e,i){e.quaternion||(e.quaternion=this.tag_quaternion[i]),e.transform||(e.transform=this.tag_transform[i]),e.materialColor||(e.materialColor=this.tag_materialColor[i])}}n(tr,"Property",{"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"}),n(tr,"Scale",{"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1}),n(tr,"tag_quaternion",{"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0}),n(tr,"tag_materialColor",{"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0}),n(tr,"tag_transform",{"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0});const Wl=class{constructor(t){n(this,"_rootObject3D"),n(this,"_animation"),n(this,"_propertyCache"),n(this,"_currentClip"),n(this,"_frame",0),n(this,"_time",0),n(this,"_isPlaying",!0),n(this,"speed",1),n(this,"_propertyTagDic"),this._rootObject3D=t.object3D,this._animation=t,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(t,e=!0){this._isPlaying=!0,e&&(this._time=0),t!=this._currentClip&&t&&this.parseAnimClip(t),this._currentClip=t,this.validProperty()}parseAnimClip(t){var e;this.reset();for(const i in t.objAnimClip){let r=t.objAnimClip[i],s=this._rootObject3D,a={};if(i==""?s=this._rootObject3D:s=this._rootObject3D.getObjectByName(i),!s)continue;let o=new JC;this._propertyTagDic.set(s,o);let l=r.curve;for(const h in l){tr.updatePropertyTag(o,h);let u=(e=this._propertyCache)[i]||(e[i]={}),c=tr.Property[h].split("."),d=c[0];if(c.length>1){let f=a[d];f||(f=a[d]=s[d]),u[h]={value:f,property:c[1]}}else u[h]={value:s,property:c[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(t,e){if(t=t*.001,e=e*.001,!this._currentClip||this._frame==t||!this._isPlaying)return;this._frame=t;let i=this._time;this._time=this.calcTime(i+e*this.speed),this.validProperty(),this._currentClip.wrapMode!=Sa.Loop&&this._currentClip.wrapMode!=Sa.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall(Wl.Complete,i,this._time)),this._animation.statusCall(Wl.Seek,i,this._time)}seek(t){return this._time=this.calcTime(t),this._rootObject3D&&this.validProperty(),this}calcTime(t){return this._currentClip.wrapMode==Sa.Loop||this._currentClip.wrapMode==Sa.Default?t=Bf(t,this._currentClip.totalTime):t=ni(t,0,this._currentClip.totalTime),t}validProperty(){for(const t in this._currentClip.objAnimClip){let e=this._currentClip.objAnimClip[t].curve;for(const i in e){const r=e[i];let s=this._propertyCache[t][i],a=r.getValue(this._time);i in tr.Scale&&(a*=tr.Scale[i]),s.value[s.property]=a}}this._propertyTagDic.forEach((t,e)=>{this.applyProperty(t,e)})}applyProperty(t,e){t.quaternion&&te.getEuler(e.transform.localRotation,e.transform.localRotQuat,!0,"ZYX"),t.transform&&(e.transform.localPosition=e.transform.localPosition,e.transform.localRotation=e.transform.localRotation,e.transform.localScale=e.transform.localScale);let i=e;t.materialColor&&i.notifyMaterialColorChange(0,"baseColor")}};let Bc=Wl;n(Bc,"Complete",0),n(Bc,"Seek",1);class Dc extends Tt{constructor(e,i){super(i),n(this,"animation"),n(this,"frame"),this.animation=e}}n(Dc,"SEEK","SEEK"),n(Dc,"COMPLETE","COMPLETE");var ZC=Object.defineProperty,$C=Object.getOwnPropertyDescriptor,e2=(t,e,i,r)=>{for(var s=r>1?void 0:r?$C(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&ZC(e,i,s),s};let Va=class extends Pe{constructor(){super(),n(this,"skinJointsName"),n(this,"mInverseBindMatrixData"),n(this,"mInverseBindMatrixBuffer"),n(this,"mSkeletonAnimation"),n(this,"mJointIndexTableBuffer"),this.addRendererMask(vt.SkinnedMesh)}get geometry(){return this._geometry}set geometry(t){this.skinJointsName=t.skinNames;let e=[];for(let i=0;i<t.bindPose.length;i++)e.push(t.bindPose[i].rawData.slice(0,16));this.skinInverseBindMatrices=e,super.geometry=t}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(us),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(us);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(us),e.parent&&(e=e.parent.object3D)}}get blendShape(){return this.morphData}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new At(e.length,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let i=0;i<t.length;i++){let r=i*16,s=t[i];e.set(s,r)}this.mInverseBindMatrixBuffer=new At(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(Va),i=[];for(const r of this.materials)i.push(r.clone());e.materials=i,e.geometry=this.geometry,e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,i,r){for(let s=0;s<this.materials.length;s++){let a=this.materials[s].getPass(e);if(a)for(let o=0;o<a.length;o++){const l=a[o];!l.pipeline&&this.mSkeletonAnimation&&(l.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),l.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),l.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,i,r)}};Va=e2([Ci(Va,"SkinnedMeshRenderer2")],Va);var t2=(t=>(t.mouthRollLower="mouthRollLower",t.browOuterUp_L="browOuterUpLeft",t.mouthSmile_L="mouthSmileLeft",t.jawRight="jawRight",t.eyeLookOut_L="eyeLookOutLeft",t.mouthFunnel="mouthFunnel",t.mouthUpperUp_R="mouthUpperUpRight",t.browDown_L="browDownLeft",t.jawLeft="jawLeft",t.mouthLowerDown_L="mouthLowerDownLeft",t.noseSneer_R="noseSneerRight",t.jawForward="jawForward",t.mouthLowerDown_R="mouthLowerDownRight",t.browInnerUp="browInnerUp",t.mouthRollUpper="mouthRollUpper",t.mouthStretch_R="mouthStretchRight",t.mouthPucker="mouthPucker",t.eyeBlink_L="eyeBlinkLeft",t.mouthUpperUp_L="mouthUpperUpLeft",t.mouthShrugUpper="mouthShrugUpper",t.eyeLookIn_R="eyeLookInRight",t.noseSneer_L="noseSneerLeft",t.mouthFrown_L="mouthFrownLeft",t.cheekSquint_L="cheekSquintLeft",t.eyeLookDown_L="eyeLookDownLeft",t.mouthDimple_L="mouthDimpleLeft",t.mouthFrown_R="mouthFrownRight",t.eyeLookIn_L="eyeLookInLeft",t.eyeLookOut_R="eyeLookOutRight",t.mouthLeft="mouthLeft",t.mouthStretch_L="mouthStretchLeft",t.mouthPress_L="mouthPressLeft",t.mouthDimple_R="mouthDimpleRight",t.eyeWide_R="eyeWideRight",t.browDown_R="browDownRight",t.eyeLookUp_R="eyeLookUpRight",t.eyeBlink_R="eyeBlinkRight",t.cheekSquint_R="cheekSquintRight",t.mouthRight="mouthDimpleRight",t.eyeLookDown_R="eyeLookDownRight",t.eyeLookUp_L="eyeLookUpLeft",t.eyeSquint_L="eyeSquintLeft",t.jawOpen="jawOpen",t.browOuterUp_R="browOuterUpRight",t.mouthClose="mouthClose",t.mouthShrugLower="mouthShrugLower",t.eyeWide_L="eyeWideLeft",t.tongueOut="tongueOut",t.eyeSquint_R="eyeSquintRight",t.cheekPuff="cheekPuff",t.mouthPress_R="mouthPressRight",t.mouthSmile_R="mouthSmileRight",t))(t2||{}),i2=(t=>(t[t.Key_BackSpace=8]="Key_BackSpace",t[t.Key_Tab=9]="Key_Tab",t[t.Key_Clear=12]="Key_Clear",t[t.Key_Enter=13]="Key_Enter",t[t.Key_Shift_L=16]="Key_Shift_L",t[t.Key_Control_L=17]="Key_Control_L",t[t.Key_Alt_L=18]="Key_Alt_L",t[t.Key_Pause=19]="Key_Pause",t[t.Key_CapsLock=20]="Key_CapsLock",t[t.Key_Escape=21]="Key_Escape",t[t.Key_Esc=27]="Key_Esc",t[t.Key_Space=32]="Key_Space",t[t.Key_Prior=33]="Key_Prior",t[t.Key_Next=34]="Key_Next",t[t.Key_End=35]="Key_End",t[t.Key_Home=36]="Key_Home",t[t.Key_Left=37]="Key_Left",t[t.Key_Up=38]="Key_Up",t[t.Key_Right=39]="Key_Right",t[t.Key_Down=40]="Key_Down",t[t.Key_Select=41]="Key_Select",t[t.Key_Print=42]="Key_Print",t[t.Key_Execute=43]="Key_Execute",t[t.Key_Insert=45]="Key_Insert",t[t.Key_Delete=46]="Key_Delete",t[t.Key_Help=47]="Key_Help",t[t.Key_0=48]="Key_0",t[t.Key_1=49]="Key_1",t[t.Key_2=50]="Key_2",t[t.Key_3=51]="Key_3",t[t.Key_4=52]="Key_4",t[t.Key_5=53]="Key_5",t[t.Key_6=54]="Key_6",t[t.Key_7=55]="Key_7",t[t.Key_8=56]="Key_8",t[t.Key_9=57]="Key_9",t[t.Key_A=65]="Key_A",t[t.Key_B=66]="Key_B",t[t.Key_C=67]="Key_C",t[t.Key_D=68]="Key_D",t[t.Key_E=69]="Key_E",t[t.Key_F=70]="Key_F",t[t.Key_G=71]="Key_G",t[t.Key_H=72]="Key_H",t[t.Key_I=73]="Key_I",t[t.Key_J=74]="Key_J",t[t.Key_K=75]="Key_K",t[t.Key_L=76]="Key_L",t[t.Key_M=77]="Key_M",t[t.Key_N=78]="Key_N",t[t.Key_O=79]="Key_O",t[t.Key_P=80]="Key_P",t[t.Key_Q=81]="Key_Q",t[t.Key_R=82]="Key_R",t[t.Key_S=83]="Key_S",t[t.Key_T=84]="Key_T",t[t.Key_U=85]="Key_U",t[t.Key_V=86]="Key_V",t[t.Key_W=87]="Key_W",t[t.Key_X=88]="Key_X",t[t.Key_Y=89]="Key_Y",t[t.Key_Z=90]="Key_Z",t[t.Key_KP_0=96]="Key_KP_0",t[t.Key_KP_1=97]="Key_KP_1",t[t.Key_KP_2=98]="Key_KP_2",t[t.Key_KP_3=99]="Key_KP_3",t[t.Key_KP_4=100]="Key_KP_4",t[t.Key_KP_5=101]="Key_KP_5",t[t.Key_KP_6=102]="Key_KP_6",t[t.Key_KP_7=103]="Key_KP_7",t[t.Key_KP_8=104]="Key_KP_8",t[t.Key_KP_9=105]="Key_KP_9",t[t.Key_Multiply=106]="Key_Multiply",t[t.Key_Add=107]="Key_Add",t[t.Key_Separator=108]="Key_Separator",t[t.Key_Subtract=109]="Key_Subtract",t[t.Key_Decimal=110]="Key_Decimal",t[t.Key_Divide=111]="Key_Divide",t[t.Key_F1=112]="Key_F1",t[t.Key_F2=113]="Key_F2",t[t.Key_F3=114]="Key_F3",t[t.Key_F4=115]="Key_F4",t[t.Key_F5=116]="Key_F5",t[t.Key_F6=117]="Key_F6",t[t.Key_F7=118]="Key_F7",t[t.Key_F8=119]="Key_F8",t[t.Key_F9=120]="Key_F9",t[t.Key_F10=121]="Key_F10",t[t.Key_F11=122]="Key_F11",t[t.Key_F12=123]="Key_F12",t[t.Key_F13=124]="Key_F13",t[t.Key_F14=125]="Key_F14",t[t.Key_F15=126]="Key_F15",t[t.Key_F16=127]="Key_F16",t[t.Key_F17=128]="Key_F17",t[t.Key_F18=129]="Key_F18",t[t.Key_F19=130]="Key_F19",t[t.Key_F20=131]="Key_F20",t[t.Key_F21=132]="Key_F21",t[t.Key_F22=133]="Key_F22",t[t.Key_F23=134]="Key_F23",t[t.Key_F24=135]="Key_F24",t[t.Key_Num_Lock=136]="Key_Num_Lock",t[t.Key_Scroll_Lock=137]="Key_Scroll_Lock",t))(i2||{});class vn{static add(e,i,r){return r||(r=new p),r.x=e.x+i.x,r.y=e.y+i.y,r.z=e.z+i.z,r}static sub(e,i,r){return r||(r=new p),r.x=e.x-i.x,r.y=e.y-i.y,r.z=e.z-i.z,r}static mul(e,i,r){return r||(r=new p),r.x=e.x*i.x,r.y=e.y*i.y,r.z=e.z*i.z,r}static mulScale(e,i,r){return r||(r=new p),r.x=e.x*i,r.y=e.y*i,r.z=e.z*i,r}static div(e,i,r){return r||(r=new p),r.x=e.x/i.x,r.y=e.y/i.y,r.z=e.z/i.z,r}static normalize(e){return e.clone().normalize()}static dot(e,i){let r=p.HELP_0;return r.copyFrom(e),r.dotProduct(i)}static calculateVectorAngle_xz(e,i){return Math.acos((e.x*i.x+e.y*i.y)/Math.sqrt((e.x*e.x+e.y*e.y)*(i.x*i.x+i.y*i.y)))}static distance(e,i){return p.distance(e,i)}static getRandomXYZ(e=-100,i=100){return new p(Math.random()*(i-e)+e,Math.random()*(i-e)+e,Math.random()*(i-e)+e)}static getRandomV3(e=-100,i=100,r,s){return new p(Math.random()*i+e,Math.random()*s+r,Math.random()*i+e)}static sphere(e){let i=e*Math.random(),r=new p(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(i),r}static sphereXYZ(e,i,r=1,s=1,a=1){let o=e+(i-e)*Math.random(),l=new p(Math.random()*r-r*.5,Math.random()*s-s*.5,Math.random()*a-a*.5);return l.normalize(),l.scaleBy(o),l}}class r2 extends Zt{constructor(){super(),n(this,"camera"),n(this,"minDistance",.1),n(this,"maxDistance",500),n(this,"rollSmooth",15),n(this,"dragSmooth",20),n(this,"wheelSmooth",10),n(this,"wheelStep",.002),n(this,"mouseRightFactor",.5),n(this,"mouseLeftFactor",20),n(this,"smooth",!0),n(this,"_wheelStep",.002),n(this,"_distance",0),n(this,"distance",10),n(this,"_roll",0),n(this,"roll",0),n(this,"_pitch",0),n(this,"pitch",0),n(this,"_currentPos"),n(this,"_targetPos"),n(this,"_flowTarget"),n(this,"_flowOffset"),n(this,"_mouseLeftDown",!1),n(this,"_mouseRightDown",!1),n(this,"_bottomClamp",89.99),n(this,"_topClamp",-89.99),n(this,"_tempDir",new p),n(this,"_tempPos",new p),this._currentPos=new me,this._targetPos=new me}start(){this.camera=this.object3D.getOrAddComponent(Lh),I.inputSystem.addEventListener(j.POINTER_DOWN,this.onMouseDown,this),I.inputSystem.addEventListener(j.POINTER_MOVE,this.onMouseMove,this),I.inputSystem.addEventListener(j.POINTER_UP,this.onMouseUp,this),I.inputSystem.addEventListener(j.POINTER_WHEEL,this.onMouseWheel,this)}flowTarget(e,i=p.ZERO){this._flowTarget=e,this._flowOffset||(this._flowOffset=new p),this._flowOffset.copyFrom(i)}getFlowTarget(){return this._flowTarget}setCamera(e,i,r,s){this.roll=e,this.pitch=i,this.distance=r,this.maxDistance<r*1.5&&(this.maxDistance=r*1.5),s&&this._targetPos.transform.localPosition.copy(s)}focusByBounds(e){let i=xr.genMeshBounds(e);this.target=i.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*vn.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=I.inputSystem.wheelDelta*this._wheelStep,this.distance=ni(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){if(this.enable){if(this._mouseRightDown){let i=.25,r=this.camera.transform.forward;vn.mulScale(r,e.movementY*i*this.camera.aspect,p.HELP_1),this._targetPos.x+=p.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=p.HELP_1.z*this.mouseRightFactor;let s=this.camera.transform.right;vn.mulScale(s,-e.movementX*i,p.HELP_1),this._targetPos.x-=p.HELP_1.x*this.mouseRightFactor,this._targetPos.z-=p.HELP_1.z*this.mouseRightFactor}this._mouseLeftDown&&(this.roll-=e.movementX*He.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*He.delta*.001*this.mouseLeftFactor,this.pitch=ni(this.pitch,this._topClamp,this._bottomClamp))}}onBeforeUpdate(e){if(!this.enable)return;this._flowTarget&&(p.HELP_0.copyFrom(this._flowTarget.transform.worldPosition),p.HELP_0.add(this._flowOffset,p.HELP_0),this.target=p.HELP_0);let i=ni(He.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*i*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*i*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*i*this.dragSmooth,this._distance+=(this.distance-this._distance)*i*this.wheelSmooth,this._roll+=(this.roll-this._roll)*i*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*i*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let r=ye.HELP_0;r.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(r),this._tempPos=vn.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.transform.lookAt(this._tempPos,this._currentPos.transform.localPosition,p.UP),this.camera.lookTarget.copy(this._currentPos.transform.localPosition)}destroy(e){I.inputSystem.removeEventListener(j.POINTER_DOWN,this.onMouseDown,this),I.inputSystem.removeEventListener(j.POINTER_MOVE,this.onMouseMove,this),I.inputSystem.removeEventListener(j.POINTER_UP,this.onMouseUp,this),I.inputSystem.removeEventListener(j.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null,this._flowTarget=null}}var Ea=(t=>(t[t.NORMAL=0]="NORMAL",t[t.DOWN=1]="DOWN",t[t.OVER=2]="OVER",t[t.DISABLE=3]="DISABLE",t))(Ea||{});let s2=Math.PI,Rc=s2*2;class zs{constructor(e=1,i=0,r=0,s=1,a=0,o=0){n(this,"a"),n(this,"b"),n(this,"c"),n(this,"d"),n(this,"tx"),n(this,"ty"),this.a=e,this.b=i,this.c=r,this.d=s,this.tx=a,this.ty=o}clone(){return new zs(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(e){let i=this.a,r=this.c,s=this.tx;this.a=i*e.a+this.b*e.c,this.b=i*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d,this.tx=s*e.a+this.ty*e.c+e.tx,this.ty=s*e.b+this.ty*e.d+e.ty}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(e){if(e=+e,e!==0){e=e*We;let i=Math.cos(e),r=Math.sin(e),s=this.a,a=this.b,o=this.c,l=this.d,h=this.tx,u=this.ty;this.a=s*i-a*r,this.b=s*r+a*i,this.c=o*i-l*r,this.d=o*r+l*i,this.tx=h*i-u*r,this.ty=h*r+u*i}}scale(e,i){e!==1&&(this.a*=e,this.c*=e,this.tx*=e),i!==1&&(this.b*=i,this.d*=i,this.ty*=i)}setTo(e,i,r,s,a,o){return this.a=e,this.b=i,this.c=r,this.d=s,this.tx=a,this.ty=o,this}transformPoint(e,i,r){let s=this.a*e+this.c*i+this.tx,a=this.b*e+this.d*i+this.ty;return r?(r.setTo(s,a,0,1),r):new p(s,a,0,1)}setTranslate(e,i){this.tx=e,this.ty=i}translate(e,i){this.tx+=e,this.ty+=i}mul(e){let i=this,r=e,s=i.a,a=i.b,o=i.c,l=i.d,h=i.tx,u=i.ty,c=r.a,d=r.b,f=r.c,g=r.d,m=r.tx,A=r.ty;d!==0||f!==0?(this.a=s*c+a*f,this.b=s*d+a*g,this.c=o*c+l*f,this.d=o*d+l*g,this.tx=c*h+f*u+m,this.ty=d*h+g*u+A):(this.a=s*c,this.b=a*g,this.c=o*c,this.d=l*g,this.tx=c*h+m,this.ty=g*u+A)}equals(e){return this.a==e.a&&this.b==e.b&&this.c==e.c&&this.d==e.d&&this.tx==e.tx&&this.ty==e.ty}prepend(e,i,r,s,a,o){let l=this.tx;if(e!=1||i!=0||r!=0||s!=1){let h=this.a,u=this.c;this.a=h*e+this.b*r,this.b=h*i+this.b*s,this.c=u*e+this.d*r,this.d=u*i+this.d*s}return this.tx=l*e+this.ty*r+a,this.ty=l*i+this.ty*s+o,this}append(e){let i=this.a,r=this.b,s=this.c,a=this.d;return(e.a!=1||e.b!=0||e.c!=0||e.d!=1)&&(this.a=e.a*i+e.b*s,this.b=e.a*r+e.b*a,this.c=e.c*i+e.d*s,this.d=e.c*r+e.d*a),this.tx=e.tx*i+e.ty*s+this.tx,this.ty=e.tx*r+e.ty*a+this.ty,this}deltaTransformPoint(e){let i=this,r=i.a*e.x+i.c*e.y,s=i.b*e.x+i.d*e.y;return new p(r,s)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(e,i,r=0,s=0,a=0){let o=this;if(r!==0){r=r*We;let l=Math.cos(r),h=Math.sin(r);o.a=l*e,o.b=h*i,o.c=-h*e,o.d=l*i}else o.a=e,o.b=0,o.c=0,o.d=i;o.tx=s,o.ty=a}createGradientBox(e,i,r=0,s=0,a=0){this.createBox(e/1638.4,i/1638.4,r,s+e/2,a+i/2)}_invertInto(e){let i=this.a,r=this.b,s=this.c,a=this.d,o=this.tx,l=this.ty;if(r==0&&s==0){e.b=e.c=0,i==0||a==0?e.a=e.d=e.tx=e.ty=0:(i=e.a=1/i,a=e.d=1/a,e.tx=-i*o,e.ty=-a*l);return}let h=i*a-r*s;if(h==0){e.identity();return}h=1/h;let u=e.a=a*h;r=e.b=-r*h,s=e.c=-s*h,a=e.d=i*h,e.tx=-(u*o+s*l),e.ty=-(r*o+a*l)}getScaleX(){let e=this;if(e.a==1&&e.b==0)return 1;let i=Math.sqrt(e.a*e.a+e.b*e.b);return this.getDeterminant()<0?-i:i}getScaleY(){let e=this;if(e.c==0&&e.d==1)return 1;let i=Math.sqrt(e.c*e.c+e.d*e.d);return this.getDeterminant()<0?-i:i}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(e,i,r,s){if((r==0||r==Rc)&&(s==0||s==Rc)){this.a=e,this.b=this.c=0,this.d=i;return}r=r*We,s=s*We;let a=Math.cos(r),o=Math.sin(r);r==s?(this.a=a*e,this.b=o*e):(this.a=Math.cos(s)*e,this.b=Math.sin(s)*e),this.c=-o*i,this.d=a*i}preMultiplyInto(e,i){let r=e.a*this.a,s=0,a=0,o=e.d*this.d,l=e.tx*this.a+this.tx,h=e.ty*this.d+this.ty;(e.b!==0||e.c!==0||this.b!==0||this.c!==0)&&(r+=e.b*this.c,o+=e.c*this.b,s+=e.a*this.b+e.b*this.d,a+=e.c*this.a+e.d*this.c,l+=e.ty*this.c,h+=e.tx*this.b),i.a=r,i.b=s,i.c=a,i.d=o,i.tx=l,i.ty=h}$transformBounds(e){let i=this.a,r=this.b,s=this.c,a=this.d,o=this.tx,l=this.ty,h=e.x,u=e.y,c=h+e.width,d=u+e.height,f=i*h+s*u+o,g=r*h+a*u+l,m=i*c+s*u+o,A=r*c+a*u+l,_=i*c+s*d+o,x=r*c+a*d+l,b=i*h+s*d+o,R=r*h+a*d+l,E=0;f>m&&(E=f,f=m,m=E),_>b&&(E=_,_=b,b=E),e.x=Math.floor(f<_?f:_),e.width=Math.ceil((m>b?m:b)-e.x),g>A&&(E=g,g=A,A=E),x>R&&(E=x,x=R,R=E),e.y=Math.floor(g<x?g:x),e.height=Math.ceil((A>R?A:R)-e.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class Uo extends Zt{constructor(){super(...arguments),n(this,"isGUICanvas",!0),n(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(Uo).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var lt=(t=>(t[t.NONE=0]="NONE",t[t.POSITION=1]="POSITION",t[t.SPRITE=2]="SPRITE",t[t.COLOR=4]="COLOR",t[t.MAX=7]="MAX",t))(lt||{});class Jo{constructor(e){n(this,"array"),n(this,"buffer"),this.buffer=new At(e,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class a2 extends wt{constructor(e){super(),n(this,"_attributeUV"),n(this,"_attributeVIndex"),n(this,"_faceIndexes"),n(this,"_uvSize",2),n(this,"_vIndexSize",1),n(this,"_posAttribute"),n(this,"_spriteAttribute"),n(this,"_colorAttribute"),n(this,"_onPositionChange",!0),n(this,"_onSpriteChange",!0),n(this,"_onColorChange",!0),n(this,"maxQuadCount"),this.maxQuadCount=e}updateSubGeometry(e,i,r){let s=this.subGeometries[e];if(s){let a=s.lodLevels[0];a.indexStart=i,a.indexCount=r,a.index=e}else s=this.addSubGeometry({indexStart:i,indexCount:r,vertexStart:0,vertexCount:0,firstStart:0,index:e,topology:0});return s}resetSubGeometries(){for(let e of this.subGeometries){let i=e.lodLevels[0];i.indexStart=0,i.indexCount=0,i.index=0}}updateBounds(e,i){let r=Number.MAX_VALUE*.1;return e=new p(-r,-r,-r),i=new p(r,r,r),this.bounds.setFromMinMax(e,i),this}getPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}getSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}getColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,i=[],r=[];for(let a=0;a<e;a++)i.push(...$i.attUV);for(let a=0,o=this.maxQuadCount*$i.vertexCount;a<o;a++)r[a]=a;this._attributeUV=new Float32Array($i.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array($i.vertexCount*e*this._vIndexSize),this._attributeUV.set(i,0),this._attributeVIndex.set(r,0);let s=[];for(let a=0;a<e;a++)for(let o=0;o<$i.indecies.length;o++){const l=$i.indecies[o]+a*4;s.push(l)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(s,0),this.setIndices(this._faceIndexes),this.setAttribute(z.uv,this._attributeUV),this.setAttribute(z.vIndex,this._attributeVIndex),this.updateSubGeometry(0,0,this._faceIndexes.length),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new Jo(e*4),this._spriteAttribute=new Jo(e*(4+4+2+2)),this._colorAttribute=new Jo(e*4)}fillQuad(e,i){e.dirtyAttributes&lt.POSITION&&this.fillQuadPosition(e,i),e.dirtyAttributes&lt.COLOR&&this.fillQuadColor(e,i),e.dirtyAttributes&lt.SPRITE&&this.fillQuadSprite(e,i)}fillQuadPosition(e,i){Mc.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,i){let r=e.color,s=this._colorAttribute.array;Mc.setXYZW(s,e.z,r.r,r.g,r.b,r.a),this._onColorChange=!0}fillQuadSprite(e,i){let r=e.sprite,s=0,a=0;r.isSliced&&e.imageType==lo.Sliced&&(s=r.trimSize.x,s=(i.width-(r.offsetSize.z-r.trimSize.x))/s,a=r.trimSize.y,a=(i.height-(r.offsetSize.w-r.trimSize.y))/a);let o=r.guiTexture.dynamicId,l=r.uvRec,h=r.uvBorder,u=this._spriteAttribute.array,c=(4+4+2+2)*e.z;u[c+0]=l.x,u[c+1]=l.y,u[c+2]=l.z,u[c+3]=l.w,u[c+4]=h.x,u[c+5]=h.y,u[c+6]=h.z,u[c+7]=h.w,u[c+8]=s,u[c+9]=a,u[c+10]=o,u[c+11]=e.visible?1:0,this._onSpriteChange=!0}}class n2{static set(e,i,r,s,...a){let o=i*s+r;for(let l=0,h=a.length;l<h;l++)e[o+l]=a[l]}}class Mc extends n2{static setXYZW(e,i,r,s,a,o){this.set(e,i,0,4,r,s,a,o)}static setXYZ(e,i,r,s,a){this.set(e,i,0,4,r,s,a)}static setZ(e,i,r){this.set(e,i,3,4,r)}}class $i{}n($i,"vertexCount",4),n($i,"attUV",[0,0,1,0,1,1,0,1]),n($i,"indecies",[0,1,2,0,2,3]);class o2{constructor(){n(this,"_textureMap",new Map),n(this,"_textureList",[])}build(e,i,r){let s=i._geometry;s.resetSubGeometries();let a=-1,o=0,l=0,h=0,u=0,c=this._textureList,d=this._textureMap;function f(){h>0&&(i.updateDrawCallSegment(u,l,h),i._uiRenderer.materials[u].setTextures(c),d.clear(),c.length=0,u++,l+=h,h=0,o=0)}d.clear(),c.length=0;let g=[],m=i.quadMaxCount-1;for(let A of e){let _=A.needUpdateQuads;g.length=0;const x=this.collectQuads(A.object3D,g);for(let b of x){let R=b.sprite.guiTexture;if(d.has(R.staticId)||(o==7&&f(),d.set(R.staticId,R),R.dynamicId=o,c[o]=R.texture,o+=1),b.z=++a,h+=6,b.cacheTextureId!=R.dynamicId&&(b.dirtyAttributes=lt.MAX,b.cacheTextureId=R.dynamicId),(_||r)&&(b.dirtyAttributes=lt.MAX),b.dirtyAttributes&lt.POSITION&&b.applyTransform(A),b.dirtyAttributes&&b.writeToGeometry(s,A),a==m)return f(),!0}}return f(),!1}collectQuads(e,i){i||(i=[]);let r=e.components.values();for(let s of r){let a=s;if(a.isUIShadow||!a.mainQuads)continue;let o=a.getShadowRender();o&&this.push(o.mainQuads,i),this.push(a.mainQuads,i)}return i}push(e,i){e&&e.length>0&&i.push(...e)}}const Yt=class{static bindTextureArray(){let t="";for(let e=0;e<7;e++)t+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return t}static sampleTexture(t){return`
#if VideoTexture${t}
            let size = textureDimensions(tex_${t}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${t}, iuv) ;
#else
            color = textureSampleLevel(tex_${t}, tex_${t}Sampler, uv, 0.0);
#endif        `}};let Ps=Yt;n(Ps,"fs",`
        ${Tf}
        ${Yt.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${Yt.sampleTexture(0)}
            }else if(texId == 1){
                ${Yt.sampleTexture(1)}
            }else if(texId == 2){
                ${Yt.sampleTexture(2)}
            }else if(texId == 3){            
                ${Yt.sampleTexture(3)}
            }else if(texId == 4){            
                ${Yt.sampleTexture(4)}
            }else if(texId == 5){            
                ${Yt.sampleTexture(5)}
            }else if(texId == 6){            
                ${Yt.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`),n(Ps,"GUI_common_vs",`
        ${Ef}
        ${Sf}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            guiSolution:vec2<f32>,
            
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,
            empty:f32,
        }
        
        struct VertexOutput {
            @location(0) vUV: vec2<f32>,
            @location(1) vColor4: vec4<f32>,
            @location(2) vLocalPos: vec2<f32>,
            @location(3) vUvRec: vec4<f32>,
            @location(4) vUvBorder: vec4<f32>,
            @location(5) vUvSlice: vec2<f32>,
            @location(6) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(0) uv: vec2<f32>,
            @location(1) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),n(Ps,"GUI_shader_view",`
        ${Yt.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${Yt.fs}
        `),n(Ps,"GUI_shader_world",`
        ${Yt.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${Yt.fs}

        `);class Pc extends Yi{constructor(e){super(),n(this,"_scissorRect"),n(this,"_screenSize",new Ne(1024,768)),n(this,"_scissorEnable",!1),n(this,"_videoTextureFlags",{}),W.register("GUI_shader_view",Ps.GUI_shader_view),W.register("GUI_shader_world",Ps.GUI_shader_world);let i=new $t,r=e==Ni.View?"GUI_shader_view":"GUI_shader_world",s=new ct(r,r);s.passType=xe.COLOR,s.setShaderEntry("VertMain","FragMain"),s.setUniformVector2("screenSize",this._screenSize),s.setUniformVector2("guiSolution",this._screenSize),s.setUniformVector4("scissorRect",new oe),s.setUniformFloat("scissorCornerRadius",0),s.setUniformFloat("scissorFadeOutSize",0),s.setUniformFloat("pixelRatio",1),s.setUniformFloat("empty",0);let a=s.shaderState;a.depthWriteEnabled=!1,s.blendMode=Te.ALPHA,s.depthCompare=e==Ni.View?zi.always:zi.less_equal,s.cullMode=zt.back,i.addRenderPass(s),this.shader=i}setGUISolution(e,i){this.shader.setUniformVector2("guiSolution",e),this.shader.setUniformFloat("pixelRatio",i)}setScissorRect(e,i,r,s){this._scissorRect||(this._scissorRect=new oe),this._scissorRect.set(e,i,r,s),this.shader.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.shader.setDefine("SCISSOR_ENABLE",!0):this.shader.deleteDefine("SCISSOR_ENABLE"),this.shader.noticeValueChange())}setScissorCorner(e,i){this.shader.setUniformFloat("scissorCornerRadius",e),this.shader.setUniformFloat("scissorFadeOutSize",i)}setScreenSize(e,i){return this._screenSize.set(e,i),this.shader.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let i=0;i<7;i++){let r=e[i]||I.res.whiteTexture;this.shader.setTexture(`tex_${i}`,r),this.setVideoTextureDefine(i,r.isVideoTexture)}}setVideoTextureDefine(e,i){let r=!1;i!=this._videoTextureFlags[e]&&(i?this.shader.setDefine(`VideoTexture${e}`,!0):this.shader.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=i,r=!0),r&&this.shader.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class l2 extends Pe{constructor(){super(...arguments),n(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(vt.UI),this.removeRendererMask(vt.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,i,r,s){for(let a=0;a<this.materials.length;a++){let o=this.materials[a].getPass(i),l=this._guiGeometry.getPositionBuffer(),h=this._guiGeometry.getSpriteBuffer(),u=this._guiGeometry.getColorBuffer();if(o)for(let c=0;c<o.length;c++){const d=o[c];d.pipeline||(d.setStorageBuffer("vPositionBuffer",l),d.setStorageBuffer("vSpriteBuffer",h),d.setStorageBuffer("vColorBuffer",u))}}super.nodeUpdate(e,i,r,s)}onUpdate(e){}}class h2{constructor(){n(this,"_use"),n(this,"_unUse"),this._use=[],this._unUse=[]}pushBack(e){let i=this._use.indexOf(e);i!=-1&&(this._use.splice(i,1),this._unUse.push(e))}getUseList(){return this._use}getOne(e,i){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new e(i),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let bs;const kn=class{constructor(){n(this,"x",0),n(this,"y",0),n(this,"z",0),n(this,"width",1),n(this,"height",1),n(this,"_globalX",0),n(this,"_globalY",0),n(this,"_globalWidth",0),n(this,"_globalHeight",0),n(this,"_visible",!0),n(this,"_offsetX",0),n(this,"_offsetY",0),n(this,"_sprite",I.res.defaultGUISprite),n(this,"_color",new Y(1,1,1,1)),n(this,"_imageType",lo.Simple),n(this,"dirtyAttributes",lt.MAX),n(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new h2),this.textPool}static recycleQuad(t){t.sprite=null,t.dirtyAttributes=lt.MAX,t.x=0,t.y=0,t.z=-1,t.cacheTextureId=-1,kn.quadPool.pushBack(t)}static spawnQuad(){return kn.quadPool.getOne(kn)}get imageType(){return this._imageType}set imageType(t){this._imageType=t,this.setAttrChange(lt.SPRITE|lt.POSITION)}get color(){return this._color}set color(t){this._color.copyFrom(t),this.setAttrChange(lt.COLOR)}get visible(){return this._visible}set visible(t){t!=this._visible&&(this._visible=t,this.setAttrChange(lt.SPRITE))}get sprite(){return this._sprite}set sprite(t){this._sprite!=t&&(this._sprite=t,this.setAttrChange(lt.SPRITE|lt.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(t,e){this.width=t,this.height=e,this.setAttrChange(lt.POSITION)}setXY(t,e){this.x=t,this.y=e,this.setAttrChange(lt.POSITION)}setAttrChange(t){this.dirtyAttributes=this.dirtyAttributes|t}applyTransform(t){this.setAttrChange(lt.POSITION);let e=this._sprite,i=t.getWorldMatrix();(this.x!=0||this.y!=0)&&(i=this.getQuadMatrix(i));let r=i.getScaleX(),s=i.getScaleY(),a=e.isSliced&&this._imageType==lo.Sliced;if(this._offsetX=t.width*.5*r,this._offsetY=t.height*.5*s,a)this._globalWidth=r*(t.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=s*(t.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=i.tx+e.offsetSize.x*r,this._globalY=i.ty+e.offsetSize.y*s;else{let o=this.width/e.offsetSize.z,l=this.height/e.offsetSize.w;this._globalWidth=r*e.trimSize.x*o,this._globalHeight=s*e.trimSize.y*l,this._globalX=i.tx+e.offsetSize.x*o*r,this._globalY=i.ty+e.offsetSize.y*l*s}return this}getQuadMatrix(t){return bs||(bs=new zs),bs.identity(),bs.setTranslate(this.x,this.y),bs.mul(t),bs}writeToGeometry(t,e){return t.fillQuad(this,e),this.dirtyAttributes=lt.NONE,this}};let Kh=kn;n(Kh,"textPool");class u2 extends Zt{constructor(){super(...arguments),n(this,"_uiTransform"),n(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var i;this._visible!=e&&(this._visible=e,(i=this.onUIComponentVisible)==null||i.call(this,this._visible))}init(e){var i;(i=super.init)==null||i.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(yr),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class c2 extends u2{constructor(){super(...arguments),n(this,"_mainQuads"),n(this,"_shadowRender"),n(this,"_shadowSource"),n(this,"isUIShadow"),n(this,"isShadowless"),n(this,"needUpdateShadow")}init(e){var i;(i=super.init)==null||i.call(this,e),this._mainQuads=[]}destroy(){var e,i;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(i=this._shadowSource)==null||i.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,i){let r=this.object3D.components.values();if(!e)for(let s of r){let a=s;if(!(a.isShadowless||a.isUIShadow)&&a.mainQuads){e=a;break}}if(!i)for(let s of r){let a=s;if(a.isUIShadow&&a.mainQuads){i=a;break}}return e&&i?(e.setShadowRenderer(i),i.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let i=this._mainQuads.indexOf(e);i>=0?(this._mainQuads.splice(i,1),Kh.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Wh extends c2{init(e){var i;(i=super.init)==null||i.call(this,e),this.attachQuad(Kh.spawnQuad()),this.sprite=I.res.defaultGUISprite}cloneTo(e){e.getOrAddComponent(Wh).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.sprite=e.sprite,this.color=e.color,this.imageType=e.imageType,this}set sprite(e){e||(e=I.res.defaultGUISprite);for(let i of this._mainQuads)i.sprite=e,i.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let e of this._mainQuads)e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let i of this._mainQuads)i.visible=!e;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(e){for(let i of this._mainQuads)i.color=e;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(e){for(let i of this._mainQuads)i.imageType=e;this.setShadowDirty()}}class Lo extends Wh{constructor(){super(...arguments),n(this,"space",Ni.World),n(this,"needUpdateGeometry",!0),n(this,"panelOrder",0),n(this,"needSortOnCameraZ"),n(this,"_billboard"),n(this,"_rebuild"),n(this,"scissorEnable",!1),n(this,"scissorCornerRadius",0),n(this,"scissorFadeOutSize",0),n(this,"_uiRenderer"),n(this,"_geometry"),n(this,"_maxCount",128),n(this,"isUIPanel",!0),n(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(Lo).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this.create(this.space),this.visible=!1}updateDrawCallSegment(e,i,r){this._geometry.updateSubGeometry(e,i,r);let s=this._uiRenderer.material,a=this._uiRenderer.materials[e];if(!a){a=new Pc(this.space);let o=this._uiRenderer.materials.slice();o.push(a),this._uiRenderer.materials=o,a.cullMode=s.cullMode,a.depthCompare=s.depthCompare}}create(e){this._maxCount=this.space==Ni.World?Ye.quadMaxCountForWorld:Ye.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(l2),this._geometry=this._uiRenderer.geometry=new a2(this._maxCount).create(),this._uiRenderer.material=new Pc(e),this._uiRenderer.renderOrder=Ye.SortOrderStartWorld,this._rebuild=new o2,this.object3D.bound=new _t(new p,new p(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}set billboard(e){this.space==Ni.View?e=is.None:console.warn("Cannot enable billboard in view space"),e==is.BillboardXYZ||e==is.BillboardY?(this._billboard=this.object3D.getOrAddComponent(ho),this._billboard.type=e):(this.object3D.removeComponent(ho),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:is.None}set cullMode(e){if(this.space==Ni.World)for(let i of this._uiRenderer.materials)i.cullMode=e;else console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var i;(i=super.onUpdate)==null||i.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let i=this,r=i._collectTransform;if(r.length=0,i.object3D.getComponents(yr,r),r.length>0){i._rebuild.build(r,i,i.needUpdateGeometry);for(const l of r)l.needUpdateQuads=!1}let s=i.object3D.getComponentFromParent(Uo),a=s?s.index:0;i._uiRenderer.enable=r.length>0;let o=i.isViewPanel?Ye.SortOrderStartView:Ye.SortOrderStartWorld;i._uiRenderer.renderOrder=a*Ye.SortOrderCanvasSpan+o+i.panelOrder,i._uiRenderer.needSortOnCameraZ=i.needSortOnCameraZ;for(let l of i._uiRenderer.materials){let h=l;if(h.setGUISolution(Ye.solution,Ye.pixelRatio),h.setScreenSize(D.canvas.clientWidth,D.canvas.clientHeight),h.setScissorEnable(i.scissorEnable),i.scissorEnable){let u=i.mainQuads[0];h.setScissorRect(u.left,u.bottom,u.right,u.top),h.setScissorCorner(i.scissorCornerRadius,i.scissorFadeOutSize)}}i.needUpdateGeometry=!1}}class jh extends Lo{constructor(){super(),n(this,"isViewPanel",!0),n(this,"space",Ni.View)}cloneTo(e){e.getOrAddComponent(jh).copyComponent(this)}}class qh extends Lo{constructor(){super(),n(this,"isWorldPanel",!0),n(this,"space",Ni.World),n(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(qh).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let i=this.depthTest?zi.less_equal:zi.always;for(let r of this._uiRenderer.materials)r.depthCompare=i}}}let Zo;class yr extends Zt{constructor(){super(),n(this,"useParentPivot",!1),n(this,"parent"),n(this,"pivotX",.5),n(this,"pivotY",.5),n(this,"_width",100),n(this,"_height",100),n(this,"_localVisible",!0),n(this,"_globalVisible",!0),n(this,"_uiInteractiveList"),n(this,"_localMatrix"),n(this,"_worldMatrix"),n(this,"_onChange",!0),n(this,"needUpdateQuads",!0),n(this,"_tempTransforms",[]),this._localMatrix=new zs,this._worldMatrix=new zs}get uiInteractiveList(){return this._uiInteractiveList}init(e){var i;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(i=this.object3D.parent)==null?void 0:i.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let i=this._uiInteractiveList.indexOf(e);if(i>=0)return this._uiInteractiveList.slice(i,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let i=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&i)}}get visible(){return this._localVisible}onUITransformVisible(e){let i=this._localVisible&&e;i!=this._globalVisible&&(this._globalVisible=i,this.object3D.components.forEach((r,s)=>{let a=r;if(a.onUITransformVisible)if(a==this)for(let o of this.object3D.entityChildren){let l=o.getComponent(yr);l&&l.onUITransformVisible(this._globalVisible)}else a.onUITransformVisible(this._globalVisible)}))}onParentChange(e,i){var r,s;(r=this.parent)==null||r.setNeedUpdateUIPanel(),this.parent=i==null?void 0:i.getComponent(yr),(s=this.parent)==null||s.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,i){var r;if(this._width!=e||this._height!=i){this._width=e,this._height=i,this.onChange=!0;for(let s of this.object3D.components.values())(r=s.onTransformResize)==null||r.call(s);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,i){let r=this.object3D.localPosition;r.set(e,i,r.z),this.object3D.localPosition=r,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let i=this.object3D.getComponents(yr,this._tempTransforms,!0);for(let r of i)r._onChange=!0,r.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(qh),e||(e=this.object3D.getComponentFromParent(jh)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let i=e.getOrAddComponent(yr);i.visible=this.visible,i.x=this.x,i.y=this.y,i.z=this.z,i.resize(this.width,this.height),i.pivotX=this.pivotX,i.pivotY=this.pivotY,i.scaleX=this.scaleX,i.scaleY=this.scaleY}matrix(){let e=this._localMatrix,i=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,i,i),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(Zo||(Zo=new zs().identity()),e.mul(Zo.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,i=e._worldMatrix;return this._onChange&&(i.copyFrom(e.matrix()),e.parent&&i.mul(e.parent.getWorldMatrix()),e._onChange=!1),i}beforeDestroy(e){var i;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(i=super.beforeDestroy)==null||i.call(this,e)}}class d2{constructor(){n(this,"_ray"),n(this,"_mouseCode"),n(this,"_clickEvent"),n(this,"_outEvent"),n(this,"_overEvent"),n(this,"_upEvent"),n(this,"_downEvent"),n(this,"_view"),n(this,"_lastDownTarget"),n(this,"_lastOverTarget"),n(this,"_lastDownPosition",new Ne),n(this,"_calcDistanceVec2",new Ne),n(this,"_lastDownTime",0),n(this,"_clickTimeSpan",200),n(this,"_clickDistanceSpan",10),n(this,"_colliderOut",[]),n(this,"_transformList",[]),n(this,"_sortWorldPanelList",[]),n(this,"_iteractive2PanelDict",new Map)}init(e){this._view=e,this._ray=new fs,this._clickEvent=new j(j.PICK_CLICK_GUI),this._outEvent=new j(j.PICK_OUT_GUI),this._overEvent=new j(j.PICK_OVER_GUI),this._upEvent=new j(j.PICK_UP_GUI),this._downEvent=new j(j.PICK_DOWN_GUI),I.inputSystem.addEventListener(j.POINTER_DOWN,this.onTouchDown,this,null,1),I.inputSystem.addEventListener(j.POINTER_UP,this.onTouchUp,this,null,1),I.inputSystem.addEventListener(j.POINTER_MOVE,this.onTouchMove,this,null,1),I.inputSystem.addEventListener(j.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(e){this._lastOverTarget&&e.stopImmediatePropagation()}onTouchMove(e){this._mouseCode=e.mouseCode,this.collectEntities();let i=this.pick(this._colliderOut);i&&e.stopImmediatePropagation();let r=i?i.collider:null;r!=this._lastOverTarget&&(this._lastOverTarget&&this._lastOverTarget.enable&&(this._lastOverTarget.mouseStyle=Ea.NORMAL,this._outEvent.data=this._lastOverTarget,this._lastOverTarget.object3D.dispatchEvent(this._outEvent)),r&&(r.mouseStyle=Ea.OVER,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastOverTarget=r)}onTouchDown(e){this._lastDownTime=He.time,this._lastDownPosition.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let i=this.pick(this._colliderOut);i&&e.stopImmediatePropagation();let r=i?i.collider:null;r&&(r.mouseStyle=Ea.DOWN,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastDownTarget=r}onTouchUp(e){this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let i=this.pick(this._colliderOut);i&&e.stopImmediatePropagation();let r=i?i.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=Ea.NORMAL),r&&r==this._lastDownTarget&&He.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(this._clickEvent.data={pick:r,pickInfo:i,mouseCode:this._mouseCode},r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(e=>{if(e&&e.transform&&e.transform.parent){let i=e.object3D.getComponentsByProperty("isUIPanel",!0,!0);i.sort((r,s)=>{let a=r._uiRenderer.__renderOrder,o=s._uiRenderer.__renderOrder;return a>o?-1:1});for(let r of i){this._transformList.length=0,r.object3D.getComponents(yr,this._transformList),this._transformList.reverse();for(const s of this._transformList){let a=s.uiInteractiveList;if(a&&a.length>0)for(let o of a)this._colliderOut.push(o),this._iteractive2PanelDict.set(o,r)}}}}),this._colliderOut}pick(e){this._ray=this._view.camera.screenPointToRay(I.inputSystem.mouseX,I.inputSystem.mouseY);let i=new Ne(I.inputSystem.mouseX,I.inputSystem.mouseY),r=new Ne(D.canvas.clientWidth,D.canvas.clientHeight),s;for(const a of e)if(a.interactive&&a.enable&&a.interactiveVisible){let o=this._iteractive2PanelDict.get(a);if(s=a.rayPick(this._ray,o,i,r),s)return s.collider=a,s}return null}}var f2=(t=>(t[t.COLLINEAR=0]="COLLINEAR",t[t.LINES_INTERSECT=1]="LINES_INTERSECT",t[t.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",t[t.A_BISECTS_B=3]="A_BISECTS_B",t[t.B_BISECTS_A=4]="B_BISECTS_A",t[t.PARALELL=5]="PARALELL",t))(f2||{}),g2=(t=>(t[t.ON_LINE=0]="ON_LINE",t[t.LEFT_SIDE=1]="LEFT_SIDE",t[t.RIGHT_SIDE=2]="RIGHT_SIDE",t))(g2||{});const Xt=class{constructor(t,e){n(this,"start"),n(this,"end"),n(this,"color",new Y(1,1,1,1)),n(this,"_normal"),n(this,"_normalCalculated",!1),this.start=t,this.end=e}set(t,e){this.start=t,this.end=e}getCenter(){let t=p.HELP_0;return this.start.subtract(this.end,t),t.scaleBy(.5),t.add(this.end),t}inverse(){let t=this.start;this.start=this.end,this.end=t}equals(t){return this.start==t.start&&this.end==t.end||this.start==t.end&&this.end==t.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(t){let e=[];for(let i=0;i<t.length;i++){let r=i,s=Bf(i+1,t.length),a=t[r],o=t[s];e.push(new Xt(a,o))}return e}intersection(t,e=null){var i=(t.end.z-t.start.z)*(this.end.x-this.start.x)-(t.end.x-t.start.x)*(this.end.z-this.start.z),r=(t.end.x-t.start.x)*(this.start.z-t.start.z)-(t.end.z-t.start.z)*(this.start.x-t.start.x),s=(t.start.x-this.start.x)*(this.end.z-this.start.z)-(t.start.z-this.start.z)*(this.end.x-this.start.x);if(i==0)return r==0&&s==0?0:5;r=r/i,s=s/i;var a=this.start.x+r*(this.end.x-this.start.x),o=this.start.z+r*(this.end.z-this.start.z);return e!=null&&(e.x=a,e.y=0,e.z=o),r>=0&&r<=1&&s>=0&&s<=1?2:s>=0&&s<=1?3:r>=0&&r<=1?4:1}getDirection(){var t=this.end.subtract(this.start),e=new p(t.x,t.y);return e.normalize()}copyFrom(t){this.start||(this.start=new p),this.end||(this.end=new p),this.start.copyFrom(t.start),this.end.copyFrom(t.end)}static IsEqual(t,e){return Math.abs(t-e)<1e-7}static squreDistanceSegmentToSegment(t,e,i){let r=t.start,s=t.end,a=e.start,o=e.end,l=r.x,h=r.y,u=r.z,c=s.x,d=s.y,f=s.z,g=a.x,m=a.y,A=a.z,_=o.x,x=o.y,b=o.z,R=c-l,E=d-h,M=f-u,G=_-g,V=x-m,k=b-A,O=l-g,ce=h-m,we=u-A,Ce=R*R+E*E+M*M,be=R*G+E*V+M*k,De=G*G+V*V+k*k,Ee=R*O+E*ce+M*we,he=G*O+V*ce+k*we,_e=Ce*De-be*be,de=_e,et=_e,Qe=0,tt=0;this.IsEqual(_e,0)?(Qe=0,de=1,tt=he,et=De):(Qe=be*he-De*Ee,tt=Ce*he-be*Ee,Qe<0?(Qe=0,tt=he,et=De):Qe>de&&(Qe=de,tt=he+be,et=De)),tt<0?(tt=0,-Ee<0?Qe=0:-Ee>Ce?Qe=de:(Qe=-Ee,de=Ce)):tt>et&&(tt=et,-Ee+be<0?Qe=0:-Ee+be>Ce?Qe=de:(Qe=-Ee+be,de=Ce));let at=0,ei=0;this.IsEqual(Qe,0)?at=0:at=Qe/de,this.IsEqual(tt,0)?ei=0:ei=tt/et;let Ki=O+at*R-ei*G,Qr=ce+at*E-ei*V,ot=we+at*M-ei*k;return Ki*Ki+Qr*Qr+ot*ot}isNear(t,e=0,i){let r=p.HELP_0,s=p.HELP_1;r.copyFrom(t.origin),s.copyFrom(t.direction),s.scaleBy(9999),s.add(r,s),Xt.cacluteLine0.set(r,s),Xt.cacluteLine1.copyFrom(this),i&&(i.perspectiveMultiplyPoint3(Xt.cacluteLine1.start,Xt.cacluteLine1.start),i.perspectiveMultiplyPoint3(Xt.cacluteLine1.end,Xt.cacluteLine1.end));let a=Xt.squreDistanceSegmentToSegment(Xt.cacluteLine0,Xt.cacluteLine1,i);return a+1e-4<=e?(t.length=a,!0):(t.length=-999999,!1)}};let Ha=Xt;n(Ha,"cacluteLine0",new Xt(null,null)),n(Ha,"cacluteLine1",new Xt(null,null));const ag=class{constructor(t,e,i){n(this,"v1"),n(this,"v2"),n(this,"v3"),n(this,"u1"),n(this,"u2"),n(this,"u3"),n(this,"n1"),n(this,"n2"),n(this,"n3"),n(this,"t0"),n(this,"t"),n(this,"u"),n(this,"v"),n(this,"min",new p),n(this,"max",new p),n(this,"id",0),this.id=ag.ID+++200,t&&e&&i&&this.set(t,e,i)}set(t,e,i){this.v1=t,this.v2=e,this.v3=i;let r=this.min,s=this.max;return r.x=Math.min(this.v1.x,this.v2.x,this.v3.x),r.y=Math.min(this.v1.y,this.v2.y,this.v3.y),r.z=Math.min(this.v1.z,this.v2.z,this.v3.z),s.x=Math.max(this.v1.x,this.v2.x,this.v3.x),s.y=Math.max(this.v1.y,this.v2.y,this.v3.y),s.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let t=this.v1,e=this.v2,i=this.v3,r=new p(e.x-t.x,e.y-t.y,e.z-t.z),s=new p(i.x-t.x,i.y-t.y,i.z-t.z).crossProduct(r);return s.normalize(),s}turnBack(){let t=this.v3;this.v3=this.v1,this.v1=t}getLines(){let t=this.v1,e=this.v2,i=this.v3;return[new Ha(t,e),new Ha(e,i),new Ha(i,t)]}equals(t){let e=this.getLines(),i=t.getLines(),r=0;for(let s=0;s<e.length;s++)for(let a=0;a<i.length;a++)e[s].equals(i[a])&&r++;return r==3}getCenter(){let t=this.min,e=this.max,i=new p;return i.x=(t.x+e.x)*.5,i.y=(t.y+e.y)*.5,i.z=(t.z+e.z)*.5,i}intersects(t){var e=this.max,i=this.min,r=t.max,s=t.min;return i.x<=r.x&&e.x>=s.x&&i.y<=r.y&&e.y>=s.y&&i.z<=r.z&&e.z>=s.z}sign2D(t,e,i){return(t.x-i.x)*(e.z-i.z)-(e.x-i.x)*(t.z-i.z)}pointInTriangle2D(t){let e=this.v1,i=this.v2,r=this.v3,s,a,o,l,h;return s=this.sign2D(t,e,i),a=this.sign2D(t,i,r),o=this.sign2D(t,r,e),l=s<0||a<0||o<0,h=s>0||a>0||o>0,!(l&&h)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}};let Jh=ag;n(Jh,"ID",-1);class ji{static init(){this._pt0=new p,this._pt1=new p,this._pt2=new p,this._pt3=new p,this._ray=new fs,this._triangle=new Jh,this._hitPoint=new p,this._worldMatrix=new te}static rayPick(e,i,r,s,a,o){this._isInit||(this.init(),this._isInit=!0);let l=this._worldMatrix;if(s==Ni.World){let h;this.calculateHotArea_World(a,this._pt0,this._pt1,this._pt2,this._pt3),l.copyFrom(o).invert();let u=this._ray;if(u.copy(e).applyMatrix(l),this._triangle.set(this._pt0,this._pt1,this._pt2),h=u.intersectTriangle(u.origin,u.direction,this._triangle),h||(this._triangle.set(this._pt1,this._pt2,this._pt3),h=u.intersectTriangle(u.origin,u.direction,this._triangle)),h)return{distance:0,intersectPoint:h}}else{this.calculateHotArea_View(a,this._pt0,this._pt1,this._pt2,this._pt3);let h=r.x,u=r.y,c=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,d=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5,f=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,g=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5;return i.x<=f&&i.x>=c&&i.y<=g&&i.y>=d?(this._hitPoint.set(i.x,i.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(e,i,r,s,a){let o=e.getWorldMatrix(),l=o.getScaleX(),h=o.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;i.set(-u,-c,0),r.set(u,-c,0),s.set(-u,c,0),a.set(u,c,0);let d=o.tx;i.x+=d,r.x+=d,s.x+=d,a.x+=d,d=o.ty,i.y-=d,r.y-=d,s.y-=d,a.y-=d,i.multiplyScalar(Ye.pixelRatio),r.multiplyScalar(Ye.pixelRatio),s.multiplyScalar(Ye.pixelRatio),a.multiplyScalar(Ye.pixelRatio)}static calculateHotArea_World(e,i,r,s,a){let o=e.getWorldMatrix(),l=o.getScaleX(),h=o.getScaleY(),u=e.width*.5*l,c=e.height*.5*h;i.set(-u,c,0),r.set(u,c,0),s.set(-u,-c,0),a.set(u,-c,0);let d=o.tx;i.x+=d,r.x+=d,s.x+=d,a.x+=d,d=o.ty,i.y+=d,r.y+=d,s.y+=d,a.y+=d}}n(ji,"_pt0"),n(ji,"_pt1"),n(ji,"_pt2"),n(ji,"_pt3"),n(ji,"_hitPoint"),n(ji,"_worldMatrix"),n(ji,"_ray"),n(ji,"_triangle"),n(ji,"_isInit");var p2=(t=>(t[t.UpperLeft=0]="UpperLeft",t[t.UpperCenter=1]="UpperCenter",t[t.UpperRight=2]="UpperRight",t[t.MiddleLeft=3]="MiddleLeft",t[t.MiddleCenter=4]="MiddleCenter",t[t.MiddleRight=5]="MiddleRight",t[t.LowerLeft=6]="LowerLeft",t[t.LowerCenter=7]="LowerCenter",t[t.LowerRight=8]="LowerRight",t))(p2||{}),m2=(t=>(t[t.Upper=0]="Upper",t[t.Middle=1]="Middle",t[t.Lower=2]="Lower",t))(m2||{}),A2=(t=>(t[t.Left=0]="Left",t[t.Center=1]="Center",t[t.Right=2]="Right",t))(A2||{}),_2=(t=>(t[t.NONE=0]="NONE",t[t.COLOR=1]="COLOR",t[t.SPRITE=2]="SPRITE",t))(_2||{}),v2=Object.defineProperty,x2=Object.getOwnPropertyDescriptor,y2=(t,e,i,r)=>{for(var s=r>1?void 0:r?x2(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&v2(e,i,s),s};let $o=class extends Mo{constructor(){super()}init(){super.init(),this.lightData.lightType=dt.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+bi())}get range(){return this.lightData.range}set range(t){this.lightData.range=t,this.onChange()}get at(){return this.lightData.linear}set at(t){this.lightData.linear=t,this.onChange()}get radius(){return this.lightData.radius}set radius(t){this.lightData.radius=t,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(t){this.lightData.quadratic=t,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(t){let e=t.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);e.buildAxis(),e.buildCircle(p.ZERO,this.range,32,p.X_AXIS),e.buildCircle(p.ZERO,this.range,32,p.Y_AXIS),e.buildCircle(p.ZERO,this.range,32,p.Z_AXIS)}debug(){}debugDraw(t){}};$o=y2([Ci($o,"Light")],$o);var C2=(t=>(t[t.CastGI=0]="CastGI",t[t.ReceiveGI=1]="ReceiveGI",t[t.CastDepth=2]="CastDepth",t[t.Other=3]="Other",t))(C2||{});class b2 extends Yi{constructor(e=0,i=0){super(),W.register("GIProbeShader",DC);let r=new $t,s=new ct("GIProbeShader","GIProbeShader");s.passType=xe.COLOR,r.addRenderPass(s),s.setDefine("USE_BRDF",!0),s.setShaderEntry("VertMain","FragMain"),s.setUniformVector4("probeUniform",new oe(i,e,0,0));let a=s.shaderState;a.acceptShadow=!1,a.castShadow=!1,a.receiveEnv=!1,a.acceptGI=!1,a.useLight=!1,r.setTexture("baseMap",I.res.whiteTexture),r.setTexture("normalMap",I.res.normalTexture),r.setTexture("emissiveMap",I.res.blackTexture),this.shader=r}}n(b2,"count",0);var I2=Object.defineProperty,w2=Object.getOwnPropertyDescriptor,S2=(t,e,i,r)=>{for(var s=r>1?void 0:r?w2(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&I2(e,i,s),s};let el=class extends Pe{constructor(){super()}get geometry(){return null}set geometry(t){}cloneTo(t){}set meshURL(t){let e=I.res.getGeometry(t);e?this.geometry=e:console.error("no geometry set",t)}};el=S2([Ci(el,"MeshFilter")],el);const Qn=class extends rs{constructor(){super(),n(this,"mesh"),n(this,"_pickRet"),this._shapeType=sg.Mesh}rayPick(t,e){if(this.mesh){Qn.triangle||(Qn.triangle=new Jh(new p,new p,new p));let i=this.mesh.getAttribute("position"),r=this.mesh.getAttribute("indices"),s=rs.helpMatrix;s.copyFrom(e).invert();let a=rs.helpRay.copy(t);if(a.applyMatrix(s),a.intersectBox(this.mesh.bounds),!a.intersectBox(this.mesh.bounds,rs.v3_help_0))return null;if(r&&i&&r.data.length>0){let o=i.data;for(let l=0,h=r.data.length/3;l<h;l++){let u=l*3;const c=r.data[u+0]*3,d=r.data[u+1]*3,f=r.data[u+2]*3;let g=Qn.triangle,m=g.v1.set(o[c+0],o[c+1],o[c+2]),A=g.v2.set(o[d+0],o[d+1],o[d+2]),_=g.v3.set(o[f+0],o[f+1],o[f+2]);g.set(m,A,_);let x=a.intersectTriangle(a.origin,a.direction,g);if(x)return this._pickRet||(this._pickRet={intersectPoint:new p,distance:0}),this._pickRet.intersectPoint=x,this._pickRet.distance=p.distance(a.origin,x),this._pickRet}}}return null}};let E2=Qn;n(E2,"triangle");class T2 extends me{constructor(){super(),n(this,"_envMap"),n(this,"skyObject"),n(this,"envMapChange",!0),n(this,"view"),this.transform.scene3D=this,this.skyObject=new me,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=I.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,ie.instance.sky&&"map"in ie.instance.sky&&(ie.instance.sky.map=e)}get exposure(){return ie.instance.sky&&"exposure"in ie.instance.sky?ie.instance.sky.exposure:0}set exposure(e){ie.instance.sky&&"exposure"in ie.instance.sky&&(ie.instance.sky.exposure=e,I.setting.sky.skyExposure=e)}get roughness(){if(ie.instance.sky&&"roughness"in ie.instance.sky)return ie.instance.sky.roughness}set roughness(e){ie.instance.sky&&"roughness"in ie.instance.sky&&(ie.instance.sky.roughness=e)}}class B2 extends Qh{constructor(){super(3,Uh.triangle_list)}}class D2 extends Qh{constructor(){super(2,Uh.line_list)}}class R2 extends me{constructor(){super(),n(this,"mLineRender"),n(this,"mFillRender"),this.mLineRender=this.addComponent(D2),this.mFillRender=this.addComponent(B2)}drawAxis(e,i=new p(0,0,0),r=10){this.createCustomShape(e).buildAxis(i,r)}drawLines(e,i,r=Y.COLOR_WHITE){this.createCustomShape(e).buildLines(i,r)}drawCurve(e,i,r=10,s=.5,a=Y.COLOR_WHITE){var o=[];let l=new p,h=new p;for(let u=0;u<i.length-1;++u){o.push(i[u]);const c=i[Math.max(u-1,0)],d=i[u],f=i[u+1],g=i[Math.min(u+2,i.length-1)];f.subtract(c,l).multiplyScalar(s/3).add(d,l),d.subtract(g,h).multiplyScalar(s/3).add(f,h),o.push(...this.calculateBezierCurve(d,l,h,f,r))}o.push(i[i.length-1]),this.drawLines(e,o,a)}calculateBezierCurve(e,i,r,s,a){var o=new Array(a);for(let l=0;l<a;++l){let h=(l+1)/(a+1),u=1-h,c=e.mul(u*u*u),d=i.mul(3*h*u*u),f=r.mul(3*h*h*u),g=s.mul(h*h*h);o[l]=c.add(d).add(f).add(g)}return o}drawRect(e,i,r,s,a=Y.COLOR_WHITE){this.drawLines(e,[i,new p(i.x+r,i.y,i.z),new p(i.x+r,i.y+s,i.z),new p(i.x,i.y+s,i.z),i],a)}drawCircle(e,i,r,s=32,a=p.Y_AXIS,o=Y.COLOR_WHITE){this.createCustomShape(e).buildCircle(i,r,s,a,o)}drawSector(e,i,r,s,a,o=16,l=p.Y_AXIS,h=Y.COLOR_WHITE){const u=(a-s)*We;s*=We;var c=[];c.push(i);for(let m=0;m<=o;++m){m>0&&c.push(c[c.length-1]);var d=u*(m/o)+s,f=r*Math.cos(d),g=r*Math.sin(d);switch(l){case p.X_AXIS:c.push(i.add(new p(0,f,g)));break;case p.Y_AXIS:c.push(i.add(new p(f,0,g)));break;case p.Z_AXIS:c.push(i.add(new p(f,g,0)));break;default:c.push(i.add(new p(f,g,0)));break}}c.push(c[c.length-1]),c.push(i),this.mLineRender.fillShapeData(e,"line",h,c)}drawArcLine(e,i,r,s,a,o=16,l=p.Y_AXIS,h=Y.COLOR_WHITE){this.mLineRender.allocGraphics3DShape(e,this.transform._worldMatrix.index).buildArcLine(i,r,s,a,o,l,h)}createCustomShape(e,i=this.transform){return this.mLineRender.allocGraphics3DShape(e,i._worldMatrix.index)}drawBox(e,i,r,s=Y.COLOR_WHITE){var a=[];a.push(i),a.push(new p(r.x,i.y,i.z)),a.push(a[a.length-1]),a.push(new p(r.x,r.y,i.z)),a.push(a[a.length-1]),a.push(new p(i.x,r.y,i.z)),a.push(a[a.length-1]),a.push(i),a.push(a[a.length-1]),a.push(new p(i.x,i.y,r.z)),a.push(a[a.length-1]),a.push(new p(r.x,i.y,r.z)),a.push(a[a.length-1]),a.push(new p(r.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new p(i.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new p(i.x,i.y,r.z)),a.push(new p(i.x,r.y,i.z)),a.push(new p(i.x,r.y,r.z)),a.push(new p(r.x,r.y,i.z)),a.push(new p(r.x,r.y,r.z)),a.push(new p(r.x,i.y,i.z)),a.push(new p(r.x,i.y,r.z)),this.mLineRender.fillShapeData(e,"line",s,a)}drawFillRect(e,i,r,s,a=Y.COLOR_WHITE){this.mFillRender.fillShapeData(e,"fill",a,[i,new p(i.x+r,i.y,i.z),new p(i.x+r,i.y,i.z+s),new p(i.x+r,i.y,i.z+s),new p(i.x,i.y,i.z+s),i])}drawFillCircle(e,i,r,s=32,a=p.Y_AXIS,o=Y.COLOR_WHITE){var l=[];l.push(i);for(let d=0;d<=s;++d){d>=2&&(l.push(i),l.push(l[l.length-2]));var h=2*Math.PI*d/s,u=r*Math.cos(h),c=r*Math.sin(h);switch(a){case p.X_AXIS:l.push(i.add(new p(0,u,c)));break;case p.Y_AXIS:l.push(i.add(new p(u,0,c)));break;case p.Z_AXIS:l.push(i.add(new p(u,c,0)));break;default:l.push(i.add(new p(u,c,0)));break}}this.mFillRender.fillShapeData(e,"fill",o,l)}drawMeshWireframe(e,i,r,s=Y.COLOR_WHITE,a=!1){i&&this.createCustomShape(e,r||this.transform).fillShapeData(i.genWireframe(),s,a)}drawFillSector(e,i,r,s,a,o=16,l=p.Y_AXIS,h=Y.COLOR_WHITE){const u=(a-s)*We;s*=We;var c=[];c.push(i);for(let m=0;m<=o;++m){m>=2&&(c.push(i),c.push(c[c.length-2]));var d=u*(m/o)+s,f=r*Math.cos(d),g=r*Math.sin(d);switch(l){case p.X_AXIS:c.push(i.add(new p(0,f,g)));break;case p.Y_AXIS:c.push(i.add(new p(f,0,g)));break;case p.Z_AXIS:c.push(i.add(new p(f,g,0)));break;default:c.push(i.add(new p(f,g,0)));break}}this.mFillRender.fillShapeData(e,"fill",h,c)}drawBoundingBox(e,i,r=Y.COLOR_WHITE){this.drawBox(e,i.min,i.max,r)}drawCameraFrustum(e,i=Y.COLOR_WHITE){if(e.type==Je.perspective){let r=Math.tan(e.fov/2*We),s=r*e.aspect,a=e.transform._worldMatrix,o=a.transformVector(new p(-s,-r,1)),l=a.transformVector(new p(-s,r,1)),h=a.transformVector(new p(s,-r,1)),u=a.transformVector(new p(s,r,1)),c=e.far,d=e.near,f=e.transform.worldPosition,g=new p().copyFrom(o).multiplyScalar(c).add(f),m=new p().copyFrom(l).multiplyScalar(c).add(f),A=new p().copyFrom(h).multiplyScalar(c).add(f),_=new p().copyFrom(u).multiplyScalar(c).add(f),x=new p().copyFrom(o).multiplyScalar(d).add(f),b=new p().copyFrom(l).multiplyScalar(d).add(f),R=new p().copyFrom(h).multiplyScalar(d).add(f),E=new p().copyFrom(u).multiplyScalar(d).add(f),M=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);M.buildLines([b,m],i),M.buildLines([x,g],i),M.buildLines([E,_],i),M.buildLines([R,A],i),M.buildLines([m,_,A,g,m],i),M.buildLines([b,E,R,x,b],i)}else if(e.type==Je.ortho){e.viewPort,e.viewPort.height;let r=e.transform.worldMatrix,s=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*.5,e.far)),a=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*-.5,e.far)),o=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*.5,e.far)),l=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*-.5,e.far)),h=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*.5,e.near)),u=r.transformVector(new p(e.viewPort.width*-.5,e.viewPort.height*-.5,e.near)),c=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*.5,e.near)),d=r.transformVector(new p(e.viewPort.width*.5,e.viewPort.height*-.5,e.near)),f=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);f.buildLines([h,s],i),f.buildLines([u,a],i),f.buildLines([c,o],i),f.buildLines([d,l],i),f.buildLines([s,o,l,a,s],i),f.buildLines([h,c,d,u,h],i)}}drawObjectBoundingBox(e,i=Y.COLOR_WHITE){let r=xr.genMeshBounds(e);this.drawBox(`Bounds_${e.instanceID}`,r.min,r.max,i)}Clear(e){this.mLineRender.shapes.has(e)?this.mLineRender.removeShape(e):this.mFillRender.shapes.has(e)&&this.mFillRender.removeShape(e)}ClearAll(){this.mLineRender.shapes.clear(),this.mFillRender.shapes.clear()}ChangeColor(e,i){var r;if(this.mLineRender.shapes.has(e))r=this.mLineRender.shapes.get(e);else if(this.mFillRender.shapes.has(e))r=this.mFillRender.shapes.get(e);else return;const s=r.shapeData;for(let a=0;a<s.length;a+=Er.ShapeVertexSize)s[a+4]=i.r,s[a+5]=i.g,s[a+6]=i.b,s[a+7]=i.a}}class M2{constructor(){n(this,"_computeShader"),n(this,"_outBuffer")}init(){let e=$s.getGBufferFrame("ColorPassGBuffer");this._computeShader=new di(IC),this._outBuffer=new Ln(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("visibleMap",e.getPositionMap())}compute(e){let i=Ze.getCameraGroup(e.camera);this._computeShader.setStorageBuffer("globalUniform",i.uniformGPUBuffer);let r=T.beginCommandEncoder();T.computeCommand(r,[this._computeShader]),T.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var e=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(e)}getPickWorldPosition(e){e||(e=new p);var i=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],s=this._outBuffer.outFloat32Array[6];return e.set(i,r,s),e}getPickScreenUV(e){e||(e=new Ne);var i=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return e.set(i,r),e}}class P2 extends Ur{constructor(e){super(),n(this,"ray"),n(this,"isTouching",!1),n(this,"_mouseCode"),n(this,"_pickEvent"),n(this,"_outEvent"),n(this,"_overEvent"),n(this,"_upEvent"),n(this,"_downEvent"),n(this,"_mouseMove"),n(this,"_pickCompute"),n(this,"_lastDownTarget"),n(this,"mouseEnableMap"),n(this,"_view"),n(this,"_lastFocus"),n(this,"_interestList",[]),this._view=e,this.init()}init(){this.ray=new fs,this.mouseEnableMap=new Map,this._pickEvent=new j(j.PICK_CLICK),this._outEvent=new j(j.PICK_OUT),this._overEvent=new j(j.PICK_OVER),this._mouseMove=new j(j.PICK_MOVE),this._upEvent=new j(j.PICK_UP),this._downEvent=new j(j.PICK_DOWN)}start(){I.setting.pick.enable&&(I.inputSystem.addEventListener(j.POINTER_DOWN,this.onTouchStart,this),I.inputSystem.addEventListener(j.POINTER_UP,this.onTouchEnd,this),I.inputSystem.addEventListener(j.POINTER_CLICK,this.onTouchOnce,this),I.inputSystem.addEventListener(j.POINTER_MOVE,this.onTouchMove,this)),I.setting.pick.mode=="pixel"&&(this._pickCompute=new M2,this._pickCompute.init())}stop(){I.inputSystem.removeEventListener(j.POINTER_DOWN,this.onTouchStart,this),I.inputSystem.removeEventListener(j.POINTER_UP,this.onTouchEnd,this),I.inputSystem.removeEventListener(j.POINTER_CLICK,this.onTouchOnce,this),I.inputSystem.removeEventListener(j.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let i=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=i,i&&(this._downEvent.target=i.object3D,this._downEvent.ctrlKey=e.ctrlKey,this._downEvent.data={pick:i,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._downEvent),i.object3D.containEventListener(j.PICK_DOWN)&&i.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let i=this.findNearestObj(this._interestList,this._view.camera);i&&(this._upEvent.target=i.object3D,this._upEvent.ctrlKey=e.ctrlKey,this._upEvent.data={pick:i,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._upEvent),i.object3D.containEventListener(j.PICK_UP)&&i.object3D.dispatchEvent(this._upEvent))}getPickInfo(){return{worldPos:this._pickCompute.getPickWorldPosition(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let i=this.findNearestObj(this._interestList,this._view.camera);i&&(this._mouseMove.target=i.object3D,this._mouseMove.ctrlKey=e.ctrlKey,this._mouseMove.data={pick:i,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._mouseMove),i.object3D.containEventListener(j.PICK_MOVE)&&i.object3D.dispatchEvent(this._mouseMove)),i!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(this._outEvent.target=this._lastFocus.object3D,this._outEvent.data={pick:this._lastFocus,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this._outEvent.ctrlKey=e.ctrlKey,this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(j.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),i&&(this._overEvent.target=i.object3D,this._overEvent.ctrlKey=e.ctrlKey,this._overEvent.data={pick:i,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._overEvent),i.object3D.containEventListener(j.PICK_OVER)&&i.object3D.dispatchEvent(this._overEvent))),this._lastFocus=i}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let i=this.findNearestObj(this._interestList,this._view.camera);if(i){let r=I.setting.pick.mode=="pixel"?this.getPickInfo():null;this._pickEvent.target=i.object3D,this._pickEvent.ctrlKey=e.ctrlKey,this._pickEvent.data={pick:i,pickInfo:r,mouseCode:this._mouseCode},this.dispatchEvent(this._pickEvent),i===this._lastDownTarget&&i.object3D.containEventListener(j.PICK_CLICK)&&i.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,i){var r;return e.sort((s,a)=>s.distance>a.distance?1:-1),(r=e[0])==null?void 0:r.collider}pick(e){if(this._interestList.length=0,I.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let i=this._pickCompute.getPickMeshID(),r=this.mouseEnableMap.get(i);if(r){let s=this._pickCompute.getPickWorldPosition(),a=p.distance(s,this.ray.origin);this._interestList.push({distance:a,collider:r,intersectPoint:s})}}else if(I.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(I.inputSystem.mouseX,I.inputSystem.mouseY);let i,r=Oe.componentsEnablePickerList.get(this._view);if(r)for(const s of r){let a=s[0];a.enable&&(i=a.rayPick(this.ray),i&&(i.collider=a,this._interestList.push(i)))}}}}class U2 extends Jn{constructor(e=0,i=0,r=0,s=0){super(),n(this,"_camera"),n(this,"_scene"),n(this,"_viewPort"),n(this,"_enablePick",!1),n(this,"_enable",!0),n(this,"pickFire"),n(this,"guiPick"),n(this,"canvasList"),n(this,"graphic3D"),this.canvasList=[],this._viewPort=new oe(e,i,r,s),this.graphic3D=new R2}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new P2(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,Mt.createBuffer(this),this.graphic3D&&e.addChild(this.graphic3D),e&&this.canvasList.forEach(i=>{i&&e.addChild(i.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let i=this.canvasList[e];if(!i){let r=new me;r.name="Canvas "+e,i=r.addComponent(Uo),i.index=e,this.canvasList[e]=i}return this.scene.addChild(i.object3D),this.guiPick||(this.guiPick=new d2,this.guiPick.init(this)),i}disableUICanvas(e=0){let i=this.canvasList[e];i&&i.object3D&&i.object3D.removeFromParent()}}var L2=(t=>(t[t.position=3]="position",t[t.normal=3]="normal",t[t.TANGENT=4]="TANGENT",t[t.uv=2]="uv",t[t.TEXCOORD_1=2]="TEXCOORD_1",t[t.color=4]="color",t[t.joints0=4]="joints0",t[t.weights0=4]="weights0",t[t.joints1=4]="joints1",t[t.weights1=4]="weights1",t[t.vIndex=1]="vIndex",t[t.weight=1]="weight",t[t.a_morphPositions_0=3]="a_morphPositions_0",t))(L2||{});class O2{constructor(){n(this,"min",0),n(this,"max",0)}set(e,i){return this.max=i,this.min=e,this}copy(e){return this.max=e.max,this.min=e.min,this}isInterestRange(e){return!(this.max>e.min||e.max<this.min)}}class N2{constructor(){n(this,"_spaceDesc")}getRange(e){return this._spaceDesc[e]}initSpace(e){this._spaceDesc={};for(let i of e)(this._spaceDesc[i]=new O2).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(e,i){let r=this._spaceDesc[e];return i>=r.min&&i<r.max}isInterestRange(e,i){let r=this._spaceDesc[e];return r?i.isInterestRange(r):!1}splitSpace(e,i,r){let s=this._spaceDesc[e];return i?s.max=r:s.min=r,this}copySpace(e){for(let i in e._spaceDesc){let r=e._spaceDesc[i];this._spaceDesc[i].copy(r)}return this}}const ng=class{};let Gs=ng;n(Gs,"MaxEntityCountInLeaf",4),n(Gs,"MaxLayer",10),n(Gs,"ClearLeafLayer",ng.MaxLayer-4);const og=class{constructor(){n(this,"uuid","0"),this.uuid=(og.UUID++).toString()}};let lg=og;n(lg,"UUID",0);class F2{constructor(){n(this,"map",{}),n(this,"_count",0)}get count(){return this._count}push(e){return this.map[e.uuid]?!1:(this.map[e.uuid]=e,this._count++,!0)}remove(e){return this.map[e]?(delete this.map[e],this._count--,!0):!1}}const Jr=class extends lg{constructor(t=0){super(),n(this,"_dimensionIndex",0),n(this,"_dimensions"),n(this,"_dimension"),n(this,"_left"),n(this,"_right"),n(this,"_space"),n(this,"_parent"),n(this,"_entities"),n(this,"layer"),n(this,"_splitEntityList",[]),n(this,"pointIntersect",new p),this.layer=t,Jr.nodeCount++}get dimension(){return this._dimension}initNode(t,e,i){return this._dimensions=e,this._dimensionIndex=i,this._dimension=e[i],this._space=new N2().initSpace(e),t&&this._space.copySpace(t._space),this._parent=t,this._entities=new F2,this}updateEntity(t){if(t.isInNode(this,this._dimension)&&(t.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let e=(this._dimensionIndex+1)%this._dimensions.length,i=this._dimensions[e];t.isInNode(this._right,i)?this._right.updateEntity(t):t.isInNode(this._left,i)&&this._left.updateEntity(t)}}buildRoot(t){for(const e of t)e.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>Gs.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<Gs.MaxLayer){let t=this._splitEntityList,e=(this._dimensionIndex+1)%this._dimensions.length,i=this._dimensions[e],r=0;for(const s in this._entities.map){let a=this._entities.map[s];r+=a.centerValue(i),t.push(a)}r/=this._entities.count,this._left=new Jr(this.layer+1),this._right=new Jr(this.layer+1),this._left.initNode(this,this._dimensions,e),this._right.initNode(this,this._dimensions,e),this._left.setSpace(!0,r),this._right.setSpace(!1,r);for(let s of t)s.isInNode(this._right,i)?s.attachTreeNode(this._right):s.isInNode(this._left,i)&&s.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(t,e){return this._parent&&this._space.splitSpace(this._dimension,t,e),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(t){return this._entities.push(t)}removeEntity(t){return this._entities.remove(t.uuid)}autoClear(){let t=this;for(;t&&t.layer>Gs.ClearLeafLayer&&t.clearLeaf();)t=t._parent}clearLeaf(){let t=!this._left&&!this._right,e=!t&&this._left.isEmpty()&&this._right.isEmpty();return e&&(this._left=this._right=null,Jr.nodeCount-=2),t||e}isContain(t){return this._space.isContain(this._dimension,t)}nodeIntersectsBox(t){let e=this._space.getRange("x"),i=this._space.getRange("y"),r=this._space.getRange("z"),s=Jr.rangeBox;return s.min.set(e.min,i.min,r.min),s.max.set(e.max,i.max,r.max),s.intersectsBox(t)}nodeIntersectsRay(t){let e=this._space.getRange("x"),i=this._space.getRange("y"),r=this._space.getRange("z"),s=Jr.rangeBox;return s.min.set(e.min,i.min,r.min),s.max.set(e.max,i.max,r.max),!0}pointCast(t,e=0,i){if(i=i||[],this._entities.count>0){let r=this._entities.map;for(let s in r){let a=r[s],o=a.entityContainPoint(t);!o&&e>0&&(o=a.squareDistanceTo(t,this._dimensions)<=e),o&&i.push(a)}}this._left&&this._left.isContain(t[this._left.dimension])&&this._left.pointCast(t,e,i),this._right&&this._right.isContain(t[this._right.dimension])&&this._right.pointCast(t,e,i)}boxCast(t,e){if(e=e||[],this._entities.count>0){let i=this._entities.map;for(let r in i){let s=i[r];s.entityIntersectsBox(t)&&e.push(s)}}this._left&&this._left.nodeIntersectsBox(t)&&this._left.boxCast(t,e),this._right&&this._right.nodeIntersectsBox(t)&&this._right.boxCast(t,e)}rayCast(t,e,i){e=e||[],i=i||[];let r=this.pointIntersect;if(this._entities.count>0){let s=this._entities.map;for(let a in s){let o=s[a];o.entityIntersectsRay(t,r)&&(i.push(new p().copyFrom(r)),e.push(o))}}this._left&&this._left.nodeIntersectsRay(t)&&this._left.rayCast(t,e,i),this._right&&this._right.nodeIntersectsRay(t)&&this._right.rayCast(t,e,i)}};let Uc=Jr;n(Uc,"nodeCount",0),n(Uc,"rangeBox",new _t(new p(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new p(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));const Di=class{constructor(){n(this,"minPosX",0),n(this,"minPosY",0),n(this,"maxPosX",0),n(this,"maxPosY",0),n(this,"testID",0),n(this,"points"),n(this,"offsetPosition"),this.points=new Array,this.offsetPosition=new p(0,0,0,0),this.clear()}setAABox(t,e,i,r){this.minPosX=t-i/2-Di.TINY,this.maxPosX=t+i/2+Di.TINY,this.minPosY=e-r/2-Di.TINY,this.maxPosY=e+r/2+Di.TINY,this.offsetPosition.setTo(0,0,0)}setOffset(t){this.maxPosX+=t.x-this.offsetPosition.x,this.minPosX+=t.x-this.offsetPosition.x,this.minPosY+=t.z-this.offsetPosition.z,this.maxPosY+=t.z-this.offsetPosition.z,this.offsetPosition.copyFrom(t)}setContainRect(t,e,i,r){this.minPosX>t&&(this.minPosX=t),this.minPosY>e&&(this.minPosY=e),this.maxPosX<i&&(this.maxPosX=i),this.maxPosY<r&&(this.maxPosY=r)}clear(){var t=1e9;this.minPosX=this.minPosY=t,this.maxPosX=this.maxPosY=-t,this.points.length=0,this.testID=0,this.offsetPosition.setTo(0,0,0)}addPoint(t){this.points.indexOf(t)==-1&&(t.x<this.minPosX&&(this.minPosX=t.x-Di.TINY),t.x>this.maxPosX&&(this.maxPosX=t.x+Di.TINY),t.z<this.minPosY&&(this.minPosY=t.z-Di.TINY),t.z>this.maxPosY&&(this.maxPosY=t.z+Di.TINY),this.points.push(t))}clone(){var t=new Di;return t.minPosX=this.minPosX,t.minPosY=this.minPosY,t.maxPosX=this.maxPosX,t.maxPosY=this.maxPosY,t}get radius(){return Math.sqrt((this.maxPosY-this.minPosY)*(this.maxPosY-this.minPosY)+(this.maxPosX-this.minPosX)*(this.maxPosX-this.minPosX))}get sideX(){return this.maxPosX-this.minPosX}get sideY(){return this.maxPosY-this.minPosY}get centreX(){return(this.maxPosX-this.minPosX)*.5+this.minPosX}get centreY(){return(this.maxPosY-this.minPosY)*.5+this.minPosY}overlapTest(t){return!(this.minPosY>=t.maxPosY||this.maxPosY<=t.minPosY||this.minPosX>=t.maxPosX||this.maxPosX<=t.minPosX)}isPointInside(t){return t.x>=this.minPosX&&t.x<=this.maxPosX&&t.z>=this.minPosY&&t.z<=this.maxPosY}isIntersectLineSegment(t,e,i,r){var s=!1,a=e-r,o=i-t,l=t*r-i*e,h=(-l-a*this.minPosX)/o;h<=this.maxPosY&&h>=this.minPosY&&(s=!0),h=(-l-a*this.maxPosX)/o,h<=this.maxPosY&&h>=this.minPosY&&(s=!0);var u=(-l-o*this.minPosY)/a;return u<=this.maxPosX&&u>=this.minPosX&&(s=!0),u=(-l-o*this.maxPosY)/a,u<=this.maxPosX&&u>=this.minPosX&&(s=!0),s}};let hg=Di;n(hg,"TINY",1e-6);const jl=class{constructor(t){n(this,"childCellIndices"),n(this,"nodeIndices"),n(this,"aabb"),n(this,"points"),this.childCellIndices=new Array,this.childCellIndices.length=jl.NUM_CHILDREN,this.nodeIndices=new Array,this.clear(),t?this.aabb=t.clone():this.aabb=new hg}isLeaf(){return this.childCellIndices[0]==-1}clear(){for(var t=0;t<jl.NUM_CHILDREN;t++)this.childCellIndices[t]=-1;this.nodeIndices.splice(0,this.nodeIndices.length)}};let k2=jl;n(k2,"NUM_CHILDREN",4);var Q2=(t=>(t[t.MOUSE_LEFT=0]="MOUSE_LEFT",t[t.MOUSE_MID=1]="MOUSE_MID",t[t.MOUSE_RIGHT=2]="MOUSE_RIGHT",t))(Q2||{});class Lc extends Tt{}n(Lc,"LOADER_PROGRESS","loaderProgress"),n(Lc,"LOADER_COMPLETE","loaderComplete");class xn extends Tt{}n(xn,"ADDED","added"),n(xn,"REMOVED","removed"),n(xn,"CHILD_ADD_EVENT","childAddEvent"),n(xn,"CHILD_REMOVED","childRemoved");class tl extends Tt{}n(tl,"SHOW","show"),n(tl,"HIDE","hide"),n(tl,"UPDATE","update");class z2{constructor(e,i){n(this,"sourceShader"),n(this,"compute"),n(this,"needUpdate",!0),this.sourceShader=i,this.compute=new di(e),this.init()}init(){}onUpdate(){this.onFrame&&this.onFrame(),this.onOnce&&this.needUpdate&&(this.needUpdate=!1,this.onFrame())}}class G2 extends z2{constructor(e){super(wC,e)}init(){let e=new Gi(256,256,le.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);return this.compute.setStorageTexture("sssMap",e),this.sourceShader.setTexture("lutMap",e),e}onFrame(){this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let e=T.beginCommandEncoder();T.computeCommand(e,[this.compute]),T.endCommandEncoder(e)}}class ql extends Or{constructor(e,i,r=0){super(),this.bufferType=Hi.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,i)}}class yn{static createMipmap(e,i){const r=D.device;this._pipelineMax||(this._pipelineMax=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}})),this._pipelineMin||(this._pipelineMin=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}}));let s=Math.ceil(e.width*.5),a=Math.ceil(e.height*.5),o={mipmapCount:i,texture:e,srcView:null,mipLevel:1,dstHeight:a,dstWidth:s};o.srcView=e.getGPUTexture().createView({format:e.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),e.width>1024&&e.height>1024?this.mipmap(this._pipelineMax,o):this.mipmap(this._pipelineMin,o)}static mipmap(e,i){const r=D.device,s=T.beginCommandEncoder();let a=e==this._pipelineMax,o,l;for(let h=i.mipLevel;h<i.mipmapCount;h++){let u=[],c=0;u.push({binding:c++,resource:i.srcView}),u.push({binding:c++,resource:i.texture.gpuSampler}),o=i.texture.getGPUTexture().createView({format:i.texture.format,dimension:"2d",baseMipLevel:h,mipLevelCount:1}),u.push({binding:c++,resource:o});const d=r.createBindGroup({layout:e.getBindGroupLayout(0),entries:u}),f=s.beginComputePass();f.setPipeline(e),f.setBindGroup(0,d);let g=i.dstWidth,m=i.dstHeight;if(a&&(g=Math.max(1,Math.floor(i.dstWidth/8)),m=Math.max(1,Math.floor(i.dstHeight/8))),f.dispatchWorkgroups(g,m),i.dstHeight*=.5,i.dstWidth*=.5,i.srcView=o,i.mipLevel=h+1,l=a&&(i.dstWidth<8||i.dstHeight<8),f.end(),l)break}T.endCommandEncoder(s),l&&this.mipmap(this._pipelineMin,i)}}n(yn,"codeMax",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),n(yn,"codeMin",`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `),n(yn,"_pipelineMax"),n(yn,"_pipelineMin");class V2{constructor(){n(this,"name",""),n(this,"passMap",new Map)}}class H2{constructor(){n(this,"passType",""),n(this,"shaderState",new Map),n(this,"vertexShader",""),n(this,"fragmentShader","")}}class da{static parser(e,i){e=li.filterComment(e);let r=new V2,s=e.indexOf(this.shaderKeyword),a=e.indexOf("{",s),o=e.substring(s+this.shaderKeyword.length,a).trim();r.name=o.substring(1,o.length-1),o=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));let l=this.splitPassBlock(o);for(let h of l){let u=this.parserPassBlock(h),c;r.passMap.has(u.passType)?c=r.passMap.get(u.passType):(c=[],r.passMap.set(u.passType,c)),c.push(u),u.vertexShader.length>0&&(u.vertexShader=li.parse(u.vertexShader,i)),u.fragmentShader.length>0&&(u.fragmentShader=li.parse(u.fragmentShader,i))}return r}static splitPassBlock(e){let i=0,r=[];for(;i<e.length;){let s=e.indexOf(this.passKeyword,i);if(s==-1){r.push(e.substring(i));break}i!=0&&r.push(e.substring(i,s)),i=s+this.passKeyword.length}return r}static parserPassBlock(e){let i=new H2,r=e.indexOf(this.passTypeKeyword),s=e.indexOf('"',r);return r=e.indexOf('"',s+1),i.passType=e.substring(r+1,s).trim(),this.parserShaderState(i,e),r=e.indexOf(this.vertexKeyword),r!=-1&&(i.vertexShader=this.extractBlock(e.substring(r+this.vertexKeyword.length),"{","}")),r=e.indexOf(this.fragmentKeyword),r!=-1&&(i.fragmentShader=this.extractBlock(e.substring(r+this.fragmentKeyword.length),"{","}")),i}static parserShaderState(e,i){let r=i.indexOf("ShaderState");if(r==-1)return!1;r=i.indexOf("{",r);let s=i.indexOf("}",r),a=i.substring(r+1,s).split(",");for(let o of a){let l=o.split(":"),h=l[0].trim(),u=this.convertValue(l[1].trim());e.shaderState.set(h,u)}return!0}static convertValue(e){return e.length==4&&e.toLowerCase()=="true"?!0:e.length==5&&e.toLowerCase()=="false"?!1:e[0]=='"'?e.substring(1,e.length-1):Number.parseInt(e)}static extractBlock(e,i,r){let s=e.indexOf(i);if(s==-1)return"";let a=0,o=0;e=e.substring(s);for(let l of e){if(l==i?a++:l==r&&a--,a<=0)break;o++}return e.substring(1,o).trim()}}n(da,"passKeyword","pass"),n(da,"shaderKeyword","Shader"),n(da,"vertexKeyword","vertex"),n(da,"fragmentKeyword","fragment"),n(da,"passTypeKeyword","PassType");let Y2=new Tt("IrradianceDataReaderCompleteEvent");class uo extends Ur{constructor(){super(...arguments),n(this,"readFlag",!1),n(this,"probeRenderer"),n(this,"opColorBuffer"),n(this,"opDepthBuffer"),n(this,"srcColorMap"),n(this,"srcDepthMap"),n(this,"opDepthArray"),n(this,"opColorArray")}initReader(e,i,r){this.probeRenderer=e,this.srcColorMap=i,this.srcDepthMap=r;let s=I.setting.gi,a=s.octRTMaxSize*s.octRTMaxSize;this.opColorBuffer=D.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(a*4),this.opDepthBuffer=D.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(a*4),this.probeRenderer.addEventListener(Of.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(Ol.type,()=>{console.log("GIRenderStartEvent")},this)}async onProbeRenderComplete(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),await uo.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),await uo.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(Y2)}}static async read(e,i,r){let s=T.beginCommandEncoder();s.copyTextureToBuffer({texture:e},{buffer:i,bytesPerRow:e.width*16},[e.width,e.height]),T.endCommandEncoder(s),await i.mapAsync(GPUMapMode.READ);const a=i.getMappedRange();r.set(new Float32Array(a),0),i.unmap()}}new uo;var X2=Object.defineProperty,K2=Object.getOwnPropertyDescriptor,W2=(t,e,i,r)=>{for(var s=r>1?void 0:r?K2(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&X2(e,i,s),s};let Jl=class extends $t{constructor(){super(),W.register("VertexAttributeIndexShader",SC),W.register("UnLitTextureArray",UC);let t=new ct("UnLitTextureArray","UnLitTextureArray");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!1,e.castShadow=!1,e.receiveEnv=!1,e.acceptGI=!1,e.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformFloat("alphaCutoff",0)}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?zt.none:e.shaderState.cullMode}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=Te.NONE:e.blendMode=Te.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Jl=W2([Lr],Jl);class Zh extends Yi{constructor(){super(),this.shader=new Jl,this.baseMap=I.res.whiteTexture}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}set shadowMap(e){}}class j2 extends wt{constructor(e){super(),n(this,"faceCount",0),this.faceCount=e,this.buildGeometry()}buildGeometry(){let e=new Uint32Array(this.faceCount*3),i=new Float32Array(this.faceCount*3*3),r=new Float32Array(this.faceCount*3*3),s=new Float32Array(this.faceCount*3*2),a=new Float32Array(this.faceCount*3*1);for(let o=0;o<this.faceCount;o++){let l=o*3+0,h=o*3+1,u=o*3+2;e[l]=l,e[h]=h,e[u]=u}this.setIndices(e),this.setAttribute(z.position,i),this.setAttribute(z.normal,r),this.setAttribute(z.uv,s),this.setAttribute(z.TEXCOORD_1,s),this.setAttribute(z.vIndex,a),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class il extends nr{constructor(){super(...arguments),n(this,"index",0),n(this,"faceStart",0),n(this,"faceEnd",0),n(this,"faceCount",0)}}class Cn extends nr{constructor(){super(...arguments),n(this,"shapeIndex",0),n(this,"shapeType",0),n(this,"width",0),n(this,"height",0),n(this,"pathCount",0),n(this,"uSpeed",0),n(this,"vSpeed",0),n(this,"radiu",0),n(this,"paths",new Float32Array(Us.maxPathPointCount*4))}}const mr=class extends Pe{constructor(){super(...arguments),n(this,"texture"),n(this,"transformBuffer"),n(this,"_onChange",!1),n(this,"_computeGeoShader"),n(this,"geometryInfoBuffer"),n(this,"shapeBuffer"),n(this,"object3Ds"),n(this,"shapes")}init(){super.init()}create(t,e){this._computeGeoShader=new di(EC(mr.maxPathPointCount)),this.geometryInfoBuffer=new ql(il,mr.maxGeometryCount),this.shapeBuffer=new ql(Cn,mr.maxShapeCount);let i=new j2(mr.maxFaceCount),r=new Zh;r.baseMap=t,this.material=r,this.transformBuffer=new At(e*(4*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer),this.object3Ds=[];for(let s=0;s<e;s++){const a=new me;this.object3Ds.push(a),this.object3D.addChild(a),this.transformBuffer.setFloat("matrix_"+s,a.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+s,1),this.transformBuffer.setFloat("texId2_"+s,1),this.transformBuffer.setFloat("texId3_"+s,1),this.transformBuffer.setColor("baseColor_"+s,new Y),this.transformBuffer.setColor("emissiveColor_"+s,new Y(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+s,new oe(0,0,1,1))}this.transformBuffer.apply(),this.geometry=i}startShape(t){this.create(t,mr.maxGeometryCount);let e=[];for(let i=0;i<mr.maxGeometryCount;i++){const r=new il;e.push(r)}this.shapeBuffer.setStructArray(il,e),this.geometryInfoBuffer.apply(),this.shapes=[];for(let i=0;i<mr.maxShapeCount;i++){const r=new Cn;this.shapes.push(r)}this.shapeBuffer.setStructArray(Cn,this.shapes),this.shapeBuffer.apply(),this.start=()=>{this._computeGeoShader.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),this._computeGeoShader.setStructStorageBuffer("geometryInfoBuffer",this.geometryInfoBuffer),this._computeGeoShader.setStructStorageBuffer("shapeBuffer",this.shapeBuffer),this._computeGeoShader.setStorageBuffer("globalUniform",Ze.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer)},this.onCompute=(i,r)=>this.computeTrail(i,r)}updateShape(t,e){this.shapeBuffer.setStruct(Cn,t,e),this.shapeBuffer.apply()}setTextureID(t,e){this.transformBuffer.setFloat("texId_"+t,e),this._onChange=!0}setBaseColor(t,e){this.transformBuffer.setColor("baseColor_"+t,e),this._onChange=!0}setEmissiveColor(t,e){this.transformBuffer.setColor("emissiveColor_"+t,e),this._onChange=!0}setUVRect(t,e){this.transformBuffer.setVector4("uvRect_"+t,e),this._onChange=!0}onUpdate(t){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}computeTrail(t,e){this._computeGeoShader.workerSizeX=1,this._computeGeoShader.workerSizeY=4,T.computeCommand(e,[this._computeGeoShader])}};let Us=mr;n(Us,"maxFaceCount",5e4),n(Us,"maxGeometryCount",1),n(Us,"maxShapeCount",1),n(Us,"maxPathPointCount",50);class ug{static merge(e,i,r){}static mergeNumber(e,i,r){let s=r||new wt,a=e.getAttribute(z.position).data.length/3,o=new Float32Array(a*i);for(const c of e.vertexAttributeMap){let d=c[1].attribute;if(d==z.indices)continue;let f=e.getAttribute(d).data,g=f.length,m=new Float32Array(g*i);for(let A=0;A<i;A++){m.set(f,g*A);for(let _=0;_<a;_++)o[a*A+_]=A}s.setAttribute(d,m)}s.setAttribute(z.vIndex,o);let l=e.getAttribute(z.indices).data,h=l.length,u=new Uint32Array(l.length*i);for(let c=0;c<i;c++)for(let d=0;d<h;d++){let f=c*a,g=c*h;const m=l[d]+f;u[g+d]=m}return s.setIndices(u),s.addSubGeometry({indexStart:0,indexCount:u.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),s}static generateNormal(){}static generateTangent(){}static packUV(){}}class q2 extends Pe{constructor(){super(...arguments),n(this,"transformBuffer"),n(this,"sourceGeometry"),n(this,"texture"),n(this,"object3Ds"),n(this,"_onChange",!1),n(this,"_computeShader")}init(){super.init()}create(e,i,r){let s=new Zh;s.baseMap=i,this.material=s,this.transformBuffer=new At(r*(4*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer),this.object3Ds=[];for(let a=0;a<r;a++){const o=new me;this.object3Ds.push(o),this.object3D.addChild(o),this.transformBuffer.setFloat("matrix_"+a,o.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+a,1),this.transformBuffer.setFloat("texId2_"+a,1),this.transformBuffer.setFloat("texId3_"+a,1),this.transformBuffer.setColor("baseColor_"+a,new Y),this.transformBuffer.setColor("emissiveColor_"+a,new Y(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+a,new oe(0,0,1,1))}this.transformBuffer.apply(),this.geometry=ug.mergeNumber(e,r)}startSpark(){}setTextureID(e,i){this.transformBuffer.setFloat("texId_"+e,i),this._onChange=!0}setBaseColor(e,i){this.transformBuffer.setColor("baseColor_"+e,i),this._onChange=!0}setEmissiveColor(e,i){this.transformBuffer.setColor("emissiveColor_"+e,i),this._onChange=!0}setUVRect(e,i){this.transformBuffer.setVector4("uvRect_"+e,i),this._onChange=!0}onUpdate(e){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}computeTrail(e,i){T.computeCommand(i,[this._computeShader])}}class J2 extends wt{constructor(e){super(),n(this,"segment"),n(this,"row",0),this.segment=e,this.buildGeometry()}buildGeometry(){this.row=this.segment+1;let e=new Uint32Array(this.segment*6),i=new Float32Array(this.row*3*2),r=new Float32Array(this.row*3*2),s=new Float32Array(this.row*2*2);for(let a=0;a<this.row;a++){i[a*3*2+0]=0,i[a*3*2+1]=0,i[a*3*2+2]=0,i[a*3*2+3]=0,i[a*3*2+4]=0,i[a*3*2+5]=0,r[a*3*2+0]=0,r[a*3*2+1]=0,r[a*3*2+2]=1,r[a*3*2+3]=0,r[a*3*2+4]=0,r[a*3*2+5]=1,s[a*2*2+0]=0,s[a*2*2+1]=a/this.segment,s[a*2*2+2]=1,s[a*2*2+3]=a/this.segment;let o=a*2,l=o,h=o+1,u=o+2,c=o+3;e[a*6+0]=l,e[a*6+1]=h,e[a*6+2]=u,e[a*6+3]=h,e[a*6+4]=c,e[a*6+5]=u}this.setIndices(e),this.setAttribute(z.position,i),this.setAttribute(z.normal,r),this.setAttribute(z.uv,s),this.setAttribute(z.TEXCOORD_1,s),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}var Z2=Object.defineProperty,$2=Object.getOwnPropertyDescriptor,eb=(t,e,i,r)=>{for(var s=r>1?void 0:r?$2(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Z2(e,i,s),s},tb=(t=>(t[t.FaceToCamera=0]="FaceToCamera",t[t.FaceToPath=1]="FaceToPath",t[t.FaceToUp=2]="FaceToUp",t))(tb||{});class zn extends nr{constructor(){super(...arguments),n(this,"index",1),n(this,"segment",5),n(this,"visible",1),n(this,"width",.25),n(this,"uv",new oe(0,0,1,30)),n(this,"uvSpeed",new Ne(0,2.1)),n(this,"smooth",0),n(this,"faceMode",0),n(this,"up",new oe(0,1,0)),n(this,"ids",new Float32Array($h.maxRibbonSegment)),n(this,"ribbonPoint",[])}}eb([Bl],zn.prototype,"ribbonPoint",2);const Zl=class extends Pe{constructor(){super(...arguments),n(this,"transformBuffer"),n(this,"sourceGeometry"),n(this,"texture"),n(this,"object3Ds"),n(this,"ribbons"),n(this,"ribbonCount",10),n(this,"_onChange",!1),n(this,"_computeShader"),n(this,"_ribbonBuffer"),n(this,"ribbonSegment")}init(){super.init()}create(t,e,i){this.ribbons=[],this.ribbonSegment=t;for(let a=0;a<i;a++)this.ribbons[a]=new zn,this.ribbons[a].index=a,this.ribbons[a].segment=t,this.ribbons[a].width=.5,this.ribbons[a].faceMode=0;let r=new J2(t),s=new Zh;s.baseMap=e,this.material=s,this.transformBuffer=new At(i*(4*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer),this.object3Ds=[];for(let a=0;a<i;a++){const o=new me;this.object3Ds.push(o),this.object3D.addChild(o),this.transformBuffer.setFloat("matrix_"+a,o.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+a,1),this.transformBuffer.setFloat("texId2_"+a,1),this.transformBuffer.setFloat("texId3_"+a,1),this.transformBuffer.setColor("baseColor_"+a,new Y),this.transformBuffer.setColor("emissiveColor_"+a,new Y(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+a,new oe(0,0,1,1))}this.transformBuffer.apply(),this.geometry=ug.mergeNumber(r,i)}startRibbon(t,e,i){this.ribbonCount=i,this.create(e,t,i),this._computeShader=new di(TC(Zl.maxRibbonSegment)),this._ribbonBuffer=new ql(zn,i);for(let r=0;r<i;r++){this.ribbons[r].ribbonPoint=[];for(let s=0;s<Zl.maxRibbonSegment;s++){const a=new me;this.object3D.addChild(a),this.ribbons[r].ribbonPoint[s]=a,this.ribbons[r].ids[s]=a.transform.worldMatrix.index}}this._ribbonBuffer.setStructArray(zn,this.ribbons),this._ribbonBuffer.apply(),this.start=()=>{this._computeShader.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),this._computeShader.setStorageBuffer("trailBuffer",this._ribbonBuffer),this._computeShader.setStorageBuffer("models",Ze.modelMatrixBindGroup.matrixBufferDst),this._computeShader.setStorageBuffer("globalUniform",Ze.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer)},this.onCompute=(r,s)=>this.computeTrail(r,s)}setTextureID(t,e){this.transformBuffer.setFloat("texId_"+t,e),this._onChange=!0}setBaseColor(t,e){this.transformBuffer.setColor("baseColor_"+t,e),this._onChange=!0}setEmissiveColor(t,e){this.transformBuffer.setColor("emissiveColor_"+t,e),this._onChange=!0}setUVRect(t,e){this.transformBuffer.setVector4("uvRect_"+t,e),this._onChange=!0}onUpdate(t){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}computeTrail(t,e){this._computeShader.workerSizeX=this.ribbonCount,this._computeShader.workerSizeY=1,T.computeCommand(e,[this._computeShader])}};let $h=Zl;n($h,"maxRibbonSegment",256);class bn{static draw(e,i,r,s){if(!this.meshMap.has(i)){let a=new me,o=a.addComponent(q2);return o.create(i,r,s),this.meshMap.set(i,o),e.addChild(a),o}}static drawRibbon(e,i,r,s,a){if(!this.ribbonMap.has(e)){let o=new me,l=o.addComponent($h);return l.startRibbon(r,s,a),this.ribbonMap.set(e,l),i.addChild(o),l}}static drawShape(e,i,r){if(!this.ribbonMap.has(e)){let s=new me,a=s.addComponent(Us);return a.startShape(r),this.faceMap.set(e,a),i.addChild(s),a}}}n(bn,"meshMap",new Map),n(bn,"meshDrawGroup",new Map),n(bn,"ribbonMap",new Map),n(bn,"faceMap",new Map);class ib{constructor(){n(this,"indexList"),n(this,"color"),n(this,"count")}}class rb{constructor(){n(this,"SlotCount",8),n(this,"MaxEntities",16),n(this,"defaultColor",new Y(.2,1,1,1)),n(this,"slots",[]),n(this,"dataDirty",!0);let e=I.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(e,this.SlotCount));for(let i=0;i<this.SlotCount;i++){let r=this.slots[i]=new ib;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let e=0;e<this.SlotCount;e++)this.clearAt(e)}clearAt(e){this.dataDirty=!0;let i=this.slots[e];return i.color.copyFrom(this.defaultColor),i.indexList.fill(-1),i.count=0,this}fillDataAt(e,i,r){this.dataDirty=!0;let s=this.slots[e];if(s){s.indexList.fill(-1);for(let a=0,o=i.length;a<o;a++)s.indexList[a]=i[a];s.count=i.length,s.color.copyFrom(r)}return this}fetchData(e){return e.dirty=this.dataDirty,e.slots=this.slots,this.dataDirty=!1,this}}let In=new rb;class sb{constructor(){n(this,"_tempIndexArray",[]),n(this,"_rendererList",[])}setOutline(e,i){this.setOutlineList([e],i?[i]:null)}setOutlineList(e,i){e||(e=[]);let r=In.defaultColor,s=In.SlotCount;for(let a=0;a<s;a++){this._tempIndexArray.length=0;let o=e[a],l=(i?i[a]:null)||r;if(o)for(const h of o)this.getEntityIdList(h,this._tempIndexArray);In.fillDataAt(a,this._tempIndexArray,l)}}clearOutline(){return In.clear(),this}getEntityIdList(e,i){this._rendererList.length=0;let r=e.getComponents(Pe,this._rendererList);for(const s of r)i.push(s.object3D.transform._worldMatrix.index)}}new sb;class ab{constructor(){n(this,"localPosition",new p),n(this,"worldPosition",new p),n(this,"uv",new Ne),n(this,"faceIndex"),n(this,"isIn",!1),n(this,"t",0),n(this,"u",0),n(this,"v",0),n(this,"triangle"),n(this,"v0"),n(this,"v1"),n(this,"v2"),n(this,"pickList"),n(this,"color")}}const Ta=class{static distPtTri(t,e,i,r){let s=new p,a=new p,o=new p;r.subtract(e,s),i.subtract(e,a),t.subtract(e,o);let l=ri(s,s),h=ri(s,a),u=ri(s,o),c=ri(a,a),d=ri(a,o),f=1/(l*c-h*h),g=(c*u-h*d)*f,m=(l*d-h*u)*f;if(g>=-Ta.EPS&&m>=-Ta.EPS&&g+m<=1+Ta.EPS){let A=e[1]+s[1]*g+a[1]*m;return Math.abs(A-t[1])}return Ta.FLT_MAX}static IntersectTriangle(t,e,i){let r=e.v1,s=e.v2,a=e.v3,o=s.subtract(r,p.HELP_3),l=a.subtract(r,p.HELP_4),h=t.direction.crossProduct(l,p.HELP_5),u=ri(o,h),c;if(u>0){if(i)return null;c=t.origin.subtract(r,p.HELP_2)}else c=r.subtract(t.origin,p.HELP_2),u=-u;if(u<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let d=ri(c,h);if(d<0||d>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let f=c.crossProduct(o,p.HELP_1),g=ri(t.direction,f);if(g<0||d+g>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let m=ri(l,f),A=1/u;m*=A,d*=A,g*=A,this._info.isIn=!0,this._info.t=m,this._info.u=d,this._info.v=g;let _=1-d-g;return this._u0.copyFrom(e.u1),this._u0.scale(_),this._u1.copyFrom(e.u2),this._u1.scale(d),this._u2.copyFrom(e.u3),this._u2.scale(g),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(t.direction).multiplyScalar(m),this._info.localPosition.add(t.origin,this._info.localPosition),this._info}};let Is=Ta;n(Is,"EPS",1e-4),n(Is,"FLT_MAX",3402823466e29),n(Is,"_info",new ab),n(Is,"_u0",new Ne),n(Is,"_u1",new Ne),n(Is,"_u2",new Ne);const $l=class extends Ur{constructor(){if(super(),n(this,"_maxRetry",3),$l._instance)throw new Error("LoadManager is singleton class...")}loadAll(t,e){return new Promise((i,r)=>{let s=t.length,a=[];t.forEach((o,l)=>{let h=new e;this.load(o,e).then(u=>{h.parse(u),a.push(h),s--,s===0&&i(a)})})})}static getInstance(){return this._instance||(this._instance=new $l)}loadUrls(t,e){return new Promise((i,r)=>{let s=t.length,a=[];t.forEach((o,l)=>{this.load(o,e).then(h=>{a.push(h),s--,s===0&&i(a),s<0&&console.error(`loadUrls ${t} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(t){this._maxRetry=t}load(t,e){return new Promise((i,r)=>{switch(e.format){}})}};let nb=$l;n(nb,"_instance");class ob{constructor(){n(this,"boneName"),n(this,"bonePath"),n(this,"parentBoneName"),n(this,"boneID"),n(this,"parentBoneID"),n(this,"instanceID"),n(this,"parentInstanceID"),n(this,"t"),n(this,"q"),n(this,"s")}formBytes(e){this.boneName=e.readUTF(),this.bonePath=e.readUTF(),this.parentBoneName=e.readUTF(),this.boneID=e.readInt32(),this.parentBoneID=e.readInt32(),this.instanceID=e.readUTF(),this.parentInstanceID=e.readUTF(),this.t=e.readVector3(),this.q=e.readQuaternion(),this.s=e.readVector3()}}class lb{constructor(){n(this,"name"),n(this,"count"),n(this,"boneData"),n(this,"boneMap")}formBytes(e){this.boneData=[],this.boneMap=new Map,this.name=e.readUTF(),this.count=e.readInt32();for(let i=0;i<this.count;i++){let r=new ob;r.formBytes(e.readBytesArray()),this.boneData[i]=r,this.boneMap.set(r.boneName,r)}}}class cg extends Vt{static parser(e,i){let r=e.readInt32();for(let s=0;s<r;s++){let a=new lb;a.formBytes(e.readBytesArray()),I.res.addObj(a.name,a)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}n(cg,"format",xt.BIN),z.position,z.normal,z.color,z.TANGENT,z.uv,z.TEXCOORD_1,z.TEXCOORD_2,z.TEXCOORD_2,z.TEXCOORD_4,z.TEXCOORD_5,z.TEXCOORD_6,z.TEXCOORD_7,z.joints0,z.weights0;var H=(t=>(t[t.single=0]="single",t[t.boolean=1]="boolean",t[t.int=2]="int",t[t.int16=3]="int16",t[t.int32=4]="int32",t[t.float=5]="float",t[t.long=6]="long",t[t.uint=7]="uint",t[t.uint32=8]="uint32",t[t.uint64=9]="uint64",t[t.double=10]="double",t[t.string=11]="string",t[t.singleArray=12]="singleArray",t[t.stringArray=13]="stringArray",t[t.floatArray=14]="floatArray",t[t.vector2=15]="vector2",t[t.vector3=16]="vector3",t[t.vector4=17]="vector4",t[t.color=18]="color",t[t.color32=19]="color32",t[t.animationCurve=20]="animationCurve",t[t.quaternion=21]="quaternion",t[t.matrix4x4=22]="matrix4x4",t[t.mesh=23]="mesh",t[t.texture=24]="texture",t[t.material=25]="material",t[t.materials=26]="materials",t[t.skeleton=27]="skeleton",t[t.animClip=28]="animClip",t[t.vector2Int=29]="vector2Int",t[t.int32List=30]="int32List",t[t.colorList=31]="colorList",t[t.color32List=32]="color32List",t))(H||{});class rl{static GetMaterial(e){let i=e,r=i.split("/");i=r[r.length-1],r=i.split("."),i=r[r.length-1];let s=v0(i);if(s){let a=new Yi;return a.shader=new s,a}else throw new Error("not found shader, shader name is "+i)}static applyMaterialTexture(e,i){for(let r=0;r<i.length;r++){const s=i[r];s.property in e?e[s.property]=s.texture:s.property in e.shader?e.shader[s.property]=s.texture:e.setTexture(s.property,s.texture)}}static applyMaterialProperties(e,i){for(let r=0;r<i.length;r++){const s=i[r],a=s.key;switch(s.type){case H.color:case H.color32:{let o=s.getValue();a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformColor(a,o)}break;case H.single:case H.float:case H.int:case H.int16:case H.int32:case H.uint:case H.uint32:case H.uint64:{let o=s.getValue();a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformFloat(a,o)}break;case H.singleArray:{let o=s.getValue()[0];a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformFloat(a,o)}break;case H.vector2:case H.vector2Int:{let o=s.getValue();a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformVector2(a,o)}break;case H.vector3:{let o=s.getValue();a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformVector3(a,o)}break;case H.vector4:{let o=s.getValue();a in e?e[a]=o:a in e.shader?e.shader[a]=o:e.setUniformVector4(a,o)}break}}}}class ir{static parser(e){switch(e.readInt32()){case H.single:return{t:H.single,v:e.readFloat32()};case H.boolean:return{t:H.boolean,v:e.readBoolean()};case H.int:return{t:H.int,v:e.readInt32()};case H.int16:return{t:H.int16,v:e.readInt16()};case H.int32:return{t:H.int32,v:e.readInt32()};case H.float:return{t:H.float,v:e.readFloat32()};case H.long:return{t:H.long,v:e.readFloat64()};case H.uint:return{t:H.uint,v:e.readUnit32()};case H.uint32:return{t:H.uint32,v:e.readUnit32()};case H.uint64:return{t:H.uint64,v:e.readUnit32()};case H.double:return{t:H.double,v:e.readFloat64()};case H.string:return{t:H.string,v:e.readUTF()};case H.singleArray:return{t:H.singleArray,v:e.readFloatArray()};case H.stringArray:return{t:H.stringArray,v:e.readStringArray()};case H.floatArray:return{t:H.floatArray,v:e.readFloatArray()};case H.vector2:return{t:H.vector2,v:e.readVector2()};case H.vector3:return{t:H.vector3,v:e.readVector3()};case H.vector4:return{t:H.vector4,v:e.readVector4()};case H.color:return{t:H.color,v:e.readColor()};case H.color32:return{t:H.color32,v:e.readColor()};case H.animationCurve:return{t:H.animationCurve,v:null};case H.quaternion:return{t:H.quaternion,v:e.readQuaternion()};case H.matrix4x4:return{t:H.matrix4x4,v:null};case H.mesh:{let o=e.readUTF(),l=I.res.getGeometry(o);return{t:H.mesh,v:l}}case H.texture:{let o=e.readUTF(),l=I.res.getTexture(o);return{t:H.texture,v:l}}case H.material:{let o=e.readUTF(),l=I.res.getMat(o);return{t:H.material,v:l}}case H.materials:{let o=e.readStringArray(),l=[];for(let h=0;h<o.length;h++){const u=o[h];let c=I.res.getMat(u);l.push(c)}return{t:H.materials,v:l}}case H.skeleton:break;case H.animClip:{let o=[],l=e.readInt32();for(let h=0;h<l;h++){let u=new Zb;u.formBytes(e),o.push(u)}return{t:H.animClip,v:o}}case H.vector2Int:return{t:H.vector2Int,v:e.readVector2int()};case H.int32List:return{t:H.int32List,v:e.readInt32List()};case H.colorList:let i=e.readInt32(),r=[];for(let o=0;o<i;o++){const l=ir.parser(e).v;r.push(l)}return{t:H.colorList,v:r};case H.color32List:let s=e.readInt32(),a=[];for(let o=0;o<s;o++){const l=ir.parser(e).v;a.push(l)}return{t:H.color32List,v:a}}}}class dg{constructor(){n(this,"key"),n(this,"type"),n(this,"_data")}getValue(){return this._data}formBytes(e){this.key=e.readUTF();let{t:i,v:r}=ir.parser(e);this.type=i,this._data=r}}class hb{constructor(){n(this,"property"),n(this,"name"),n(this,"texture"),n(this,"texelSize"),n(this,"wrapModeU"),n(this,"wrapModeV"),n(this,"wrapModeW"),n(this,"wrapMode"),n(this,"anisoLevel"),n(this,"dimension"),n(this,"filterMode")}}class fg extends Vt{static parserMaterial(e,i){let r=e.readInt32();for(let s=0;s<r;s++){let a=e.readBytesArray(),o=a.readUTF(),l=a.readUTF();a.readUTF();let h=a.readStringArray();a.readVector4(),a.readVector4();let u=a.readUTF(),c=[],d=[],f=a.readInt32();for(let A=0;A<f;A++){let _=new dg;_.formBytes(a),c.push(_)}let g=a.readInt32();for(let A=0;A<g;A++){let _=a.readBytesArray(),x=new hb;x.property=_.readUTF(),x.name=_.readUTF(),x.texture=I.res.getTexture(x.name),x.texelSize=_.readVector2(),x.wrapModeU=_.readUnit32(),x.wrapModeV=_.readUnit32(),x.wrapModeW=_.readUnit32(),x.wrapMode=_.readUnit32(),x.anisoLevel=_.readUnit32(),x.dimension=_.readUnit32(),x.filterMode=_.readUnit32(),d.push(x)}let m=rl.GetMaterial(u);m.name=o;for(let A=0;A<h.length;A++){const _=h[A];m.shader.setDefine(_,!0)}rl.applyMaterialTexture(m,d),rl.applyMaterialProperties(m,c),I.res.addMat(l,m)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}n(fg,"format",xt.TEXT);class ub{constructor(){n(this,"shapeName"),n(this,"shapeIndex"),n(this,"frameCount"),n(this,"blendPositionList",new Float32Array),n(this,"blendNormalList",new Float32Array)}formBytes(e){let i=e.readBytesArray();this.shapeName=i.readUTF(),this.shapeIndex=i.readInt32(),this.frameCount=i.readInt32();let r=i.readInt32();this.blendPositionList=i.readFloat32Array(r*3);let s=i.readInt32();this.blendNormalList=i.readFloat32Array(s*3)}}class cb{constructor(){n(this,"vertexCount"),n(this,"shapeNames"),n(this,"shapeIndexs"),n(this,"blendCount"),n(this,"blendShapePropertyDatas"),n(this,"blendShapeMap")}formBytes(e){this.blendShapeMap=new Map,this.blendShapePropertyDatas=[];let i=e.readBytesArray();this.vertexCount=i.readInt32(),this.shapeNames=i.readStringArray(),this.shapeIndexs=i.readIntArray(),this.blendCount=i.readInt32();for(let r=0;r<this.blendCount;r++){let s=new ub;s.formBytes(i),this.blendShapePropertyDatas.push(s),this.blendShapeMap.set(s.shapeName,s)}return e}}class db{constructor(){n(this,"name"),n(this,"meshName"),n(this,"meshID"),n(this,"vertexCount"),n(this,"vertexStrip"),n(this,"vertexBuffer"),n(this,"indices"),n(this,"attributes"),n(this,"bones"),n(this,"bindPose"),n(this,"blendShapeData")}}class gg extends Vt{async parseBuffer(e){}static parserMeshs(e,i){let r=e.readInt32();for(let s=0;s<r;s++){let a=new db,o=e.readBytesArray();a.meshName=o.readUTF(),a.meshID=o.readUTF(),o.readFloat32()>0,o.readFloat32()>0,o.readFloat32()>0;let l=o.readFloat32()>0,h=o.readFloat32()>0;l&&(a.bones=o.readStringArray(),a.bindPose=o.readMatrix44Array()),h&&(a.blendShapeData=new cb,a.blendShapeData.formBytes(o));let u=o.readBytesArray(),c=o.readBytesArray(),d=u.readInt32(),f=0,g=[];for(let b=0;b<d;b++)g[b]={},g[b].att=fb[u.readUTF()],g[b].dim=u.readInt32(),f+=g[b].dim,g[b].format=u.readUTF();a.vertexCount=u.readInt32(),a.vertexBuffer=c.getFloat32Array();let m=o.readInt32Array(),A=[],_=o.readInt32();for(let b=0;b<_;b++){let R=o.readInt32(),E=o.readInt32(),M=o.readInt32(),G=o.readInt32(),V=o.readInt32(),k=o.readInt32();o.readVector3(),o.readVector3();let O={indexStart:E,indexCount:M,vertexStart:G,vertexCount:k,firstStart:V,topology:R,index:b};A.push(O)}m.length>65535?a.indices=new Uint32Array(m):a.indices=new Uint16Array(m);let x=new wt;if(x.vertexDim=f,x.geometryType=Rt.compose_bin,x.setIndices(a.indices),x.setAttribute(z.all,a.vertexBuffer),l&&(x.skinNames=a.bones,x.bindPose=a.bindPose),h){x.blendShapeData=a.blendShapeData,x.morphTargetsRelative=!0,x.morphTargetDictionary={};for(let b=0;b<a.blendShapeData.blendCount;b++){x.setAttribute("a_morphPositions_"+b,a.blendShapeData.blendShapePropertyDatas[b].blendPositionList),x.setAttribute("a_morphNormals_"+b,a.blendShapeData.blendShapePropertyDatas[b].blendNormalList);for(let R=0;R<a.blendShapeData.blendCount;R++){let E=a.blendShapeData.shapeNames[R],M=a.blendShapeData.shapeIndexs[R];x.morphTargetDictionary[E]=M}}}for(let b=0;b<g.length;b++){const R=g[b].att;x.setAttribute(R,null)}for(let b=0;b<A.length;b++){const R=A[b];x.addSubGeometry(R)}x.name=a.meshName,I.res.addGeometry(a.meshID,x)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}n(gg,"format",xt.BIN);let fb={Position:z.position,Normal:z.normal,Color:z.color,Tangent:z.TANGENT,TexCoord0:z.uv,TexCoord1:z.TEXCOORD_1,TexCoord2:z.TEXCOORD_2,TexCoord3:z.TEXCOORD_2,TexCoord4:z.TEXCOORD_4,TexCoord5:z.TEXCOORD_5,TexCoord6:z.TEXCOORD_6,TexCoord7:z.vIndex,BlendIndices:z.joints0,BlendWeight:z.weights0};class eu extends DataView{constructor(e,i,r){super(e,i,r),n(this,"position",0),n(this,"littleEndian",!0),this.position=0,this.position+=this.byteOffset}readUTF(){let e=this.readInt32(),i=e%4;i>0&&i<4&&(i=4-i);let r="",s=new Int8Array(this.buffer,this.position,e);return this.position+=e*Int8Array.BYTES_PER_ELEMENT,r+=String.fromCharCode.apply(null,s),this.position+=i*Int8Array.BYTES_PER_ELEMENT,r}readStringArray(){let e=[],i=this.readInt32();for(let r=0;r<i;r++)e.push(this.readUTF());return e}readByte(){let e=this.buffer[this.position];return this.position+=1,e}readBoolean(){let e=this.readInt32();return this.position+=4,e==1}readBytes(e){let i=new DataView(this.buffer,this.position,e);return this.position+=e,i.buffer}readBytesArray(){let e=this.readInt32(),i=new eu(this.buffer.slice(this.position,this.position+e));return this.position+=e,i}readUnit8(){let e=this.getUint8(this.position);return this.position+=Uint8Array.BYTES_PER_ELEMENT,e}readUnit16(){let e=this.getUint16(this.position);return this.position+=Uint16Array.BYTES_PER_ELEMENT,e}readUnit32(){let e=this.getUint32(this.position);return this.position+=Uint32Array.BYTES_PER_ELEMENT,e}readInt8(){let e=this.getInt8(this.position);return this.position+=Int8Array.BYTES_PER_ELEMENT,e}readInt16(){let e=this.getInt16(this.position,this.littleEndian);return this.position+=Int16Array.BYTES_PER_ELEMENT,e}readInt32(){let e=this.getInt32(this.position,this.littleEndian);return this.position+=Int32Array.BYTES_PER_ELEMENT,e}readFloat32(){let e=this.getFloat32(this.position,this.littleEndian);return this.position+=Float32Array.BYTES_PER_ELEMENT,e}readFloat64(){let e=this.getFloat64(this.position,this.littleEndian);return this.position+=Float64Array.BYTES_PER_ELEMENT,e}readInt32Array(){let e=this.readInt32(),i=new Int32Array(this.buffer,this.position,e);return i=i.slice(0,e),this.position+=i.byteLength,i}readInt32List(){let e=this.readInt32(),i=[];for(let r=0;r<e;r++)i.push(this.readInt32());return i}readFloatArray(){let e=this.readInt32(),i=[];for(let r=0;r<e;r++){let s=this.readFloat32();i.push(s)}return i}readIntArray(){let e=this.readInt32(),i=[];for(let r=0;r<e;r++){let s=this.readInt32();i.push(s)}return i}readVector2int(){let e=new Ne;return e.x=this.readInt32(),e.y=this.readInt32(),e}readVector2(){let e=new Ne;return e.x=this.readFloat32(),e.y=this.readFloat32(),e}readVector3(){let e=new p;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e}readVector3Array(){let e=[],i=this.readInt32();for(let r=0;r<i;r++)e.push(this.readVector3());return e}readVector4(){let e=new oe;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readVector4Array(){let e=[],i=this.readInt32();for(let r=0;r<i;r++)e.push(this.readVector4());return e}readColor(){let e=new Y;return e.r=this.readFloat32(),e.g=this.readFloat32(),e.b=this.readFloat32(),e.a=this.readFloat32(),e}readColorArray(){let e=[],i=this.readInt32();for(let r=0;r<i;r++)e.push(this.readColor());return e}readQuaternion(){let e=new ye;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readQuaternionArray(){let e=[],i=this.readInt32();for(let r=0;r<i;r++)e.push(this.readQuaternion());return e}readMatrix44(){let e=new te,i=e.rawData;return i[0]=this.readFloat32(),i[1]=this.readFloat32(),i[2]=this.readFloat32(),i[3]=this.readFloat32(),i[4]=this.readFloat32(),i[5]=this.readFloat32(),i[6]=this.readFloat32(),i[7]=this.readFloat32(),i[8]=this.readFloat32(),i[9]=this.readFloat32(),i[10]=this.readFloat32(),i[11]=this.readFloat32(),i[12]=this.readFloat32(),i[13]=this.readFloat32(),i[14]=this.readFloat32(),i[15]=this.readFloat32(),e}readMatrix44Array(){let e=this.readInt32(),i=[];for(let r=0;r<e;r++){let s=this.readMatrix44();i.push(s)}return i}readFloat32Array(e){let i=new Float32Array(this.buffer,this.position,e);return i=i.slice(0,this.byteLength),this.position+=e*Float32Array.BYTES_PER_ELEMENT,i}getFloat32Array(){let e=new Float32Array(this.buffer,this.byteOffset,this.byteLength/Float32Array.BYTES_PER_ELEMENT);return e=e.slice(0,this.byteLength),e}}class pg extends Vt{static async parserTexture(e,i,r){let s=e.readInt32(),a=[];for(let l=0;l<s;l++){let h=e.readUTF();nh.useWebp?(h=h.replace("png","webp"),h=h.replace("jpb","webp"),a.push(i.baseUrl+"webp/"+h)):a.push(i.baseUrl+h)}let o=await I.res.loadBitmapTextures(a,I.setting.loader.numConcurrent,r,!0);for(const l of o)I.res.addTexture(l.name,l)}verification(){if(this.data)return!0;throw new Error("verify failed.")}}n(pg,"format",xt.TEXT);function gb(t){if(t&&!(typeof window>"u")){var e=document.createElement("style");return e.setAttribute("type","text/css"),e.innerHTML=t,document.head.appendChild(e),t}}function Ls(t,e){var i=t.__state.conversionName.toString(),r=Math.round(t.r),s=Math.round(t.g),a=Math.round(t.b),o=t.a,l=Math.round(t.h),h=t.s.toFixed(1),u=t.v.toFixed(1);if(e||i==="THREE_CHAR_HEX"||i==="SIX_CHAR_HEX"){for(var c=t.hex.toString(16);c.length<6;)c="0"+c;return"#"+c}else{if(i==="CSS_RGB")return"rgb("+r+","+s+","+a+")";if(i==="CSS_RGBA")return"rgba("+r+","+s+","+a+","+o+")";if(i==="HEX")return"0x"+t.hex.toString(16);if(i==="RGB_ARRAY")return"["+r+","+s+","+a+"]";if(i==="RGBA_ARRAY")return"["+r+","+s+","+a+","+o+"]";if(i==="RGB_OBJ")return"{r:"+r+",g:"+s+",b:"+a+"}";if(i==="RGBA_OBJ")return"{r:"+r+",g:"+s+",b:"+a+",a:"+o+"}";if(i==="HSV_OBJ")return"{h:"+l+",s:"+h+",v:"+u+"}";if(i==="HSVA_OBJ")return"{h:"+l+",s:"+h+",v:"+u+",a:"+o+"}"}return"unknown format"}var Oc=Array.prototype.forEach,fa=Array.prototype.slice,L={BREAK:{},extend:function(t){return this.each(fa.call(arguments,1),function(e){var i=this.isObject(e)?Object.keys(e):[];i.forEach((function(r){this.isUndefined(e[r])||(t[r]=e[r])}).bind(this))},this),t},defaults:function(t){return this.each(fa.call(arguments,1),function(e){var i=this.isObject(e)?Object.keys(e):[];i.forEach((function(r){this.isUndefined(t[r])&&(t[r]=e[r])}).bind(this))},this),t},compose:function(){var t=fa.call(arguments);return function(){for(var e=fa.call(arguments),i=t.length-1;i>=0;i--)e=[t[i].apply(this,e)];return e[0]}},each:function(t,e,i){if(t){if(Oc&&t.forEach&&t.forEach===Oc)t.forEach(e,i);else if(t.length===t.length+0){var r=void 0,s=void 0;for(r=0,s=t.length;r<s;r++)if(r in t&&e.call(i,t[r],r)===this.BREAK)return}else for(var a in t)if(e.call(i,t[a],a)===this.BREAK)return}},defer:function(t){setTimeout(t,0)},debounce:function(t,e,i){var r=void 0;return function(){var s=this,a=arguments;function o(){r=null,i||t.apply(s,a)}var l=i||!r;clearTimeout(r),r=setTimeout(o,e),l&&t.apply(s,a)}},toArray:function(t){return t.toArray?t.toArray():fa.call(t)},isUndefined:function(t){return t===void 0},isNull:function(t){return t===null},isNaN:function(t){function e(i){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}(function(t){return isNaN(t)}),isArray:Array.isArray||function(t){return t.constructor===Array},isObject:function(t){return t===Object(t)},isNumber:function(t){return t===t+0},isString:function(t){return t===t+""},isBoolean:function(t){return t===!1||t===!0},isFunction:function(t){return t instanceof Function}},pb=[{litmus:L.isString,conversions:{THREE_CHAR_HEX:{read:function(t){var e=t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return e===null?!1:{space:"HEX",hex:parseInt("0x"+e[1].toString()+e[1].toString()+e[2].toString()+e[2].toString()+e[3].toString()+e[3].toString(),0)}},write:Ls},SIX_CHAR_HEX:{read:function(t){var e=t.match(/^#([A-F0-9]{6})$/i);return e===null?!1:{space:"HEX",hex:parseInt("0x"+e[1].toString(),0)}},write:Ls},CSS_RGB:{read:function(t){var e=t.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return e===null?!1:{space:"RGB",r:parseFloat(e[1]),g:parseFloat(e[2]),b:parseFloat(e[3])}},write:Ls},CSS_RGBA:{read:function(t){var e=t.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return e===null?!1:{space:"RGB",r:parseFloat(e[1]),g:parseFloat(e[2]),b:parseFloat(e[3]),a:parseFloat(e[4])}},write:Ls}}},{litmus:L.isNumber,conversions:{HEX:{read:function(t){return{space:"HEX",hex:t,conversionName:"HEX"}},write:function(t){return t.hex}}}},{litmus:L.isArray,conversions:{RGB_ARRAY:{read:function(t){return t.length!==3?!1:{space:"RGB",r:t[0],g:t[1],b:t[2]}},write:function(t){return[t.r,t.g,t.b]}},RGBA_ARRAY:{read:function(t){return t.length!==4?!1:{space:"RGB",r:t[0],g:t[1],b:t[2],a:t[3]}},write:function(t){return[t.r,t.g,t.b,t.a]}}}},{litmus:L.isObject,conversions:{RGBA_OBJ:{read:function(t){return L.isNumber(t.r)&&L.isNumber(t.g)&&L.isNumber(t.b)&&L.isNumber(t.a)?{space:"RGB",r:t.r,g:t.g,b:t.b,a:t.a}:!1},write:function(t){return{r:t.r,g:t.g,b:t.b,a:t.a}}},RGB_OBJ:{read:function(t){return L.isNumber(t.r)&&L.isNumber(t.g)&&L.isNumber(t.b)?{space:"RGB",r:t.r,g:t.g,b:t.b}:!1},write:function(t){return{r:t.r,g:t.g,b:t.b}}},HSVA_OBJ:{read:function(t){return L.isNumber(t.h)&&L.isNumber(t.s)&&L.isNumber(t.v)&&L.isNumber(t.a)?{space:"HSV",h:t.h,s:t.s,v:t.v,a:t.a}:!1},write:function(t){return{h:t.h,s:t.s,v:t.v,a:t.a}}},HSV_OBJ:{read:function(t){return L.isNumber(t.h)&&L.isNumber(t.s)&&L.isNumber(t.v)?{space:"HSV",h:t.h,s:t.s,v:t.v}:!1},write:function(t){return{h:t.h,s:t.s,v:t.v}}}}}],ga=void 0,wn=void 0,eh=function(){wn=!1;var t=arguments.length>1?L.toArray(arguments):arguments[0];return L.each(pb,function(e){if(e.litmus(t))return L.each(e.conversions,function(i,r){if(ga=i.read(t),wn===!1&&ga!==!1)return wn=ga,ga.conversionName=r,ga.conversion=i,L.BREAK}),L.BREAK}),wn},Nc=void 0,Sn={hsv_to_rgb:function(t,e,i){var r=Math.floor(t/60)%6,s=t/60-Math.floor(t/60),a=i*(1-e),o=i*(1-s*e),l=i*(1-(1-s)*e),h=[[i,l,a],[o,i,a],[a,i,l],[a,o,i],[l,a,i],[i,a,o]][r];return{r:h[0]*255,g:h[1]*255,b:h[2]*255}},rgb_to_hsv:function(t,e,i){var r=Math.min(t,e,i),s=Math.max(t,e,i),a=s-r,o=void 0,l=void 0;if(s!==0)l=a/s;else return{h:NaN,s:0,v:0};return t===s?o=(e-i)/a:e===s?o=2+(i-t)/a:o=4+(t-e)/a,o/=6,o<0&&(o+=1),{h:o*360,s:l,v:s/255}},rgb_to_hex:function(t,e,i){var r=this.hex_with_component(0,2,t);return r=this.hex_with_component(r,1,e),r=this.hex_with_component(r,0,i),r},component_from_hex:function(t,e){return t>>e*8&255},hex_with_component:function(t,e,i){return i<<(Nc=e*8)|t&~(255<<Nc)}},mb=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ii=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},wi=function(){function t(e,i){for(var r=0;r<i.length;r++){var s=i[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}return function(e,i,r){return i&&t(e.prototype,i),r&&t(e,r),e}}(),Pr=function t(e,i,r){e===null&&(e=Function.prototype);var s=Object.getOwnPropertyDescriptor(e,i);if(s===void 0){var a=Object.getPrototypeOf(e);return a===null?void 0:t(a,i,r)}else{if("value"in s)return s.value;var o=s.get;return o===void 0?void 0:o.call(r)}},Nr=function(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},Fr=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e&&(typeof e=="object"||typeof e=="function")?e:t},gt=function(){function t(){if(Ii(this,t),this.__state=eh.apply(this,arguments),this.__state===!1)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return wi(t,[{key:"toString",value:function(){return Ls(this)}},{key:"toHexString",value:function(){return Ls(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),t}();function sl(t,e,i){Object.defineProperty(t,e,{get:function(){return this.__state.space==="RGB"?this.__state[e]:(gt.recalculateRGB(this,e,i),this.__state[e])},set:function(r){this.__state.space!=="RGB"&&(gt.recalculateRGB(this,e,i),this.__state.space="RGB"),this.__state[e]=r}})}function al(t,e){Object.defineProperty(t,e,{get:function(){return this.__state.space==="HSV"?this.__state[e]:(gt.recalculateHSV(this),this.__state[e])},set:function(i){this.__state.space!=="HSV"&&(gt.recalculateHSV(this),this.__state.space="HSV"),this.__state[e]=i}})}gt.recalculateRGB=function(t,e,i){if(t.__state.space==="HEX")t.__state[e]=Sn.component_from_hex(t.__state.hex,i);else if(t.__state.space==="HSV")L.extend(t.__state,Sn.hsv_to_rgb(t.__state.h,t.__state.s,t.__state.v));else throw new Error("Corrupted color state")},gt.recalculateHSV=function(t){var e=Sn.rgb_to_hsv(t.r,t.g,t.b);L.extend(t.__state,{s:e.s,v:e.v}),L.isNaN(e.h)?L.isUndefined(t.__state.h)&&(t.__state.h=0):t.__state.h=e.h},gt.COMPONENTS=["r","g","b","h","s","v","hex","a"],sl(gt.prototype,"r",2),sl(gt.prototype,"g",1),sl(gt.prototype,"b",0),al(gt.prototype,"h"),al(gt.prototype,"s"),al(gt.prototype,"v"),Object.defineProperty(gt.prototype,"a",{get:function(){return this.__state.a},set:function(t){this.__state.a=t}}),Object.defineProperty(gt.prototype,"hex",{get:function(){return this.__state.space!=="HEX"&&(this.__state.hex=Sn.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(t){this.__state.space="HEX",this.__state.hex=t}});var As=function(){function t(e,i){Ii(this,t),this.initialValue=e[i],this.domElement=document.createElement("div"),this.object=e,this.property=i,this.__onChange=void 0,this.__onFinishChange=void 0}return wi(t,[{key:"onChange",value:function(e){return this.__onChange=e,this}},{key:"onFinishChange",value:function(e){return this.__onFinishChange=e,this}},{key:"setValue",value:function(e){return this.object[this.property]=e,this.__onChange&&this.__onChange.call(this,e),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),t}(),Ab={HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},mg={};L.each(Ab,function(t,e){L.each(t,function(i){mg[i]=e})});var _b=/(\d+(\.\d+)?)px/;function Ti(t){if(t==="0"||L.isUndefined(t))return 0;var e=t.match(_b);return L.isNull(e)?0:parseFloat(e[1])}var B={makeSelectable:function(t,e){t===void 0||t.style===void 0||(t.onselectstart=e?function(){return!1}:function(){},t.style.MozUserSelect=e?"auto":"none",t.style.KhtmlUserSelect=e?"auto":"none",t.unselectable=e?"on":"off")},makeFullscreen:function(t,e,i){var r=i,s=e;L.isUndefined(s)&&(s=!0),L.isUndefined(r)&&(r=!0),t.style.position="absolute",s&&(t.style.left=0,t.style.right=0),r&&(t.style.top=0,t.style.bottom=0)},fakeEvent:function(t,e,i,r){var s=i||{},a=mg[e];if(!a)throw new Error("Event type "+e+" not supported.");var o=document.createEvent(a);switch(a){case"MouseEvents":{var l=s.x||s.clientX||0,h=s.y||s.clientY||0;o.initMouseEvent(e,s.bubbles||!1,s.cancelable||!0,window,s.clickCount||1,0,0,l,h,!1,!1,!1,!1,0,null);break}case"KeyboardEvents":{var u=o.initKeyboardEvent||o.initKeyEvent;L.defaults(s,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),u(e,s.bubbles||!1,s.cancelable,window,s.ctrlKey,s.altKey,s.shiftKey,s.metaKey,s.keyCode,s.charCode);break}default:{o.initEvent(e,s.bubbles||!1,s.cancelable||!0);break}}L.defaults(o,r),t.dispatchEvent(o)},bind:function(t,e,i,r){var s=r||!1;return t.addEventListener?t.addEventListener(e,i,s):t.attachEvent&&t.attachEvent("on"+e,i),B},unbind:function(t,e,i,r){var s=r||!1;return t.removeEventListener?t.removeEventListener(e,i,s):t.detachEvent&&t.detachEvent("on"+e,i),B},addClass:function(t,e){if(t.className===void 0)t.className=e;else if(t.className!==e){var i=t.className.split(/ +/);i.indexOf(e)===-1&&(i.push(e),t.className=i.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return B},removeClass:function(t,e){if(e)if(t.className===e)t.removeAttribute("class");else{var i=t.className.split(/ +/),r=i.indexOf(e);r!==-1&&(i.splice(r,1),t.className=i.join(" "))}else t.className=void 0;return B},hasClass:function(t,e){return new RegExp("(?:^|\\s+)"+e+"(?:\\s+|$)").test(t.className)||!1},getWidth:function(t){var e=getComputedStyle(t);return Ti(e["border-left-width"])+Ti(e["border-right-width"])+Ti(e["padding-left"])+Ti(e["padding-right"])+Ti(e.width)},getHeight:function(t){var e=getComputedStyle(t);return Ti(e["border-top-width"])+Ti(e["border-bottom-width"])+Ti(e["padding-top"])+Ti(e["padding-bottom"])+Ti(e.height)},getOffset:function(t){var e=t,i={left:0,top:0};if(e.offsetParent)do i.left+=e.offsetLeft,i.top+=e.offsetTop,e=e.offsetParent;while(e);return i},isActive:function(t){return t===document.activeElement&&(t.type||t.href)}},Ag=function(t){Nr(e,t);function e(i,r){Ii(this,e);var s=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r)),a=s;s.__prev=s.getValue(),s.__checkbox=document.createElement("input"),s.__checkbox.setAttribute("type","checkbox");function o(){a.setValue(!a.__prev)}return B.bind(s.__checkbox,"change",o,!1),s.domElement.appendChild(s.__checkbox),s.updateDisplay(),s}return wi(e,[{key:"setValue",value:function(i){var r=Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,i);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),r}},{key:"updateDisplay",value:function(){return this.getValue()===!0?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(As),vb=function(t){Nr(e,t);function e(i,r,s){Ii(this,e);var a=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r)),o=s,l=a;if(a.__select=document.createElement("select"),L.isArray(o)){var h={};L.each(o,function(u){h[u]=u}),o=h}return L.each(o,function(u,c){var d=document.createElement("option");d.innerHTML=c,d.setAttribute("value",u),l.__select.appendChild(d)}),a.updateDisplay(),B.bind(a.__select,"change",function(){var u=this.options[this.selectedIndex].value;l.setValue(u)}),a.domElement.appendChild(a.__select),a}return wi(e,[{key:"setValue",value:function(i){var r=Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,i);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),r}},{key:"updateDisplay",value:function(){return B.isActive(this.__select)?this:(this.__select.value=this.getValue(),Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this))}}]),e}(As),xb=function(t){Nr(e,t);function e(i,r){Ii(this,e);var s=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r)),a=s;function o(){a.setValue(a.__input.value)}function l(){a.__onFinishChange&&a.__onFinishChange.call(a,a.getValue())}return s.__input=document.createElement("input"),s.__input.setAttribute("type","text"),B.bind(s.__input,"keyup",o),B.bind(s.__input,"change",o),B.bind(s.__input,"blur",l),B.bind(s.__input,"keydown",function(h){h.keyCode===13&&this.blur()}),s.updateDisplay(),s.domElement.appendChild(s.__input),s}return wi(e,[{key:"updateDisplay",value:function(){return B.isActive(this.__input)||(this.__input.value=this.getValue()),Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(As);function Fc(t){var e=t.toString();return e.indexOf(".")>-1?e.length-e.indexOf(".")-1:0}var _g=function(t){Nr(e,t);function e(i,r,s){Ii(this,e);var a=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r)),o=s||{};return a.__min=o.min,a.__max=o.max,a.__step=o.step,L.isUndefined(a.__step)?a.initialValue===0?a.__impliedStep=1:a.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(a.initialValue))/Math.LN10))/10:a.__impliedStep=a.__step,a.__precision=Fc(a.__impliedStep),a}return wi(e,[{key:"setValue",value:function(i){var r=i;return this.__min!==void 0&&r<this.__min?r=this.__min:this.__max!==void 0&&r>this.__max&&(r=this.__max),this.__step!==void 0&&r%this.__step!==0&&(r=Math.round(r/this.__step)*this.__step),Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,r)}},{key:"min",value:function(i){return this.__min=i,this}},{key:"max",value:function(i){return this.__max=i,this}},{key:"step",value:function(i){return this.__step=i,this.__impliedStep=i,this.__precision=Fc(i),this}}]),e}(As);function yb(t,e){var i=Math.pow(10,e);return Math.round(t*i)/i}var co=function(t){Nr(e,t);function e(i,r,s){Ii(this,e);var a=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r,s));a.__truncationSuspended=!1;var o=a,l=void 0;function h(){var m=parseFloat(o.__input.value);L.isNaN(m)||o.setValue(m)}function u(){o.__onFinishChange&&o.__onFinishChange.call(o,o.getValue())}function c(){u()}function d(m){var A=l-m.clientY;o.setValue(o.getValue()+A*o.__impliedStep),l=m.clientY}function f(){B.unbind(window,"mousemove",d),B.unbind(window,"mouseup",f),u()}function g(m){B.bind(window,"mousemove",d),B.bind(window,"mouseup",f),l=m.clientY}return a.__input=document.createElement("input"),a.__input.setAttribute("type","text"),B.bind(a.__input,"change",h),B.bind(a.__input,"blur",c),B.bind(a.__input,"mousedown",g),B.bind(a.__input,"keydown",function(m){m.keyCode===13&&(o.__truncationSuspended=!0,this.blur(),o.__truncationSuspended=!1,u())}),a.updateDisplay(),a.domElement.appendChild(a.__input),a}return wi(e,[{key:"updateDisplay",value:function(){return this.__input.value=this.__truncationSuspended?this.getValue():yb(this.getValue(),this.__precision),Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(_g);function kc(t,e,i,r,s){return r+(s-r)*((t-e)/(i-e))}var th=function(t){Nr(e,t);function e(i,r,s,a,o){Ii(this,e);var l=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r,{min:s,max:a,step:o})),h=l;l.__background=document.createElement("div"),l.__foreground=document.createElement("div"),B.bind(l.__background,"mousedown",u),B.bind(l.__background,"touchstart",f),B.addClass(l.__background,"slider"),B.addClass(l.__foreground,"slider-fg");function u(A){document.activeElement.blur(),B.bind(window,"mousemove",c),B.bind(window,"mouseup",d),c(A)}function c(A){A.preventDefault();var _=h.__background.getBoundingClientRect();return h.setValue(kc(A.clientX,_.left,_.right,h.__min,h.__max)),!1}function d(){B.unbind(window,"mousemove",c),B.unbind(window,"mouseup",d),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}function f(A){A.touches.length===1&&(B.bind(window,"touchmove",g),B.bind(window,"touchend",m),g(A))}function g(A){var _=A.touches[0].clientX,x=h.__background.getBoundingClientRect();h.setValue(kc(_,x.left,x.right,h.__min,h.__max))}function m(){B.unbind(window,"touchmove",g),B.unbind(window,"touchend",m),h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())}return l.updateDisplay(),l.__background.appendChild(l.__foreground),l.domElement.appendChild(l.__background),l}return wi(e,[{key:"updateDisplay",value:function(){var i=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=i*100+"%",Pr(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(_g),vg=function(t){Nr(e,t);function e(i,r,s){Ii(this,e);var a=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r)),o=a;return a.__button=document.createElement("div"),a.__button.innerHTML=s===void 0?"Fire":s,B.bind(a.__button,"click",function(l){return l.preventDefault(),o.fire(),!1}),B.addClass(a.__button,"button"),a.domElement.appendChild(a.__button),a}return wi(e,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),e}(As),ih=function(t){Nr(e,t);function e(i,r){Ii(this,e);var s=Fr(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,i,r));s.__color=new gt(s.getValue()),s.__temp=new gt(0);var a=s;s.domElement=document.createElement("div"),B.makeSelectable(s.domElement,!1),s.__selector=document.createElement("div"),s.__selector.className="selector",s.__saturation_field=document.createElement("div"),s.__saturation_field.className="saturation-field",s.__field_knob=document.createElement("div"),s.__field_knob.className="field-knob",s.__field_knob_border="2px solid ",s.__hue_knob=document.createElement("div"),s.__hue_knob.className="hue-knob",s.__hue_field=document.createElement("div"),s.__hue_field.className="hue-field",s.__input=document.createElement("input"),s.__input.type="text",s.__input_textShadow="0 1px 1px ",B.bind(s.__input,"keydown",function(A){A.keyCode===13&&d.call(this)}),B.bind(s.__input,"blur",d),B.bind(s.__selector,"mousedown",function(){B.addClass(this,"drag").bind(window,"mouseup",function(){B.removeClass(a.__selector,"drag")})}),B.bind(s.__selector,"touchstart",function(){B.addClass(this,"drag").bind(window,"touchend",function(){B.removeClass(a.__selector,"drag")})});var o=document.createElement("div");L.extend(s.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),L.extend(s.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:s.__field_knob_border+(s.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),L.extend(s.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),L.extend(s.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),L.extend(o.style,{width:"100%",height:"100%",background:"none"}),Qc(o,"top","rgba(0,0,0,0)","#000"),L.extend(s.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),bb(s.__hue_field),L.extend(s.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:s.__input_textShadow+"rgba(0,0,0,0.7)"}),B.bind(s.__saturation_field,"mousedown",l),B.bind(s.__saturation_field,"touchstart",l),B.bind(s.__field_knob,"mousedown",l),B.bind(s.__field_knob,"touchstart",l),B.bind(s.__hue_field,"mousedown",h),B.bind(s.__hue_field,"touchstart",h);function l(A){g(A),B.bind(window,"mousemove",g),B.bind(window,"touchmove",g),B.bind(window,"mouseup",u),B.bind(window,"touchend",u)}function h(A){m(A),B.bind(window,"mousemove",m),B.bind(window,"touchmove",m),B.bind(window,"mouseup",c),B.bind(window,"touchend",c)}function u(){B.unbind(window,"mousemove",g),B.unbind(window,"touchmove",g),B.unbind(window,"mouseup",u),B.unbind(window,"touchend",u),f()}function c(){B.unbind(window,"mousemove",m),B.unbind(window,"touchmove",m),B.unbind(window,"mouseup",c),B.unbind(window,"touchend",c),f()}function d(){var A=eh(this.value);A!==!1?(a.__color.__state=A,a.setValue(a.__color.toOriginal())):this.value=a.__color.toString()}function f(){a.__onFinishChange&&a.__onFinishChange.call(a,a.__color.toOriginal())}s.__saturation_field.appendChild(o),s.__selector.appendChild(s.__field_knob),s.__selector.appendChild(s.__saturation_field),s.__selector.appendChild(s.__hue_field),s.__hue_field.appendChild(s.__hue_knob),s.domElement.appendChild(s.__input),s.domElement.appendChild(s.__selector),s.updateDisplay();function g(A){A.type.indexOf("touch")===-1&&A.preventDefault();var _=a.__saturation_field.getBoundingClientRect(),x=A.touches&&A.touches[0]||A,b=x.clientX,R=x.clientY,E=(b-_.left)/(_.right-_.left),M=1-(R-_.top)/(_.bottom-_.top);return M>1?M=1:M<0&&(M=0),E>1?E=1:E<0&&(E=0),a.__color.v=M,a.__color.s=E,a.setValue(a.__color.toOriginal()),!1}function m(A){A.type.indexOf("touch")===-1&&A.preventDefault();var _=a.__hue_field.getBoundingClientRect(),x=A.touches&&A.touches[0]||A,b=x.clientY,R=1-(b-_.top)/(_.bottom-_.top);return R>1?R=1:R<0&&(R=0),a.__color.h=R*360,a.setValue(a.__color.toOriginal()),!1}return s}return wi(e,[{key:"updateDisplay",value:function(){var i=eh(this.getValue());if(i!==!1){var r=!1;L.each(gt.COMPONENTS,function(o){if(!L.isUndefined(i[o])&&!L.isUndefined(this.__color.__state[o])&&i[o]!==this.__color.__state[o])return r=!0,{}},this),r&&L.extend(this.__color.__state,i)}L.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var s=this.__color.v<.5||this.__color.s>.5?255:0,a=255-s;L.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+s+","+s+","+s+")"}),this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+"px",this.__temp.s=1,this.__temp.v=1,Qc(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),L.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+s+","+s+","+s+")",textShadow:this.__input_textShadow+"rgba("+a+","+a+","+a+",.7)"})}}]),e}(As),Cb=["-moz-","-o-","-webkit-","-ms-",""];function Qc(t,e,i,r){t.style.background="",L.each(Cb,function(s){t.style.cssText+="background: "+s+"linear-gradient("+e+", "+i+" 0%, "+r+" 100%); "})}function bb(t){t.style.background="",t.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",t.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",t.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",t.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",t.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}var Ib={load:function(t,e){var i=e||document,r=i.createElement("link");r.type="text/css",r.rel="stylesheet",r.href=t,i.getElementsByTagName("head")[0].appendChild(r)},inject:function(t,e){var i=e||document,r=document.createElement("style");r.type="text/css",r.innerHTML=t;var s=i.getElementsByTagName("head")[0];try{s.appendChild(r)}catch{}}},wb=`<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,Sb=function(t,e){var i=t[e];return L.isArray(arguments[2])||L.isObject(arguments[2])?new vb(t,e,arguments[2]):L.isNumber(i)?L.isNumber(arguments[2])&&L.isNumber(arguments[3])?L.isNumber(arguments[4])?new th(t,e,arguments[2],arguments[3],arguments[4]):new th(t,e,arguments[2],arguments[3]):L.isNumber(arguments[4])?new co(t,e,{min:arguments[2],max:arguments[3],step:arguments[4]}):new co(t,e,{min:arguments[2],max:arguments[3]}):L.isString(i)?new xb(t,e):L.isFunction(i)?new vg(t,e,""):L.isBoolean(i)?new Ag(t,e):null};function Eb(t){setTimeout(t,1e3/60)}var Tb=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||Eb,Bb=function(){function t(){Ii(this,t),this.backgroundElement=document.createElement("div"),L.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),B.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),L.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var e=this;B.bind(this.backgroundElement,"click",function(){e.hide()})}return wi(t,[{key:"show",value:function(){var e=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),L.defer(function(){e.backgroundElement.style.opacity=1,e.domElement.style.opacity=1,e.domElement.style.webkitTransform="scale(1)"})}},{key:"hide",value:function(){var e=this,i=function r(){e.domElement.style.display="none",e.backgroundElement.style.display="none",B.unbind(e.domElement,"webkitTransitionEnd",r),B.unbind(e.domElement,"transitionend",r),B.unbind(e.domElement,"oTransitionEnd",r)};B.bind(this.domElement,"webkitTransitionEnd",i),B.bind(this.domElement,"transitionend",i),B.bind(this.domElement,"oTransitionEnd",i),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-B.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-B.getHeight(this.domElement)/2+"px"}}]),t}(),Db=gb(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);Ib.inject(Db);var zc="dg",Gc=72,Vc=20,sn="Default",Ba=function(){try{return!!window.localStorage}catch{return!1}}(),Ya=void 0,Hc=!0,Bs=void 0,nl=!1,xg=[],Ve=function t(e){var i=this,r=e||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),B.addClass(this.domElement,zc),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],r=L.defaults(r,{closeOnTop:!1,autoPlace:!0,width:t.DEFAULT_WIDTH}),r=L.defaults(r,{resizable:r.autoPlace,hideable:r.autoPlace}),L.isUndefined(r.load)?r.load={preset:sn}:r.preset&&(r.load.preset=r.preset),L.isUndefined(r.parent)&&r.hideable&&xg.push(this),r.resizable=L.isUndefined(r.parent)&&r.resizable,r.autoPlace&&L.isUndefined(r.scrollable)&&(r.scrollable=!0);var s=Ba&&localStorage.getItem(Ds(this,"isLocal"))==="true",a=void 0,o=void 0;if(Object.defineProperties(this,{parent:{get:function(){return r.parent}},scrollable:{get:function(){return r.scrollable}},autoPlace:{get:function(){return r.autoPlace}},closeOnTop:{get:function(){return r.closeOnTop}},preset:{get:function(){return i.parent?i.getRoot().preset:r.load.preset},set:function(d){i.parent?i.getRoot().preset=d:r.load.preset=d,Ub(this),i.revert()}},width:{get:function(){return r.width},set:function(d){r.width=d,ah(i,d)}},name:{get:function(){return r.name},set:function(d){r.name=d,o&&(o.innerHTML=r.name)}},closed:{get:function(){return r.closed},set:function(d){r.closed=d,r.closed?B.addClass(i.__ul,t.CLASS_CLOSED):B.removeClass(i.__ul,t.CLASS_CLOSED),this.onResize(),i.__closeButton&&(i.__closeButton.innerHTML=d?t.TEXT_OPEN:t.TEXT_CLOSED)}},load:{get:function(){return r.load}},useLocalStorage:{get:function(){return s},set:function(d){Ba&&(s=d,d?B.bind(window,"unload",a):B.unbind(window,"unload",a),localStorage.setItem(Ds(i,"isLocal"),d))}}}),L.isUndefined(r.parent)){if(this.closed=r.closed||!1,B.addClass(this.domElement,t.CLASS_MAIN),B.makeSelectable(this.domElement,!1),Ba&&s){i.useLocalStorage=!0;var l=localStorage.getItem(Ds(this,"gui"));l&&(r.load=JSON.parse(l))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=t.TEXT_CLOSED,B.addClass(this.__closeButton,t.CLASS_CLOSE_BUTTON),r.closeOnTop?(B.addClass(this.__closeButton,t.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(B.addClass(this.__closeButton,t.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),B.bind(this.__closeButton,"click",function(){i.closed=!i.closed})}else{r.closed===void 0&&(r.closed=!0);var h=document.createTextNode(r.name);B.addClass(h,"controller-name"),o=tu(i,h);var u=function(d){return d.preventDefault(),i.closed=!i.closed,!1};B.addClass(this.__ul,t.CLASS_CLOSED),B.addClass(o,"title"),B.bind(o,"click",u),r.closed||(this.closed=!1)}r.autoPlace&&(L.isUndefined(r.parent)&&(Hc&&(Bs=document.createElement("div"),B.addClass(Bs,zc),B.addClass(Bs,t.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(Bs),Hc=!1),Bs.appendChild(this.domElement),B.addClass(this.domElement,t.CLASS_AUTO_PLACE)),this.parent||ah(i,r.width)),this.__resizeHandler=function(){i.onResizeDebounced()},B.bind(window,"resize",this.__resizeHandler),B.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),B.bind(this.__ul,"transitionend",this.__resizeHandler),B.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),r.resizable&&Pb(this),a=function(){Ba&&localStorage.getItem(Ds(i,"isLocal"))==="true"&&localStorage.setItem(Ds(i,"gui"),JSON.stringify(i.getSaveObject()))},this.saveToLocalStorageIfPossible=a;function c(){var d=i.getRoot();d.width+=1,L.defer(function(){d.width-=1})}r.parent||c()};Ve.toggleHide=function(){nl=!nl,L.each(xg,function(t){t.domElement.style.display=nl?"none":""})},Ve.CLASS_AUTO_PLACE="a",Ve.CLASS_AUTO_PLACE_CONTAINER="ac",Ve.CLASS_MAIN="main",Ve.CLASS_CONTROLLER_ROW="cr",Ve.CLASS_TOO_TALL="taller-than-window",Ve.CLASS_CLOSED="closed",Ve.CLASS_CLOSE_BUTTON="close-button",Ve.CLASS_CLOSE_TOP="close-top",Ve.CLASS_CLOSE_BOTTOM="close-bottom",Ve.CLASS_DRAG="drag",Ve.DEFAULT_WIDTH=245,Ve.TEXT_CLOSED="Close Controls",Ve.TEXT_OPEN="Open Controls",Ve._keydownHandler=function(t){document.activeElement.type!=="text"&&(t.which===Gc||t.keyCode===Gc)&&Ve.toggleHide()},B.bind(window,"keydown",Ve._keydownHandler,!1),L.extend(Ve.prototype,{add:function(t,e){return Xa(this,t,e,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(t,e){return Xa(this,t,e,{color:!0})},remove:function(t){this.__ul.removeChild(t.__li),this.__controllers.splice(this.__controllers.indexOf(t),1);var e=this;L.defer(function(){e.onResize()})},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&Bs.removeChild(this.domElement);var t=this;L.each(this.__folders,function(e){t.removeFolder(e)}),B.unbind(window,"keydown",Ve._keydownHandler,!1),Yc(this)},addFolder:function(t){if(this.__folders[t]!==void 0)throw new Error('You already have a folder in this GUI by the name "'+t+'"');var e={name:t,parent:this};e.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[t]&&(e.closed=this.load.folders[t].closed,e.load=this.load.folders[t]);var i=new Ve(e);this.__folders[t]=i;var r=tu(this,i.domElement);return B.addClass(r,"folder"),i},removeFolder:function(t){this.__ul.removeChild(t.domElement.parentElement),delete this.__folders[t.name],this.load&&this.load.folders&&this.load.folders[t.name]&&delete this.load.folders[t.name],Yc(t);var e=this;L.each(t.__folders,function(i){t.removeFolder(i)}),L.defer(function(){e.onResize()})},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var t=this.getRoot();if(t.scrollable){var e=B.getOffset(t.__ul).top,i=0;L.each(t.__ul.childNodes,function(r){t.autoPlace&&r===t.__save_row||(i+=B.getHeight(r))}),window.innerHeight-e-Vc<i?(B.addClass(t.domElement,Ve.CLASS_TOO_TALL),t.__ul.style.height=window.innerHeight-e-Vc+"px"):(B.removeClass(t.domElement,Ve.CLASS_TOO_TALL),t.__ul.style.height="auto")}t.__resize_handle&&L.defer(function(){t.__resize_handle.style.height=t.__ul.offsetHeight+"px"}),t.__closeButton&&(t.__closeButton.style.width=t.width+"px")},onResizeDebounced:L.debounce(function(){this.onResize()},50),remember:function(){if(L.isUndefined(Ya)&&(Ya=new Bb,Ya.domElement.innerHTML=wb),this.parent)throw new Error("You can only call remember on a top level GUI.");var t=this;L.each(Array.prototype.slice.call(arguments),function(e){t.__rememberedObjects.length===0&&Mb(t),t.__rememberedObjects.indexOf(e)===-1&&t.__rememberedObjects.push(e)}),this.autoPlace&&ah(this,this.width)},getRoot:function(){for(var t=this;t.parent;)t=t.parent;return t},getSaveObject:function(){var t=this.load;return t.closed=this.closed,this.__rememberedObjects.length>0&&(t.preset=this.preset,t.remembered||(t.remembered={}),t.remembered[this.preset]=En(this)),t.folders={},L.each(this.__folders,function(e,i){t.folders[i]=e.getSaveObject()}),t},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=En(this),rh(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(t){this.load.remembered||(this.load.remembered={},this.load.remembered[sn]=En(this,!0)),this.load.remembered[t]=En(this),this.preset=t,sh(this,t,!0),this.saveToLocalStorageIfPossible()},revert:function(t){L.each(this.__controllers,function(e){this.getRoot().load.remembered?yg(t||this.getRoot(),e):e.setValue(e.initialValue),e.__onFinishChange&&e.__onFinishChange.call(e,e.getValue())},this),L.each(this.__folders,function(e){e.revert(e)}),t||rh(this.getRoot(),!1)},listen:function(t){var e=this.__listening.length===0;this.__listening.push(t),e&&Cg(this.__listening)},updateDisplay:function(){L.each(this.__controllers,function(t){t.updateDisplay()}),L.each(this.__folders,function(t){t.updateDisplay()})}});function tu(t,e,i){var r=document.createElement("li");return e&&r.appendChild(e),i?t.__ul.insertBefore(r,i):t.__ul.appendChild(r),t.onResize(),r}function Yc(t){B.unbind(window,"resize",t.__resizeHandler),t.saveToLocalStorageIfPossible&&B.unbind(window,"unload",t.saveToLocalStorageIfPossible)}function rh(t,e){var i=t.__preset_select[t.__preset_select.selectedIndex];e?i.innerHTML=i.value+"*":i.innerHTML=i.value}function Rb(t,e,i){if(i.__li=e,i.__gui=t,L.extend(i,{options:function(a){if(arguments.length>1){var o=i.__li.nextElementSibling;return i.remove(),Xa(t,i.object,i.property,{before:o,factoryArgs:[L.toArray(arguments)]})}if(L.isArray(a)||L.isObject(a)){var l=i.__li.nextElementSibling;return i.remove(),Xa(t,i.object,i.property,{before:l,factoryArgs:[a]})}},name:function(a){return i.__li.firstElementChild.firstElementChild.innerHTML=a,i},listen:function(){return i.__gui.listen(i),i},remove:function(){return i.__gui.remove(i),i}}),i instanceof th){var r=new co(i.object,i.property,{min:i.__min,max:i.__max,step:i.__step});L.each(["updateDisplay","onChange","onFinishChange","step","min","max"],function(a){var o=i[a],l=r[a];i[a]=r[a]=function(){var h=Array.prototype.slice.call(arguments);return l.apply(r,h),o.apply(i,h)}}),B.addClass(e,"has-slider"),i.domElement.insertBefore(r.domElement,i.domElement.firstElementChild)}else if(i instanceof co){var s=function(a){if(L.isNumber(i.__min)&&L.isNumber(i.__max)){var o=i.__li.firstElementChild.firstElementChild.innerHTML,l=i.__gui.__listening.indexOf(i)>-1;i.remove();var h=Xa(t,i.object,i.property,{before:i.__li.nextElementSibling,factoryArgs:[i.__min,i.__max,i.__step]});return h.name(o),l&&h.listen(),h}return a};i.min=L.compose(s,i.min),i.max=L.compose(s,i.max)}else i instanceof Ag?(B.bind(e,"click",function(){B.fakeEvent(i.__checkbox,"click")}),B.bind(i.__checkbox,"click",function(a){a.stopPropagation()})):i instanceof vg?(B.bind(e,"click",function(){B.fakeEvent(i.__button,"click")}),B.bind(e,"mouseover",function(){B.addClass(i.__button,"hover")}),B.bind(e,"mouseout",function(){B.removeClass(i.__button,"hover")})):i instanceof ih&&(B.addClass(e,"color"),i.updateDisplay=L.compose(function(a){return e.style.borderLeftColor=i.__color.toString(),a},i.updateDisplay),i.updateDisplay());i.setValue=L.compose(function(a){return t.getRoot().__preset_select&&i.isModified()&&rh(t.getRoot(),!0),a},i.setValue)}function yg(t,e){var i=t.getRoot(),r=i.__rememberedObjects.indexOf(e.object);if(r!==-1){var s=i.__rememberedObjectIndecesToControllers[r];if(s===void 0&&(s={},i.__rememberedObjectIndecesToControllers[r]=s),s[e.property]=e,i.load&&i.load.remembered){var a=i.load.remembered,o=void 0;if(a[t.preset])o=a[t.preset];else if(a[sn])o=a[sn];else return;if(o[r]&&o[r][e.property]!==void 0){var l=o[r][e.property];e.initialValue=l,e.setValue(l)}}}}function Xa(t,e,i,r){if(e[i]===void 0)throw new Error('Object "'+e+'" has no property "'+i+'"');var s=void 0;if(r.color)s=new ih(e,i);else{var a=[e,i].concat(r.factoryArgs);s=Sb.apply(t,a)}r.before instanceof As&&(r.before=r.before.__li),yg(t,s),B.addClass(s.domElement,"c");var o=document.createElement("span");B.addClass(o,"property-name"),o.innerHTML=s.property;var l=document.createElement("div");l.appendChild(o),l.appendChild(s.domElement);var h=tu(t,l,r.before);return B.addClass(h,Ve.CLASS_CONTROLLER_ROW),s instanceof ih?B.addClass(h,"color"):B.addClass(h,mb(s.getValue())),Rb(t,h,s),t.__controllers.push(s),s}function Ds(t,e){return document.location.href+"."+e}function sh(t,e,i){var r=document.createElement("option");r.innerHTML=e,r.value=e,t.__preset_select.appendChild(r),i&&(t.__preset_select.selectedIndex=t.__preset_select.length-1)}function Xc(t,e){e.style.display=t.useLocalStorage?"block":"none"}function Mb(t){var e=t.__save_row=document.createElement("li");B.addClass(t.domElement,"has-save"),t.__ul.insertBefore(e,t.__ul.firstChild),B.addClass(e,"save-row");var i=document.createElement("span");i.innerHTML="&nbsp;",B.addClass(i,"button gears");var r=document.createElement("span");r.innerHTML="Save",B.addClass(r,"button"),B.addClass(r,"save");var s=document.createElement("span");s.innerHTML="New",B.addClass(s,"button"),B.addClass(s,"save-as");var a=document.createElement("span");a.innerHTML="Revert",B.addClass(a,"button"),B.addClass(a,"revert");var o=t.__preset_select=document.createElement("select");if(t.load&&t.load.remembered?L.each(t.load.remembered,function(d,f){sh(t,f,f===t.preset)}):sh(t,sn,!1),B.bind(o,"change",function(){for(var d=0;d<t.__preset_select.length;d++)t.__preset_select[d].innerHTML=t.__preset_select[d].value;t.preset=this.value}),e.appendChild(o),e.appendChild(i),e.appendChild(r),e.appendChild(s),e.appendChild(a),Ba){var l=document.getElementById("dg-local-explain"),h=document.getElementById("dg-local-storage"),u=document.getElementById("dg-save-locally");u.style.display="block",localStorage.getItem(Ds(t,"isLocal"))==="true"&&h.setAttribute("checked","checked"),Xc(t,l),B.bind(h,"change",function(){t.useLocalStorage=!t.useLocalStorage,Xc(t,l)})}var c=document.getElementById("dg-new-constructor");B.bind(c,"keydown",function(d){d.metaKey&&(d.which===67||d.keyCode===67)&&Ya.hide()}),B.bind(i,"click",function(){c.innerHTML=JSON.stringify(t.getSaveObject(),void 0,2),Ya.show(),c.focus(),c.select()}),B.bind(r,"click",function(){t.save()}),B.bind(s,"click",function(){var d=prompt("Enter a new preset name.");d&&t.saveAs(d)}),B.bind(a,"click",function(){t.revert()})}function Pb(t){var e=void 0;t.__resize_handle=document.createElement("div"),L.extend(t.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"});function i(a){return a.preventDefault(),t.width+=e-a.clientX,t.onResize(),e=a.clientX,!1}function r(){B.removeClass(t.__closeButton,Ve.CLASS_DRAG),B.unbind(window,"mousemove",i),B.unbind(window,"mouseup",r)}function s(a){return a.preventDefault(),e=a.clientX,B.addClass(t.__closeButton,Ve.CLASS_DRAG),B.bind(window,"mousemove",i),B.bind(window,"mouseup",r),!1}B.bind(t.__resize_handle,"mousedown",s),B.bind(t.__closeButton,"mousedown",s),t.domElement.insertBefore(t.__resize_handle,t.domElement.firstElementChild)}function ah(t,e){t.domElement.style.width=e+"px",t.__save_row&&t.autoPlace&&(t.__save_row.style.width=e+"px"),t.__closeButton&&(t.__closeButton.style.width=e+"px")}function En(t,e){var i={};return L.each(t.__rememberedObjects,function(r,s){var a={},o=t.__rememberedObjectIndecesToControllers[s];L.each(o,function(l,h){a[h]=e?l.initialValue:l.getValue()}),i[s]=a}),i}function Ub(t){for(var e=0;e<t.__preset_select.length;e++)t.__preset_select[e].value===t.preset&&(t.__preset_select.selectedIndex=e)}function Cg(t){t.length!==0&&Tb.call(window,function(){Cg(t)}),L.each(t,function(e){e.updateDisplay()})}var Kc=Ve;class Lb{constructor(){n(this,"debug",!1),n(this,"data"),n(this,"gui"),n(this,"bind"),n(this,"_current"),n(this,"_nullBind",{}),n(this,"folders",{}),this.data={},this.bind={},this._nullBind={},this._nullBind.onChange=()=>{}}init(e=10){this.debug=!0,this.gui=new Kc,this.gui.domElement.style.zIndex=`${e}`,this.gui.domElement.parentElement.style.zIndex=`${e}`,this.addFolder("Orillusion")}addCustom(e,i,r,s,a,o){if(!this.debug)return this._nullBind;let l=this._current?this._current:this.gui,h={[e]:i[r]};l.add(h,e,s,a,o).onChange(u=>{i[r]=u})}add(e,i,r,s,a){return this.debug?(this._current?this._current:this.gui).add(e,i,r,s,a):this._nullBind}addLabel(e){if(!this.debug)return this._nullBind;rt.add({label:e},"label")}addInfo(e,i){if(!this.debug)return this._nullBind;let r={};r[e]=i.toString(),rt.add(r,e)}addColor(e,i){if(!this.debug)return this._nullBind;let r=(this._current?this._current:this.gui).addColor(e[i],"rgba").name(i);return r.onChange(s=>{console.log(s);let a=e[i];a.rgba=s,e[i]=a}),r}addButton(e,i){if(!this.debug)return this._nullBind;var r=new function(){this[e]=i};(this._current?this._current:this.gui).add(r,e)}open(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).open()}close(){if(!this.debug)return this._nullBind;(this._current?this._current:this.gui).close()}addFolder(e){return this.debug?(this.folders[e]?this._current=this.folders[e]:(this._current=this.gui.addFolder(e),this.folders[e]=this._current),this._current):this._nullBind}removeFolder(e){if(!this.debug)return this._nullBind;let i=this.folders[e];i&&(this.gui.removeFolder(i),this._current=null,delete this.folders[e])}endFolder(){if(!this.debug)return this._nullBind;this._current=null}_creatPanel(){let e=new Kc;return e.domElement.style.zIndex="10",e.domElement.parentElement.style.zIndex="10",e}_add(e,i,r,s,a,o){return e.add(i,r,s,a,o)}_addLabel(e,i){rt._add(e,{label:i},"label")}_addButton(e,i,r){var s=new function(){this[i]=r};e.add(s,i)}_addColor(e,i,r){return e.addColor(i[r],"rgb").name(r)}_addFolder(e,i){e.Folder==null&&(e.Folder={});let r=e.addFolder(i);return e.Folder[i]=r,r}_removeFolder(e,i){e.Folder&&e.Folder[i]&&e.removeFolder(e.Folder[i])}}let rt=new Lb;var Ob=Object.defineProperty,Nb=Object.getOwnPropertyDescriptor,Fb=(t,e,i,r)=>{for(var s=r>1?void 0:r?Nb(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Ob(e,i,s),s};let Wc=class extends $t{constructor(){super(),W.register("PBRLitSSSShader",PC);let t=new ct("PBRLitSSSShader","PBRLitSSSShader");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefault(),this.debug(),this.computes=[new G2(this)]}debug(){rt.addFolder("face"),rt.addColor({SkinColor:new Y},"SkinColor").onChange(t=>{let e=new Y;e.copyFromArray(t),this._SkinColor=e}),rt.add({skinPower:1},"skinPower",0,10).onChange(t=>{this._SkinPower=t}),rt.add({skinColorIns:1},"skinColorIns",0,10).onChange(t=>{this._SkinColorIns=t}),rt.add({roughness:1},"roughness",0,1).onChange(t=>{this._Roughness=t}),rt.add({metallic:1},"metallic",0,1).onChange(t=>{this._Metallic=t}),rt.add({curveFactor:1},"curveFactor",0,10).onChange(t=>{this.curveFactor=t}),rt.endFolder()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y(1,1,1)),this.setUniformVector4("materialF0",new oe(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformColor("skinColor",new Y(1,0,0)),this.setUniformFloat("skinPower",3.4),this.setUniformFloat("skinColorIns",.5),this.setUniformFloat("curveFactor",1)}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _SSSMap(t){this.setTexture("sssMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?zt.none:e.shaderState.cullMode}set _SkinColor(t){this.setUniformColor("skinColor",t)}set _SkinPower(t){this.setUniformFloat("skinPower",t)}set _SkinColorIns(t){this.setUniformFloat("skinColorIns",t)}set curveFactor(t){this.setUniformFloat("curveFactor",t)}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=Te.NONE:e.blendMode=Te.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Wc=Fb([Lr],Wc);var kb=Object.defineProperty,Qb=Object.getOwnPropertyDescriptor,zb=(t,e,i,r)=>{for(var s=r>1?void 0:r?Qb(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&kb(e,i,s),s};let jc=class extends $t{constructor(){super();let t=new ct("PBRLItShader","PBRLItShader");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y(0,0,0)),this.setUniformVector4("materialF0",new oe(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this._MainTex=I.res.grayTexture,this._BumpMap=I.res.normalTexture,this._MaskTex=I.res.maskTexture}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?zt.none:e.shaderState.cullMode}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=Te.NONE:e.blendMode=Te.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};jc=zb([Lr],jc);class iu{constructor(){n(this,"comName"),n(this,"data")}static parser(e){let i=e.readBytesArray(),r=new iu;r.comName=i.readUTF(),r.data=[];let s=i.readInt32();for(let a=0;a<s;a++){let o=new dg;o.formBytes(i),r.data.push(o)}return r}}class fo{constructor(){n(this,"name"),n(this,"parentName"),n(this,"position"),n(this,"rotation"),n(this,"scale"),n(this,"comDatas"),n(this,"child")}static parser(e){let i=e.readBytesArray(),r=new fo;r.name=i.readUTF(),r.parentName=i.readUTF(),r.position=i.readVector3(),r.rotation=i.readQuaternion(),r.scale=i.readVector3(),r.comDatas=[],r.child=[];let s=i.readInt32();for(let o=0;o<s;o++){const l=iu.parser(i);r.comDatas.push(l)}let a=i.readInt32();for(let o=0;o<a;o++){const l=fo.parser(i);r.child.push(l)}return r}}class nh extends Vt{constructor(){super(...arguments),n(this,"avatarDic"),n(this,"nodeData")}async parseBuffer(e){this.avatarDic={};let i=new eu(e,0);await pg.parserTexture(i,this,this.loaderFunctions),cg.parser(i,this),gg.parserMeshs(i,this),fg.parserMaterial(i,this),this.nodeData=this.parserPrefabNode(i),this.data=this.data=this.parserNodeTree(this.nodeData)}parserPrefabNode(e){return fo.parser(e)}parserNodeTree(e){let i=new me;if(i.localPosition=p.serialize(e.position),i.localQuaternion=ye.serialize(e.rotation),i.localScale=p.serialize(e.scale),i.name=e.name,e.comDatas)for(let r=0;r<e.comDatas.length;r++){const s=e.comDatas[r];let a=null,o=_0(s.comName);if(o){a=i.getOrAddComponent(o);for(let l=0;l<s.data.length;l++){const h=s.data[l];h.key in a&&(a[h.key]=h.getValue())}}}if(e.child&&e.child.length>0)for(let r=0;r<e.child.length;r++){let s=this.parserNodeTree(e.child[r]);i.addChild(s)}return i}verification(){if(this.data)return!0;throw new Error("verify failed.")}}n(nh,"useWebp",!0),n(nh,"format",xt.BIN);var Gb=Object.defineProperty,Vb=Object.getOwnPropertyDescriptor,Hb=(t,e,i,r)=>{for(var s=r>1?void 0:r?Vb(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Gb(e,i,s),s};let qc=class extends $t{constructor(){super(),this.create_opPass(),this.setDefine("USEC",!0),this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_HAIR",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefine("USE_HAIRCOLOR",!0),this.setDefault(),this.debug()}create_opPass(){W.register("HairShader_op",RC);let t=new ct("HairShader_op","HairShader_op");this.addRenderPass(t),t.setShaderEntry("VertMain","FragMain");let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,e.blendMode=Te.NONE,e.cullMode=zt.none,e.writeMasks[0]=GPUColorWrite.ALL}create_trPass(){W.register("HairShader_tr",MC);let t=new ct("HairShader_tr","HairShader_tr");this.addRenderPass(t),t.setShaderEntry("VertMain","FragMain");let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,e.depthWriteEnabled=!1,e.blendMode=Te.NORMAL,e.cullMode=zt.none,e.writeMasks[0]=GPUColorWrite.ALL,e.writeMasks[1]=0,e.writeMasks[2]=0,e.writeMasks[3]=0}debug(){rt.addFolder("Hair"),rt.addColor({HairColorStart:new Y},"HairColorStart").onChange(t=>{let e=new Y;e.copyFromArray(t),this._HairColor0=e}),rt.addColor({HairColorEnd:new Y},"HairColorEnd").onChange(t=>{let e=new Y;e.copyFromArray(t),this._HairColor1=e}),rt.addColor({specularColor:new Y},"specularColor").onChange(t=>{let e=new Y;e.copyFromArray(t),this._SpecularColor=e}),rt.add({roughness:1},"roughness",0,1).onChange(t=>{this._Roughness=t}),rt.add({metallic:1},"metallic",0,1).onChange(t=>{this._Metallic=t}),rt.add({alphaCutoff:1},"alphaCutoff",0,1).onChange(t=>{this._AlphaCutoff=t}),rt.add({backlit:1},"backlit",0,1,1e-4).onChange(t=>{this._BackLit=t}),rt.add({area:.1},"area",0,1,1e-4).onChange(t=>{this._Area=t}),rt.endFolder()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor0",new Y(3/255,2/255,2/255)),this.setUniformColor("baseColor1",new Y(2/255,2/255,2/255)),this.setUniformColor("emissiveColor",new Y(1,1,1)),this.setUniformVector4("materialF0",new oe(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(36/255,36/255,36/255)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",.1),this.setUniformFloat("metallic",.3),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",.1),this.setUniformFloat("ior",1.5),this.setUniformFloat("backlit",.3987),this.setUniformFloat("area",.0615)}set _MainTex(t){this.setTexture("baseMap",t)}set _IDMap(t){this.setTexture("idMap",t)}set _DepthMap(t){this.setTexture("depthMap",t)}set _RootMap(t){this.setTexture("rootMap",t)}set _AlphaMap(t){this.setTexture("alphaMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _HairColor0(t){this.setUniformColor("baseColor0",t)}set _HairColor1(t){this.setUniformColor("baseColor1",t)}set _SpecularColor(t){this.setUniformColor("specularColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _BackLit(t){this.setUniformFloat("backlit",t)}set _Area(t){this.setUniformFloat("area",t)}set _DoubleSidedEnable(t){let e=this.getSubShaders(xe.COLOR)[0];e.shaderState.cullMode=t?zt.none:e.shaderState.cullMode}set _SurfaceType(t){}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};qc=Hb([Lr],qc);var Yb=Object.defineProperty,Xb=Object.getOwnPropertyDescriptor,Kb=(t,e,i,r)=>{for(var s=r>1?void 0:r?Xb(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Yb(e,i,s),s};let Jc=class extends $t{constructor(){super();let t=new ct("UnLit","UnLit");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!1,e.castShadow=!1,e.receiveEnv=!1,e.acceptGI=!1,e.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new oe(0,0,1,1)),this.setUniformVector4("transformUV2",new oe(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformFloat("alphaCutoff",0)}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?zt.none:e.shaderState.cullMode}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=Te.NONE:e.blendMode=Te.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Jc=Kb([Lr],Jc);var Wb=Object.defineProperty,jb=Object.getOwnPropertyDescriptor,qb=(t,e,i,r)=>{for(var s=r>1?void 0:r?jb(e,i):e,a=t.length-1,o;a>=0;a--)(o=t[a])&&(s=(r?o(e,i,s):o(s))||s);return r&&s&&Wb(e,i,s),s};let ol=class extends Zt{constructor(){super(...arguments),n(this,"size"),n(this,"blockSize"),n(this,"walk"),n(this,"obs"),n(this,"colors"),n(this,"aPaths")}onGraphic(t){}};ol=qb([Ci(ol,"APatch")],ol);class Jb extends Yi{constructor(){super(),W.register("ColorLitShader",BC),this.shader=new $t;let e=new ct("ColorLitShader","ColorLitShader");e.passType=xe.COLOR,this.shader.addRenderPass(e),e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain"),e.setUniformColor("baseColor",new Y),e.setUniformColor("emissiveColor",new Y),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",0),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("alphaCutoff",0);let i=e.shaderState;i.acceptShadow=!0,i.receiveEnv=!0,i.acceptGI=!0,i.useLight=!0,e.setTexture("normalMap",I.res.normalTexture),e.setTexture("emissiveMap",I.res.blackTexture)}clone(){return null}debug(){}}n(Jb,"count",0);class Zb{constructor(){n(this,"clipName"),n(this,"loopTime"),n(this,"startTime"),n(this,"stopTime"),n(this,"sampleRate"),n(this,"useSkeletonPos"),n(this,"useSkeletonScale"),n(this,"positionCurves",new Map),n(this,"rotationCurves",new Map),n(this,"scaleCurves",new Map),n(this,"floatCurves",new Map)}formBytes(e){if(this.clipName=e.readUTF(),this.loopTime=!e.readInt32(),this.startTime=e.readFloat32(),this.stopTime=e.readFloat32(),this.sampleRate=e.readInt32(),this.useSkeletonPos=e.readInt32()>0,this.useSkeletonScale=e.readInt32()>0,this.useSkeletonPos){let s=e.readInt32();for(let a=0;a<s;a++){let o=new Tn;o.formBytes(e),this.positionCurves.set(o.path,o)}}let i=e.readInt32();for(let s=0;s<i;s++){let a=new Tn;a.formBytes(e),this.rotationCurves.set(a.path,a)}if(this.useSkeletonScale){let s=e.readInt32();for(let a=0;a<s;a++){let o=new Tn;o.formBytes(e),this.scaleCurves.set(o.path,o)}}let r=e.readInt32();for(let s=0;s<r;s++){let a=new Tn;a.formBytes(e),this.floatCurves.set(a.attribute,a)}}}class Tn{constructor(e=1){n(this,"path"),n(this,"attribute"),n(this,"propertys"),n(this,"preInfinity"),n(this,"postInfinity"),n(this,"rotationOrder"),n(this,"m_curves"),n(this,"k",0),n(this,"_cacheValue"),n(this,"_kValue"),this.k=e,this.m_curves=[],this.check()}check(){var e;for(let i=0;i<this.k;i++)(e=this.m_curves)[i]||(e[i]=new qC);switch(this.k){case 1:this._cacheValue=0;break;case 2:this._cacheValue=new Ne;break;case 3:this._cacheValue=new p;break;case 4:this._cacheValue=new oe;break}}get totalTime(){return this.m_curves[0].totalTime}addKeyFrame(e){for(let i=0;i<this.k;i++)this.m_curves[i].addKeyFrame(e.getK(i))}removeKeyFrame(e){for(let i=0;i<this.k;i++)this.m_curves[i].removeKeyFrame(e.getK(i))}getValue(e){switch(this.k){case 1:this._cacheValue=this.m_curves[0].getValue(e);break;case 2:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e);break;case 3:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e),this._cacheValue.z=this.m_curves[2].getValue(e);break;case 4:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e),this._cacheValue.z=this.m_curves[2].getValue(e),this._cacheValue.w=this.m_curves[3].getValue(e);break}return this._cacheValue}getKeyCount(){return this.m_curves[0].getKeyCount()}getKey(e){let i=[];for(let r=0;r<this.k;r++)i.push(this.m_curves[r].getKey(e));return i}formBytes(e){this.path=e.readUTF(),this.k=e.readInt32(),this.check(),this.attribute=e.readUTF(),this.propertys=this.attribute.split("."),this.preInfinity=e.readInt32(),this.postInfinity=e.readInt32(),this.rotationOrder=e.readInt32();let i=e.readInt32();for(let r=0;r<i;r++){let s=new hI(0);s.formBytes(e),this.addKeyFrame(s)}}}class $b{static calculateCubicBezierPoint(e,i,r,s,a){e>1&&(e=1),e<0&&(e=0);let o=1-e,l=o*o,h=o*o*o,u=e*e,c=e*e*e,d=i.mul(h),f=r.mul(3);f=f.mul(e),f=f.mul(l);let g=s.mul(3);g=g.mul(u),g=g.mul(o);let m=a.mul(c);return d=d.add(f),d=d.add(g),d=d.add(m),d}static bezierPoint(e,i,r,s){e>1&&(e=1),e<0&&(e=0);let a=1-e,o=a*a,l=e*e,h=i.mul(o),u=r.mul(2);u.scaleBy(a),u.scaleBy(e);let c=s.mul(l);return h=h.add(u),h=h.add(c),h}static calculateCubicBezierPoints(e,i,r){e>1&&(e=1),e<0&&(e=0);let s=1-e,a=s*s,o=s*s*s,l=e*e,h=e*e*e,u=i[r].mul(o),c=i[r+1].mul(3);c=c.mul(e),c=c.mul(a);let d=i[r+2].mul(3);d=d.mul(l),d=d.mul(s);let f=i[r+3].mul(h);return u=u.add(c),u=u.add(d),u=u.add(f),u}static bezierPathValue(e,i){e>1&&(e=1),e<0&&(e=0);let r=i.length,s=this.tmp_points;s.length=0;for(let a=1;a<r;++a)for(let o=0;o<r-a;++o){if(a==1){let h=new p;h.x=i[o].x*(1-e)+i[o+1].x*e,h.y=i[o].y*(1-e)+i[o+1].y*e,h.z=i[o].z*(1-e)+i[o+1].z*e,this.tmp_points.push(h);continue}let l=new p;l.x=s[o].x*(1-e)+s[o+1].x*e,l.y=s[o].y*(1-e)+s[o+1].y*e,l.z=s[o].z*(1-e)+s[o+1].z*e,s.push(l)}return s[0]}}n($b,"tmp_points",[]);var eI=(t=>(t[t.Open=0]="Open",t[t.Closed=1]="Closed",t))(eI||{}),tI=(t=>(t[t.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",t[t.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",t[t.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",t[t.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",t[t.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",t[t.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",t[t.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",t[t.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",t[t.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",t[t.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",t[t.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",t[t.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",t[t.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",t))(tI||{});function iI(t,e,i){let r=.3333333333333333,s=.5,a=t*r,o=a*a,l=o*a-a*e*s+i*s,h=-o+e*r,u=h*h*h,c=u+l*l;if(c>=0){let g=Math.sqrt(c)-l;return g=g>0?Math.pow(g,r):-Math.pow(-g,r),-a-h/g+g}let d=Math.sqrt(-u),f=Math.acos(-l/d);return d=Math.pow(d,r),d=d-h/d,f=-a+d*Math.cos(f*r),f}function Zc(t,e,i,r){let s=1e-5;if(Math.abs(t)<s)return Math.abs(e)>s?(r.r0=-i/e,1):0;let a=e*e-4*t*i;if(a<0)return 0;let o=.5/t,l=Math.sqrt(a);return r.r0=(l-e)*o,r.r1=(-l-e)*o,2}function rI(t,e,i,r,s){let a=0;if(Math.abs(e)>=1e-4){let o=i/e,l=r/e,h=s/e;t[0]=iI(o,l,h),a++;let u=e,c=i+e*t[0],d=r+i*t[0]+e*t[0]*t[0];a+=Zc(u,c,d,{r0:t[1],r1:t[2]})}else a+=Zc(i,r,s,{r0:t[1],r1:t[2]});return a}class Hr{constructor(){n(this,"coeff",[])}static EvalSegment(e,i){return e*(e*(e*i[0]+i[1])+i[2])+i[3]}}const Rs=class{constructor(){n(this,"segments",[]),n(this,"integrationCache",[]),n(this,"doubleIntegrationCache",[]),n(this,"times",[]),n(this,"segmentCount"),this.segments[Rs.kMaxNumSegments]=new Hr,this.integrationCache[Rs.kMaxNumSegments]=0,this.doubleIntegrationCache[Rs.kMaxNumSegments]=0,this.times[Rs.kMaxNumSegments]=0}calculateMinMax(t,e){t.x=Math.min(t.x,e),t.y=Math.max(t.y,e)}findMinMaxDoubleIntegrated(){let t=Ne.ZERO.clone(),e=20,i=1/e,r=i;for(let s=0;s<e;s++)this.calculateMinMax(t,this.evaluateDoubleIntegrated(r)),r+=i;return t}findMinMaxIntegrated(){let t=Ne.ZERO.clone(),e=[],i=[];for(let r=0;r<this.segmentCount;r++){let s=4*this.segments[r].coeff[0],a=3*this.segments[r].coeff[1],o=2*this.segments[r].coeff[2],l=1*this.segments[r].coeff[3],h=[],u=rI(h,s,a,o,l);for(let c=0;c<u;c++){let d=h[c]+e[r];d>=e[r]&&d<i[r]&&this.calculateMinMax(t,this.evaluateIntegrated(d))}this.calculateMinMax(t,this.evaluateIntegrated(i[r])),this.times[r]}return t}generateIntegrationCache(t){t.integrationCache[0]=0;let e=t.times[0],i=0;for(let r=1;r<t.segmentCount;r++){let s=t.segments[r-1].coeff;$c(s);let a=e-i;t.integrationCache[r]=t.integrationCache[r-1]+Hr.EvalSegment(a,s)*a,i=e,e=t.times[r]}}generateDoubleIntegrationCache(t){let e=0,i=0;for(let r=0;r<t.segmentCount;r++){t.doubleIntegrationCache[r]=e;let s=t.times[r]-i;s=Math.max(s,0),e+=Hr.EvalSegment(s,t.segments[r].coeff)*s*s+t.integrationCache[r]*s,i=t.times[r]}}integrate(){this.generateIntegrationCache(this);for(let t=0;t<this.segmentCount;t++)$c(this.segments[t].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let t=0;t<this.segmentCount;t++)aI(this.segments[t].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(t){let e=t.getKeyCount(),i=e-1;return t.getKey(0).time!=0&&i++,t.getKey(e-1).time!=1&&i++,i<=Rs.kMaxNumSegments}evaluateDoubleIntegrated(t){let e=0;for(let i=0;i<this.segmentCount;i++){if(t<=this.times[i]){let r=t-e;return this.doubleIntegrationCache[i]+this.integrationCache[i]*r+Hr.EvalSegment(r,this.segments[i].coeff)*r*r}e=this.times[i]}return 1}evaluateIntegrated(t){let e=0;for(let i=0;i<this.segmentCount;i++){if(t<=this.times[i]){let r=t-e;return this.integrationCache[i]+Hr.EvalSegment(r,this.segments[i].coeff)*r}e=this.times[i]}return 1}evaluate(t){let e=0;for(let i=0;i<this.segmentCount;i++){if(t<=this.times[i])return Hr.EvalSegment(t-e,this.segments[i].coeff);e=this.times[i]}return 1}buildCurve(t,e){let i=t.getKeyCount();this.segmentCount=1;let r=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=r,i!=0)if(i==1)this.segments[0]=new Hr,this.segments[0].coeff[3]=t.getKey(0).value*e;else{this.segmentCount=i-1;let s=0;t.getKey(0).time!=0&&(this.segments[0].coeff[3]=t.getKey(0).value,this.times[0]=t.getKey(0).time,s=1);for(let a=0;a<this.segmentCount;a++){let o;t.calculateCacheData(o,a,a+1,0),this.segments[a+s].coeff=o.coeff.concat(),this.times[a+s]=t.getKey(a+1).time}this.segmentCount+=s,t.getKey(i-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=t.getKey(i-1).value,this.segmentCount++),this.times[this.segmentCount-1]=r;for(let a=0;a<this.segmentCount;a++)this.segments[a].coeff[0]*=e,this.segments[a].coeff[1]*=e,this.segments[a].coeff[2]*=e,this.segments[a].coeff[3]*=e}return!0}};let sI=Rs;n(sI,"kMaxNumSegments",8);function aI(t){t[0]/=20,t[1]/=12,t[2]/=6,t[3]/=2}function $c(t){t[0]/=4,t[1]/=3,t[2]/=2,t[3]/=1}var nI=(t=>(t[t.kEMScalar=0]="kEMScalar",t[t.kEMOptimized=1]="kEMOptimized",t[t.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",t[t.kEMSlow=3]="kEMSlow",t))(nI||{}),oI=(t=>(t[t.kMMCScalar=0]="kMMCScalar",t[t.kMMCCurve=1]="kMMCCurve",t[t.kMMCTwoCurves=2]="kMMCTwoCurves",t[t.kMMCTwoConstants=3]="kMMCTwoConstants",t))(oI||{});class mi{}n(mi,"BACK",0),n(mi,"FRONT",1),n(mi,"IN",0),n(mi,"OUT",1),n(mi,"INTERSECT",2);class Bn{constructor(e=0,i=0,r=0,s=0){n(this,"a"),n(this,"b"),n(this,"c"),n(this,"d"),this.a=e,this.b=i,this.c=r,this.d=s}setTo(e=0,i=0,r=0,s=0){this.a=e,this.b=i,this.c=r,this.d=s}fromPoints(e,i,r){var s=i.x-e.x,a=i.y-e.y,o=i.z-e.z,l=r.x-e.x,h=r.y-e.y,u=r.z-e.z;this.a=a*u-o*h,this.b=o*l-s*u,this.c=s*h-a*l,this.d=-(this.a*e.x+this.b*e.y+this.c*e.z)}fromNormalAndPoint(e,i){this.a=e.x,this.b=e.y,this.c=e.z,this.d=-(this.a*i.x+this.b*i.y+this.c*i.z)}normalize(){var e=Math.sqrt(this.a*this.a+this.b*this.b+this.c*this.c);if(e>0){var i=1/e;this.a*=i,this.b*=i,this.c*=i,this.d*=i}return e}distance(e){return this.a*e.x+this.b*e.y+this.c*e.z+this.d}classifyPoint(e,i=.01){var r=this.distance(e);return r<-i?mi.BACK:r>i?mi.FRONT:mi.INTERSECT}toString(){return"Plane3D [a:"+this.a+", b:"+this.b+", c:"+this.c+", d:"+this.d+"]"}}n(Bn,"ALIGN_ANY",0),n(Bn,"ALIGN_XY_AXIS",1),n(Bn,"ALIGN_YZ_AXIS",2),n(Bn,"ALIGN_XZ_AXIS",3);const bg=class extends Ne{constructor(t=0,e=0){super(t,e),n(this,"u",0),n(this,"v",0),this.u=t,this.v=e}length(){return 0}static getUVSheet(t,e,i){let r=Math.floor(t%(e*i)),s=Math.floor(r/e),a=r%e;return new oe(s/e,a/i,1/e,1/i)}};let lI=bg;n(lI,"uv_0",new bg);class hI{constructor(e=0){n(this,"serializedVersion","2"),n(this,"time"),n(this,"tangentMode",0),n(this,"weightedMode",0),n(this,"propertyKeyFrame"),this.time=e,this.propertyKeyFrame={}}getK(e){return this.propertyKeyFrame[e]}split(e,i,r){switch(e){case H.single:{let s=this.getKeyFrame(0);s[r]=i}break;case H.float:{let s=this.getKeyFrame(0);s[r]=i}break;case H.vector2:{let s=i,a=this.getKeyFrame(0);a[r]=s.x;let o=this.getKeyFrame(1);o[r]=s.y}break;case H.vector3:{let s=i,a=this.getKeyFrame(0);a[r]=s.x;let o=this.getKeyFrame(1);o[r]=s.y;let l=this.getKeyFrame(2);l[r]=s.z}break;case H.vector4:{let s=i,a=this.getKeyFrame(0);a[r]=s.x;let o=this.getKeyFrame(1);o[r]=s.y;let l=this.getKeyFrame(2);l[r]=s.y;let h=this.getKeyFrame(3);h[r]=s.y}break;case H.quaternion:{let s=i,a=this.getKeyFrame(0);a[r]=s.x;let o=this.getKeyFrame(1);o[r]=s.y;let l=this.getKeyFrame(2);l[r]=s.z;let h=this.getKeyFrame(3);h[r]=s.w}break}}getKeyFrame(e){let i=this.propertyKeyFrame[e];return i||(i=new Kl,i.time=this.time,i.tangentMode=this.tangentMode,i.weightedMode=this.weightedMode,this.propertyKeyFrame[e]=i),i}formBytes(e){this.time=e.readFloat32();{let{t:i,v:r}=ir.parser(e);this.split(i,r,"value")}{let{t:i,v:r}=ir.parser(e);this.split(i,r,"inSlope")}{let{t:i,v:r}=ir.parser(e);this.split(i,r,"outSlope")}this.tangentMode=e.readInt32(),this.weightedMode=e.readInt32();{let{t:i,v:r}=ir.parser(e);this.split(i,r,"inWeight")}{let{t:i,v:r}=ir.parser(e);this.split(i,r,"outWeight")}}}class Gn{}n(Gn,"WalkAble",1);const oh=class{static SetConst(t){this.EPSILON=t,this.POWER_EPSILON=t*t}};let Vs=oh;n(Vs,"EPSILON",.1),n(Vs,"POWER_EPSILON",oh.EPSILON*oh.EPSILON);const lh=class extends p{constructor(t,e,i,r){super(e,i,r,0),n(this,"_pointId",0),this._pointId=t}get id(){return this._pointId}static equalPoint(t,e){return(t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y)+(t.z-e.z)*(t.z-e.z)<Vs.POWER_EPSILON}static calcDistance(t,e){return lh.CALC_VECTOR3D3.setTo(t.x-e.x,t.y-e.y,t.z-e.z),lh.CALC_VECTOR3D3.length}};let kt=lh;n(kt,"CALC_VECTOR3D1",new p),n(kt,"CALC_VECTOR3D2",new p),n(kt,"CALC_VECTOR3D3",new p),n(kt,"CALC_VECTOR3D4",new p),n(kt,"CALC_VECTOR3D5",new p);class Ui extends kt{constructor(e,i){super(e.id,0,0,0),n(this,"_ownerPoint"),n(this,"_ownerEdge"),n(this,"radius",0),this._ownerEdge=i,this._ownerPoint=e}get ownerPoint(){return this._ownerPoint}get ownerEdge(){return this._ownerEdge}scalePoint(e=.7){var i=new Ui(this._ownerPoint,this._ownerEdge);return i.copyFrom(this),i.decrementBy(this._ownerPoint),i.scaleBy(e),i.radius=i.length,i.incrementBy(this._ownerPoint),i}}const qi=class{constructor(t,e){if(n(this,"_edgeMask",0),n(this,"_edgeSize",0),n(this,"_pointA"),n(this,"_pointB"),n(this,"_triangleOwners"),n(this,"_centerPoint"),n(this,"_edgeDirA2B"),n(this,"crossPoint"),n(this,"fatPointA"),n(this,"fatPointB"),this._pointA=t,this._pointB=e,t.id>=e.id)throw new Error("edge point order error!!!");this._triangleOwners=new Array,this._centerPoint=new p,this._edgeMask=Gn.WalkAble,kt.CALC_VECTOR3D1.setTo(t.x-e.x,t.y-e.y,t.z-e.z),this._edgeSize=kt.CALC_VECTOR3D1.length,this._centerPoint.setTo((t.x+e.x)/2,(t.y+e.y)/2,(t.z+e.z)/2)}get size(){return this._edgeSize}get triangleOwners(){return this._triangleOwners}get centerPoint(){return this._centerPoint}initFatPoints(t){this._edgeDirA2B=this._pointB.subtract(this._pointA),this._edgeDirA2B.normalize(),this.fatPointA=this.fatPointA||new Ui(this._pointA,this),this.fatPointB=this.fatPointB||new Ui(this._pointB,this),this.fatPointA.radius!=t&&(qi.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),qi.CALC_FAT_VECTOR.scaleBy(t),qi.CALC_FAT_VECTOR.incrementBy(this._pointA),this.fatPointA.copyFrom(qi.CALC_FAT_VECTOR),this.fatPointA.radius=t),this.fatPointB.radius!=t&&(qi.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),qi.CALC_FAT_VECTOR.scaleBy(-t),qi.CALC_FAT_VECTOR.incrementBy(this._pointB),this.fatPointB.copyFrom(qi.CALC_FAT_VECTOR),this.fatPointB.radius=t)}getFatPoint(t){return t==this._pointA?this.fatPointA:this.fatPointB}getAnotherFatPoint(t){return t==this._pointA?this.fatPointB:this.fatPointA}getAnotherPoint(t){return t==this._pointA?this._pointB:this._pointA}containsPoint(t){return kt.equalPoint(t,this._pointA)?this._pointA:kt.equalPoint(t,this._pointB)?this._pointB:null}addTriangleOwners(t){if(t.edges.indexOf(this)==-1)throw new Error("the edge is not belong triangle!!!");this._triangleOwners.indexOf(t)==-1&&this._triangleOwners.push(t)}getPublicPoint(t){return this._pointA==t._pointA||this._pointA==t._pointB?this._pointA:this._pointB==t._pointA||this._pointB==t._pointB?this._pointB:null}getEqualPoint(t){return kt.equalPoint(t,this._pointA)?this._pointA:kt.equalPoint(t,this._pointB)?this._pointB:null}get pointA(){return this._pointA}get pointB(){return this._pointB}get walkAble(){return(this._edgeMask&Gn.WalkAble)==Gn.WalkAble}testMask(t){return(this._edgeMask&t)==t}};let uI=qi;n(uI,"CALC_FAT_VECTOR",new p);const ge=class{constructor(){n(this,"endPoint"),n(this,"curPoint"),n(this,"rayA"),n(this,"rayB"),n(this,"rayAPoint"),n(this,"rayBPoint"),n(this,"cornerPoint"),n(this,"cornerEdge")}continuePass(t,e,i){this.resetData(),this.curPoint=t,this.endPoint=e,this.cornerEdge=i}passEdge(t,e,i,r){if((this.rayA==null||this.rayB==null)&&(this.rayA=ge.RAY_1,this.rayB=ge.RAY_2,this.rayAPoint=t.pointA,this.rayBPoint=t.pointB,this.rayA.setTo(this.rayAPoint.x-this.curPoint.x,0,this.rayAPoint.z-this.curPoint.z),this.rayB.setTo(this.rayBPoint.x-this.curPoint.x,0,this.rayBPoint.z-this.curPoint.z)),r)return this.checkEndPoint(i);if(ge.TEST_RAY.setTo(i.x-this.curPoint.x,0,i.z-this.curPoint.z),this.isPointAtCenter(ge.TEST_RAY,this.rayA,this.rayB)){this.hasCrossPoint(e.pointA,e.pointB,this.rayAPoint,this.rayA)?(this.rayB.copyFrom(ge.TEST_RAY),i instanceof kt?this.rayBPoint=i:this.rayBPoint=null):(this.rayA.copyFrom(ge.TEST_RAY),i instanceof kt?this.rayAPoint=i:this.rayAPoint=null);var s=e.getAnotherPoint(i);ge.TEST_RAY.setTo(s.x-this.curPoint.x,0,s.z-this.curPoint.z),(s==this.rayAPoint||s==this.rayBPoint||this.isPointAtCenter(ge.TEST_RAY,this.rayA,this.rayB))&&(this.cornerEdge=e)}else{var a;if(ge.TEST_RAY_1.copyFrom(e.pointA),ge.TEST_RAY_1.decrementBy(this.curPoint),ge.TEST_RAY_2.copyFrom(e.pointB),ge.TEST_RAY_2.decrementBy(this.curPoint),ge.TEST_RAY_1.y=0,ge.TEST_RAY_2.y=0,this.isPointAtCenter(this.rayA,ge.TEST_RAY_1,ge.TEST_RAY_2)||this.isPointAtCenter(this.rayB,ge.TEST_RAY_1,ge.TEST_RAY_2)?a=!1:a=!0,a)return this.isPointAtCenter(this.rayA,ge.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1}return!0}checkEndPoint(t){return ge.TEST_RAY.setTo(t.x-this.curPoint.x,0,t.z-this.curPoint.z),this.isPointAtCenter(ge.TEST_RAY,this.rayA,this.rayB)?!0:(this.isPointAtCenter(this.rayA,ge.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1)}calcCrossEdge(t,e,i){return this.calcCrossPoint(t.fatPointA,t.fatPointB,e,i)}calcCrossPoint(t,e,i,r){ge.CALC_CROSS_POINT.copyFrom(e),ge.CALC_CROSS_POINT.decrementBy(t);let s=ge.CALC_CROSS_POINT.x*r.z-r.x*ge.CALC_CROSS_POINT.z;var a=0;return s!=0&&(a=((t.z-i.z)*r.x-(t.x-i.x)*r.z)/s),a>1?a=1:a<0&&(a=0),ge.CALC_CROSS_POINT.scaleBy(a),ge.CALC_CROSS_POINT.incrementBy(t),ge.CALC_CROSS_POINT.clone()}calcCrossPointOut(t,e,i,r){ge.CALC_CROSS_POINT.copyFrom(e),ge.CALC_CROSS_POINT.decrementBy(t);var s=((t.z-i.z)*r.x-(t.x-i.x)*r.z)/(ge.CALC_CROSS_POINT.x*r.z-r.x*ge.CALC_CROSS_POINT.z);return s<=1&&s>=0?null:(ge.CALC_CROSS_POINT.scaleBy(s),ge.CALC_CROSS_POINT.incrementBy(t),ge.CALC_CROSS_POINT.clone())}hasCrossPoint(t,e,i,r){ge.CALC_CROSS_TEST.copyFrom(e),ge.CALC_CROSS_TEST.decrementBy(t);var s=((t.z-i.z)*r.x-(t.x-i.x)*r.z)/(ge.CALC_CROSS_TEST.x*r.z-r.x*ge.CALC_CROSS_TEST.z);return s<=1&&s>=0}isPointAtCenter(t,e,i){var r=e.crossProduct(t);if(r.length==0&&t.length<e.length)return!0;var s=i.crossProduct(t);return s.length==0&&t.length<i.length?!0:(r.normalize(),s.normalize(),r.incrementBy(s),r.length<.01)}resetData(){this.cornerEdge=null,this.cornerPoint=null,this.curPoint=null,this.rayA=this.rayB=null,this.rayAPoint=this.rayBPoint=null,ge.RAY_1.setTo(0,0,0),ge.RAY_2.setTo(0,0,0)}};let Ar=ge;n(Ar,"RAY_1",new p),n(Ar,"RAY_2",new p),n(Ar,"TEST_RAY",new p),n(Ar,"TEST_RAY_1",new p),n(Ar,"TEST_RAY_2",new p),n(Ar,"CALC_CROSS_POINT",new p),n(Ar,"CALC_CROSS_TEST",new p);const Zr=class{constructor(){n(this,"_aiRadius",0),n(this,"_router"),n(this,"_result"),n(this,"_tempPublicEdgeList",new Array),n(this,"_tempSamePlaneList",new Array),this._router=new Ar}searchPath(t,e,i,r=0){return r<=0&&(r=1),this._aiRadius=r*1.5,this.searchEnable(t,e,i)?(this.search(t,e,i),!0):!1}get path(){return this._result}searchEnable(t,e,i){return!(t==null||e==null||i==null||i[0].plane.classifyPoint(t,Vs.EPSILON)!=mi.INTERSECT||i[i.length-1].plane.classifyPoint(e,Vs.EPSILON)!=mi.INTERSECT)}search(t,e,i){this._tempPublicEdgeList.length=0,this._tempSamePlaneList.length=0;var r=0,s=i.length-1,a,o,l,h;for(r=0;r<s;r++)o=i[r].getPublicEdge(i[r+1]),o.crossPoint=null,o.initFatPoints(this._aiRadius),this._tempPublicEdgeList.push(o),a=i[r],h=a.plane,a=i[r+1],l=a.getEdgeAgainstPoint(o),this._tempSamePlaneList.push(h.classifyPoint(l,Vs.EPSILON)==mi.INTERSECT);this._router.continuePass(t,e,this._tempPublicEdgeList[0]),s=this._tempPublicEdgeList.length;var u,c,d,f;for(r=0;r<s;r++)o=this._tempPublicEdgeList[r],a=i[r+1],f=r==s-1,f?l=e:l=a.getEdgeAgainstPoint(o),d=this._router.passEdge(o,this._tempPublicEdgeList[r+1],l,f),d||(u=this._router.cornerPoint,c=this._router.cornerEdge,r=this._tempPublicEdgeList.indexOf(c),this._router.continuePass(u,e,this._tempPublicEdgeList[r+1]));this.pushAllPathPoint2(t,e),this._result.length>=3&&(this.optimusTerminusFat(),this.optimusByRadius());let g=[];for(let m of this._result)g.push(new p().copyFrom(m));this._result=g}optimusTerminusFat(){var t,e,i;i=this._result[1],i instanceof Ui&&(t=i),i=this._result[this._result.length-2],i instanceof Ui&&(e=i),t&&(this._result[1]=t.scalePoint()),e&&t!=e&&(this._result[this._result.length-2]=e.scalePoint())}pushAllPathPoint2(t,e){var i=this._tempPublicEdgeList.length,r,s;this._result=new Array,this._result.push(t);for(var a=t,o,l,h,u=0;u<i;u++)if(r=this._tempPublicEdgeList[u],l=null,r.crossPoint)l=this.getFatPoint(r,r.crossPoint),l?this._result.push(l):this._result.push(r.crossPoint),a=r.crossPoint;else{s=null,o=null;for(var c=u+1;c<i&&(s=this._tempPublicEdgeList[c],o=s.crossPoint,!o);c++);o==null&&(o=e),l=this.getFatPoint(r,o),l?this._result.push(l):(o==a?h=o.clone():(Zr.CROSS_TEST_DIRECTION.setTo(o.x-a.x,0,o.z-a.z),h=this._router.calcCrossEdge(r,a,Zr.CROSS_TEST_DIRECTION)),this._result.push(h))}this._result.push(e)}optimusByRadius(){var t=new Array;t.length=this._result.length;var e=this._result.length-2,i,r,s,a,o,l,h,u,c,d,f,g,m;for(m=0;m<e;m++)h=u=c=null,a=o=l=null,f=!1,g=null,i=this._result[m],r=this._result[m+1],s=this._result[m+2],i instanceof Ui&&(a=i),r instanceof Ui&&(o=r),s instanceof Ui&&(l=s),a&&(h=a.ownerPoint),o&&(u=o.ownerPoint),l&&(c=l.ownerPoint),h&&u&&h==u&&u!=c&&(f=!0),c&&u&&c==u&&h!=u&&(f=!0),f&&(Zr.CROSS_TEST_DIRECTION.copyFrom(i),Zr.CROSS_TEST_DIRECTION.decrementBy(s),d=o.ownerEdge,f=this._router.hasCrossPoint(d.pointA,d.pointB,s,Zr.CROSS_TEST_DIRECTION),f&&(g=this._router.calcCrossPointOut(u,r,s,Zr.CROSS_TEST_DIRECTION)),g&&(t[m+1]=g))}getFatPoint(t,e){if(t==null)return null;var i;e instanceof Ui&&(i=e);var r;return i?r=i.ownerPoint:r=t.getEqualPoint(e),r==null?null:(i=t.getFatPoint(r),i)}};let cI=Zr;n(cI,"CROSS_TEST_DIRECTION",new p);class Vn extends wt{constructor(e=1,i=1,r=1){super(),n(this,"width"),n(this,"height"),n(this,"depth"),this.width=e,this.height=i,this.depth=r,this.initVertex()}initVertex(){let e=this.width/2,i=this.height/2,r=this.depth/2;this.bounds=new _t(p.ZERO.clone(),new p(this.width,this.height,this.depth));let s=new Float32Array([-e,i,r,e,i,r,e,i,-r,-e,i,-r,-e,i,r,e,i,-r,e,-i,r,-e,-i,r,-e,-i,-r,e,-i,-r,e,-i,r,-e,-i,-r,-e,-i,r,-e,i,r,-e,i,-r,-e,-i,-r,-e,-i,r,-e,i,-r,e,i,r,e,-i,r,e,-i,-r,e,i,-r,e,i,r,e,-i,-r,e,i,r,-e,i,r,-e,-i,r,-e,-i,r,e,-i,r,e,i,r,e,-i,-r,-e,-i,-r,-e,i,-r,e,i,-r,e,-i,-r,-e,i,-r]),a=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),o=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),l=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],h=new Uint16Array(l.reverse());this.setIndices(h),this.setAttribute(z.position,s),this.setAttribute(z.normal,a),this.setAttribute(z.uv,o),this.setAttribute(z.TEXCOORD_1,o),this.addSubGeometry({indexStart:0,indexCount:l.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class ll{static initHeap(){this.boxGeo||(this.boxGeo=new Vn),this.sphere||(this.sphere=new Xl(1,35,35)),this.material||(this.material=new lr)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let e=new me,i=e.addComponent(Pe);return i.geometry=this.boxGeo,i.material=this.material.clone(),i.castShadow=!0,e}static GetSingleCube(e,i,r,s,a,o){this.initHeap();let l=new lr;l.roughness=.5,l.metallic=.1,l.baseColor=new Y(s,a,o,1);let h=new me,u=h.addComponent(Pe);return u.castGI=!0,u.geometry=new Vn(e,i,r),u.material=l,h}static GetSingleSphere(e,i,r,s){this.initHeap();let a=new lr;a.baseColor=new Y(i,r,s,1);let o=new me,l=o.addComponent(Pe);return l.castGI=!0,l.geometry=new Xl(e,20,20),l.material=a,o}static get Sphere(){this.initHeap();let e=new me,i=e.addComponent(Pe);return i.geometry=this.sphere,i.material=this.material,e}static GetSingleCube2(e,i=10){this.initHeap();let r=new me,s=r.addComponent(Pe);return s.castShadow=!1,s.geometry=new Vn(i,i,i),s.material=e,r}}n(ll,"boxGeo"),n(ll,"sphere"),n(ll,"material");const Ig=class{static load(t){let e=localStorage.getItem(t);return e?this.localData=JSON.parse(e):(this.localData={},Ig.save(t,this.localData)),this.localData}static save(t,e){let i=JSON.stringify(e);localStorage.setItem(t,i)}};let dI=Ig;n(dI,"localData");class fI{constructor(e=600,i=400){}async init(){await this.initEngine(),await this.initScene()}async initEngine(){await I.init()}async initScene(){let e=new T2;e.addComponent(YC);let i=new me,r=i.addComponent(Lh);r.perspective(60,window.innerWidth/window.innerHeight,1,5e3),r.object3D.addComponent(r2).setCamera(0,0,15),e.addChild(i);let a=new me,o=a.addComponent(Qa);a.rotationX=45,a.rotationY=30,o.intensity=2,e.addChild(a);const l=new me;let h=l.addComponent(Pe);h.geometry=new Vn(5,5,5),h.material=new lr,e.addChild(l);let u=new U2;u.scene=e,u.camera=r,I.startRenderView(u)}}const gI={name:"Home",setup(t,e){const i=Br(""),r=c0(),{userId:s}=n_(r);async function a(){new fI().init()}return Od(()=>{i.value=s.value}),()=>ue("div",null,[ue(jA,null,{default:()=>[ue(YA,{title:"单元格",value:"内容"},{title:()=>ue("span",null,[xl("这是用户ID: "),i.value]),value:()=>ue(kA,{onClick:a,type:"primary"},{default:()=>[xl("主要按钮")]})})]})])}};const pI=(t,e)=>{const i=t.__vccOpts||t;for(const[r,s]of e)i[r]=s;return i},mI=pI(gI,[["__scopeId","data-v-782c3362"]]),AI=[{path:"/",redirect:"/home"},{path:"/home",component:mI}],_I=h0({history:w_(),routes:AI});(function(e,i){var r=i.documentElement,s=e.devicePixelRatio||1;function a(){i.body?i.body.style.fontSize=12*s+"px":i.addEventListener("DOMContentLoaded",a)}a();function o(){var u=r.clientWidth/10;r.style.fontSize=u+"px"}if(o(),e.addEventListener("resize",o),e.addEventListener("pageshow",function(u){u.persisted&&o()}),s>=2){var l=i.createElement("body"),h=i.createElement("div");h.style.border=".5px solid transparent",l.appendChild(h),r.appendChild(l),h.offsetHeight===1&&r.classList.add("hairlines"),r.removeChild(l)}})(window,document);const kr=typeof require<"u"?function(){return require("electron")}():function(){return console.error('If you need to use "electron" in the Renderer process, make sure that "nodeIntegration" is enabled in the Main process.'),{}}();let Hn;if(typeof document>"u"){Hn={};const t=["invoke","postMessage","send","sendSync","sendTo","sendToHost","addListener","emit","eventNames","getMaxListeners","listenerCount","listeners","off","on","once","prependListener","prependOnceListener","rawListeners","removeAllListeners","removeListener","setMaxListeners"];for(const e of t)Hn[e]=()=>{throw new Error(`ipcRenderer doesn't work in a Web Worker.
You can see https://github.com/electron-vite/vite-plugin-electron/issues/69`)}}else Hn=kr.ipcRenderer;kr.clipboard;kr.contextBridge;kr.crashReporter;const vI=Hn;kr.nativeImage;kr.shell;kr.webFrame;kr.deprecate;window.isHasScreen===void 0&&(window.isHasScreen=!1);vI.on("main-process-message",(t,...e)=>{e.length>0&&(window.isHasScreen=e[0].isHasScreen)});const ru=jm(JA);ru.use(_I);ru.use($A());ru.mount("#app").$nextTick(window.removeLoading);
//# sourceMappingURL=index-14791f72.js.map
